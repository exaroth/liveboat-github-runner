{"id":"4W3i2hyrJTVfcLq85rWgduVQ3y3BMzrSD4pVUCMqPpFhmXWpqxQ","title":"Hacker News: Front Page","displayTitle":"HN Front","url":"https://hnrss.org/frontpage?points=75","feedLink":"https://news.ycombinator.com/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":16,"items":[{"title":"One in four 2020 Tesla Model 3 failed the Danish periodic inspection in 2024","url":"https://fdm.dk/nyheder/bilist/2025-01-populaer-tesla-model-dumper-med-et-brag-til-syn","date":1737967966,"author":"asp1","guid":197,"unread":true,"content":"<h2>Tesla har mere end hver 3. af alle fejl</h2><h2></h2>","contentLength":39,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42838855"},{"title":"Once You're Laid Off, You'll Never Be the Same Again","url":"https://mertbulan.com/2025/01/26/once-you-are-laid-off-you-will-never-be-the-same-again/","date":1737966161,"author":"mertbio","guid":196,"unread":true,"content":"<p>It happened on the afternoon of May 4th. A message from a colleague—who has since become a good friend—popped up on my screen, urging me to check my emails. When I opened my inbox, there it was: an email from the COO. The email announced an impending company-wide layoff and mentioned that, within a few minutes, I’d receive another email letting me know whether I was impacted. A short while later, the second email arrived. I was among those affected—along with most of my team.</p><p>The situation felt surreal. One by one, my colleagues posted in our team chat, confirming they’d been impacted too. Before our accounts were locked, we quickly jumped on a call. We had just 30 minutes to have one final conversation as a team, to say our goodbyes. It was a bittersweet moment, sharing those last words with people I’d worked so closely with.</p><p>It was difficult to process what was happening. Just ten months earlier, the company had gone through another round of layoffs. And at the beginning of the year, during the company’s kick-off event, the president assured us there wouldn’t be any more layoffs. They even said the company was performing well financially. So, why was this happening?</p><p>Looking back, my colleagues and I were not entirely surprised by the layoff. There were several warning signs that hinted something was coming. I want to share these signs so you can be better prepared if you ever face a similar situation.</p><h3>1. Cancellation of Team Events</h3><p>One of the earliest indicators was the sudden cancellation of team events. When I heard from other teams that their off-site events were canceled without any clear explanation, it immediately raised red flags. These cancellations often signal that the company is going to announce something about the team structure and doesn’t want you to be with your team in the same place. This is because one of your teammates—or you—might be impacted, and you’d need to cancel flights, hotels, etc. To avoid dealing with these logistical issues, the company preemptively cancels the event.</p><h3>2. Unexpected Notifications About Packages</h3><p>Some employees at the company received notifications about packages scheduled to arrive at their homes. This happens because services like DHL notify you through their app when a package is on the way. If your company requires you to return your work equipment, like a laptop, after being laid off, they often arrange for these shipping boxes to be delivered in advance. If you unexpectedly see a notification about a package from your company’s IT provider, it’s a strong sign that a layoff is imminent—and you may be impacted.</p><h3>3. Lack of Vision from Leadership</h3><p>The absence of a clear vision from leadership is one of the most common signs of an impending layoff. During off-site or kick-off events, you might notice that leaders seem unsure of the company’s direction. When this lack of clarity is followed by team restructuring, and then another restructuring just a few months later, it becomes evident that the leadership is struggling to find focus. Ultimately, this cycle often ends with a layoff, accompanied by yet another round of restructuring for those who remain.</p><h3>4. Sudden, Vague Meetings</h3><p>Another sign is the appearance of unexpected, vague meetings on your calendar. These meetings are marked as “important” with no clear agenda, and attendance is mandatory. If this happens, it’s often a precursor to a layoff announcement. Public companies, in particular, may choose to send layoff notices via email to align the timing with when they notify investors.</p><h3>5. Timing Around Quarterly Results</h3><p>If your company is publicly traded, layoffs are frequently announced in conjunction with quarterly earnings reports. This can be especially stressful because, leading up to every financial results announcement, employees may anxiously wait to see if layoffs will accompany the news. If no layoffs are announced, you know you’re safe—for at least one more quarter.</p><p>When I looked back on my time at the company and all the things I had accomplished, I was surprised to be impacted by the layoffs. It wasn’t because I thought I was better than others—it was because I believed I was doing more than what was expected of me. However, during a layoff, it seems that who you are and what you do doesn’t matter. In most cases, the decision is made by people who don’t even know you. This realization made me question the concept of work, which is part of the reason I’m writing this blog post.</p><p>I was hired as a Backend Developer. When I joined my team, I noticed a project that needed a developer to implement the client-side feature in React Native. Although I had no prior experience with React Native, I had worked with React before, so I volunteered for the task. I shipped the feature without any issues, received positive feedback from my team and lead, and eventually, my title was changed to Developer, making me a full-stack developer.</p><p>In some instances, I worked on projects independently, always aligning with my team and ensuring my work was reviewed. I would implement the backend first and then move on to the client-side. This was my expected role, and in performance reviews, I was consistently rated as a high performer. Yet, I was always doing more than what was expected of me.</p><p>Sometimes, I worked on small features I thought would enhance the app. These features might not have been used by many, but they provided significant value to heavy users. Occasionally, I shipped these under the radar. I created dashboards to measure the impact of my team’s work, helping us focus on features that would bring the most value to users. I also built proof-of-concept features based on user requests to show leadership how easily they could be implemented, advocating for their prioritization. Additionally, I participated in hackdays, creating projects to showcase innovative ideas.</p><p>On several occasions, I was selected for special projects outside my team. These projects often came directly from the CEO, and I was chosen because I constantly wanted to do more for the company and our users. For some of these projects, I worked more than eight hours a day, including weekends. A few of these initiatives were mentioned in financial reports, praised by the CEO during all-hands meetings, or retweeted multiple times by the CEO on Twitter.</p><p>Over time, I gained the attention of senior management in my business unit, which consisted of about 400 people. I began directly interacting with the VP of Product and the VP of Engineering, both of whom were four or five levels above me. Occasionally, the VP of Product would message me directly to ask if a feature was feasible to implement. Later, the VP of Engineering started scheduling regular one-on-one meetings with me, which was highly uncommon. During these calls, he told me multiple times that if I continued working at this level, I could quickly climb the ladder to become a Staff Developer. He wasn’t the only one saying this to me.</p><p>Beyond my immediate role, I also sought ways to contribute to the broader company. Whenever a new tool was introduced, I would explore it, write detailed articles about my findings, and share them to help other teams use the tool more effectively.</p><p>I referred many friends and former colleagues to the company because I believed in its mission. If I recall correctly, I referred over ten people, four of whom received offers, and three were ultimately hired. I also encouraged many others to consider joining the company.</p><p>I even initiated discussions about translating our website into Turkish to support the many customers we had in Turkey. A few weeks before the layoff announcement, I was helping a team working on this project find a Turkish-speaking content designer because they noticed my willingness to assist.</p><p>Additionally, I tried to convince friends who were CTOs at major e-commerce companies to migrate their websites to our platform. Whenever I received job offers from e-commerce companies on LinkedIn, I used those opportunities to promote our platform instead. I passed along leads to the sales team and later noticed that one of those companies had indeed moved to our platform.</p><p>I’m not sharing all of this to brag but to highlight that, in the end, none of it mattered. On the day I announced I had been laid off, I received numerous messages from colleagues, even those I hadn’t worked with directly, telling me that I had inspired and motivated them. While those messages were heartwarming, they didn’t change the reality: to the company, I was just a row in an Excel sheet.</p><p>Layoffs were uncommon when I started working, and being a developer felt like an incredibly safe job. In most professions, the unspoken rule was simple: if you performed well and the company was financially stable, your job was secure.</p><p>But today, companies are announcing layoffs alongside record-breaking financial results. You work hard, focus on impactful projects, and receive praise from your lead—only to find yourself let go by someone who likely doesn’t even know you exist. It feels as though the trust between companies and employees is now broken. Companies, it seems, are either unaware of this shift or unwilling to address it. And frankly, I’m not sure how they could fix it.</p><p>What’s particularly strange is that the layoffs predominantly affect individual contributors—the people who have little say in deciding the company’s direction. These are the team members closest to the users, the ones who spend hours planning how to improve the product. But after those plans are made, leadership often swoops in and redirects efforts toward entirely different goals. You trust their judgment, work on their priorities, and deliver on time. Then, when the arbitrary goals they set aren’t met, the company decides to cut staff. Those who made the poor decisions remain, and some are even promoted, while the people carrying out the work are let go. It feels surreal—like <a rel=\"nofollow noopener\" target=\"_blank\" href=\"https://www.youtube.com/watch?v=u48vYSLvKNQ\">an episode from Silicon Valley</a>—but this is how big companies operate.</p><p>I’m not alone in feeling this way. Many friends and ex-colleagues who’ve been laid off in recent years share similar experiences. They’ve lost trust in their employers. They believe their efforts won’t matter in the long run and anticipate being part of the next layoff cycle. As a result, they only do what’s strictly required to avoid a performance improvement plan. No one goes above and beyond anymore; no one takes initiative to improve things. Why? Because it doesn’t matter. They’ve seen firsthand that it changes nothing.</p><p>For those like me who’ve experienced layoffs, work has become just that—work. You do what’s assigned, and if your company squanders your potential or forces you to waste time on unnecessary projects, you simply stop caring. You collect your paycheck at the end of the month, and that’s it. This is the new modern work: no more striving to be 40% better every year.</p><p>Since I was working for a German entity of a company, I want to address a common myth about job security in Germany. Many people believe that it’s nearly impossible to be fired in Germany. While this is partially true for individuals who have completed their probation period, it doesn’t hold up in the context of layoffs. If a company decides to lay off, for instance, 40 employees, German law doesn’t prevent this. Instead, the law enforces a social scoring system to determine who is affected, prioritizing the protection of the most vulnerable employees, such as those with children. In this sense, when it comes to layoffs, the difference between Germany and the US is minimal.</p><p>When I talk to friends who were laid off in recent years, we often reflect on what we could have done differently. Here are some of the lessons we’ve learned:</p><ul><li><strong>Stick to your contract hours.</strong> If your contract says 40 hours, work 40 hours—no more, no less. Protect your personal time and well-being.</li><li><strong>Avoid going above and beyond with initiatives.</strong> Many companies encourage impactful work to earn promotions, but instead of chasing internal advancements, focus on switching companies to achieve your next career step.</li><li><strong>Always keep interviewing.</strong> One of the biggest mistakes I’ve seen is stopping interviews after starting a new job, trusting in the company. Instead, continuously explore opportunities so that if a layoff happens, you already have other options lined up.</li><li><strong>Leverage external offers for salary growth.</strong> Companies often resist giving substantial raises to existing employees but pay top dollar for new hires. Regularly interview elsewhere, and if you get an offer with a 20% or higher salary increase, consider taking it. Many people have seen their compensation triple or quadruple this way in just a few years.</li><li><strong>Don’t overthink your résumé.</strong> Worrying about short experiences on your CV isn’t worth it. You can always tailor your résumé—leave out brief roles, or consolidate short-term jobs as freelance experience. Ultimately, your résumé is just a starting point; your skills will be assessed during the interview process.</li></ul><p>You’ve probably noticed that I didn’t mention the name of the company I was laid off from. That’s because I believe it’s irrelevant. Everything I’ve shared reflects the current state of the tech industry. It might differ at very small companies, but once you work at a company with more than 100 employees, you’ll likely encounter many of the same patterns I’ve described.</p><p>I’ve wanted to write about this topic for a long time, but it’s been difficult to find the energy. The subject itself is a deep disappointment for me, and every time I reflect on layoffs, it makes me profoundly sad. It’s a stark reminder of how companies treat workers as disposable. Before you join, they go to great lengths to make you feel valued and excited to accept their offer. You meet multiple people, and some even offer signing bonuses. But when layoffs come, you’re reduced to a name on a list. During the exit interview, a random person from the company reads a prepared script and can’t answer your questions. The HR team that once worked to make you feel valued doesn’t even conduct an actual conversation with you. That random person becomes the last connection you have to a company you spent years at.</p><p>The layoff fundamentally changed how I perceive work now. I don’t think that I’ll be the same person again.</p>","contentLength":14447,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42838700"},{"title":"Hedy: Textual programming made easy","url":"https://www.hedy.org/","date":1737954667,"author":"0x54MUR41","guid":195,"unread":true,"content":"<h2>Textual programming made easy!</h2><p>Many schools and teachers around the world want to teach their students programming. Initially this is often done with playful tools, ranging from the Beebot robot to\nScratch Junior or Scratch. After using such tools, kids often want to move to more powerful, textual programming languages, like Python.</p><p>Python however is hard, because it is only available in English, and requires learners to learn complex programming concepts and syntax at once.\nHedy is the easy way to get started with textual programming languages! Hedy is free to use, open source, and unlike any other textual programming language in three ways.</p><ol><li>Hedy is multi-lingual, you can use Hedy in your own language</li><li>Hedy is gradual, so you can learn one concept and its syntax a time</li><li>Hedy is built for the classroom, allowing teachers to fully customize their student's experience</li></ol>","contentLength":871,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42837636"},{"title":"Marginalia – A search engine that prioritizes non-commercial content","url":"https://marginalia-search.com/","date":1737941945,"author":"herbertl","guid":194,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42836405"},{"title":"Openhaystack: Build 'AirTags' – track Bluetooth devices via Apple's network","url":"https://github.com/seemoo-lab/openhaystack","date":1737936687,"author":"thunderbong","guid":193,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42835772"},{"title":"Lessons in creating family photos that people want to keep (2018)","url":"https://estherschindler.medium.com/the-old-family-photos-project-lessons-in-creating-family-photos-that-people-want-to-keep-ea3909129943","date":1737933181,"author":"mooreds","guid":192,"unread":true,"content":"<p><em>As a consequence of scanning thousands of slides, I learned quite a bit about taking photos that capture a family’s life. Here’s a personal memoir, with a few lessons in taking memorable snapshots.</em></p><p>My father was an avid amateur photographer. He loved to take pictures, he invested in expensive cameras, and I’ve plenty of vacation memories where he had one of those cameras in hand.</p><p>But organizing the slides afterwards? Labeling them? No way. Pop threw the boxes of slides in big piles and said, “I’ll sort them after I retire.” And, in preparation for his retirement, he put all those slides into five huge boxes — the kind you’d use to ship vinyl records.</p><p>Whereupon, three days after my father formally retired in 1988, he died in his sleep.</p><p>The slides stayed with my mother. When she moved into assisted living, the boxes went into my sister’s garage. After mom died, three years ago, they came to me. The result was a huge project of scanning family slides — between 8,000 and 10,000 of them.</p><p>The primary goal was to save the photos before the media deteriorated beyond hope. It was too late in some cases. I remember Pop telling me how much cheaper Ektachrome was (compared to Kodachrome), but many of those images were as ghost-like as a half-remembered dream. Memories fade even faster. Is that a photo of my second cousin Charlotte? I’ve no idea.</p><p>For those who want practical lessons, herein you will find two categories:</p><ul><li>How to go about a family photo archive project (or at least how I did it) and</li><li>Practical suggestions for taking photos that your family will treasure long after you’re gone.</li></ul><p>This was an oddly spiritual process. We take pictures of the moments we think are valuable or important. So, in the photos he took, I saw my father’s dreams, the things he thought were beautiful, his moments of pride. And in so doing, I gained more understanding of who my parents were. …but I’ll leave that essay to another time.</p><p>I have spoken with several people who have similar family photo archives, so let me begin by describing I went about the project.</p><p>Before I began, I had an inexpensive <a href=\"http://amzn.to/2BzhIkw\" rel=\"noopener ugc nofollow\" target=\"_blank\">Wolverine slide scanner</a> but I knew a manual unit would not cut it. I bought a heavy-duty slide scanner to help me process the images. It’s a <a href=\"http://amzn.to/2u4f8Ee\" rel=\"noopener ugc nofollow\" target=\"_blank\">Canon CanoScan 9000F</a>. I like it, in case you’re shopping for an affordable unit; in particular, I do not loathe the built-in software, which sets it apart from other scanners I’ve used.</p><p>The project, which took me about a year, became a background process. I could scan a box of slides while I was reading my daily morning e-mail, then clean up and share the images during moments of down-time (such as waiting for poky websites to load site statistics). Over a weekend I usually could get through five or six boxes of slides.</p><p>Scanning a box of slides had several steps, each of which became a kind of emotional triage:</p><ul><li>I held up a slide (in front of a desk lamp) to identify it generally and decide if it was worth scanning. In other words: Do I care about this at all? Something out-of-focus easily could be thrown away. A picture of people I didn’t care about (e.g. someone my folks met on a bus tour and never spoke with again) could be dumped, too. It soon became obvious that I didn’t need to scan tourist photos; there are just-so-many pictures you need to see of the Tower of London (which looks the same today as it did in 1972 when my parents visited) or random sunsets over random mountains.</li><li>If the slide looked interesting, I did a fast preview scan. For instance, if my father took three pictures “just to be sure” I could choose the best image; I could throw out the ones where my brother had his eyes closed. And I could eliminate the pictures that were inherently uninteresting, by which I mean it brought me no sense of nostalgia.</li><li>By the time I scanned an image, I was pretty committed to keeping it and sharing it with my siblings. Sometimes, if an image was entertaining or meaningful, I’d share it among my friends on Facebook.</li></ul><p>From a box of 24–36 slides, I usually shared about 8 with my brother and sisters. By the end of the project, I’d shared 2,800 images with my siblings, and a few hundred on Facebook.</p><p>I used iPhoto to clean up the images and sort them into a dedicated folder. While tools like PhotoShop certainly could do a better job (and were trotted out for a few special images), 98% were treated with iPhoto’s crop, straighten, and the “Enhance” button. I also added dates and locations to the images’ metadata.</p><p>To share the images with my family, I uploaded photos to Flickr. Other photo sharing sites have far better user interfaces, but Flickr has two advantages: I can limit sharing to a set of people marked as friends-and-family, and viewers can comment on the images. Plus you can search images, if you’re smart enough to add tags as you go. (Do.)</p><p>Towards the end I also created private Facebook groups, which let me share with cousins as well as siblings, though its search capabilities are poor. It’s been useful for sharing those videos, though, and for encouraging conversations among my relatives.</p><p>For general sharing online, I created an Old Family Photos album on Facebook. iPhoto makes it easy to share to an album (though, alas, not to a private group). I’ve been astonished by how many of my family’s history touches a chord. Don’t be shy; but do keep your family’s privacy sensitivities in mind when you share.</p><p>The earliest roll of slides was from my parents’ engagement party circa 1941, followed by their honeymoon snapshots in 1942. Thousands of slides record their lives all the way through the 1980s, with a Family Circle gathering held only two months before my father’s death.</p><p>Inside the big boxes were two shoeboxes with a hundred 8mm video movies, which went back to the 1920s but mainly record 1950s camping trips. (<a href=\"https://www.imemories.com/\" rel=\"noopener ugc nofollow\" target=\"_blank\">iMemories</a> did a very good job at digitizing those.)</p><p>Most images are from family vacations and special occasions, rather than “daily life.” Earlier vacations (1950s and 1960s) are mostly camping trips; later pictures are from trips to Europe, particularly when money eased up after “the kids left home.”</p><p>But more is visible than the campsites and Boy Scout trips. I saw a young couple’s struggles to cope with three young children (I was an afterthought); I watched their idealism diminish and exhaustion set in.</p><p>I threw away many thousands of pictures. Some of them undoubtedly had meaning to my parents, but nobody alive cares about those photos. Yet I also came across special moments — and none of us need to have “been there” to appreciate them.</p><p>In reviewing thousands of slides, I learned quite a bit about taking photos that capture a family’s life. Perhaps these lessons can help you, too, in considering which images to snap — on vacation or in daily life.</p><p><strong>Those “title slides” are meaningful after all</strong>. I remember rolling my eyes whenever my father would station me in front of a road sign or National Park entrance. Such pictures seemed really lame.</p><p>As I reviewed the pictures, though, the title slides were priceless. In all those years, my parents went to dozens of beaches, gardens, and campsites in random mountain ranges. Other than the date on the slide (“Sep 83”) I have no way to identify which one it is. (Occasionally, there’s a scribbled note, like, “Explorer Trip” or “London.” Um, thanks, Pop.)</p><p>So I was always glad when I found a photo of us kids standing next to a “Mystic Seaport” sign or “Underground tours” (always looking put-upon and sullen, because we were told to “Stand up straight! And smile — it might turn out good!”).</p><p>Labels matter. Even a few words helped me know when-and-where something happened: “1955 Nova Scotia” or my grandfather’s name. One of the saddest experiences was looking at a family-gathering photo from the 50s with several people in it, and having no idea who’s in it. (Is that my great-aunt? Maybe my sister remembers? …and too often she didn’t.) If you inherit the photos, take the time to identify the people in them. Even if it’s obvious to you that the picture is of cousin Janet who died in 1943, you can’t assume that the next viewer will know.</p><p>: Do take pictures that give the viewer a clue of where you are, and with whom.</p><p><strong>Kodak picture spots aren’t memorable</strong>. Destination pictures surely remind the travelers of their experience. I’m sure that that picture of the beach in Portugal would have encouraged my father to say, “Thelma, remember that night?” That’s fine, for the people who participated. I’ve taken thousands of such photos myself.</p><p>But if I wasn’t there, the image brings me no nostalgia.</p><p>The worst of these pictures are the touristy photos. My father took plenty of pictures of the Eiffel Tower on their trip in the 70s. But the tower doesn’t look any different today, so I didn’t bother to scan those photos. In fact, I dumped boxes without even looking at the contents, because there’s nothing in that experience that speaks to anyone but the participants.</p><p>: It’s fine to take pictures that capture a moment for those who were present. But if  could have taken that photo, don’t expect anyone to care.</p><p><strong>People pictures matter the most</strong>. Especially the non-staged ones. The formal pictures of special occasions, where we kids are lined up like we’re in front of a firing squad, are not the ones that bind us.</p><p>The best family photos are the ones where we’re clowning around and laughing, or where we’re doing something together, or a moment captured without the subject realizing it. The most precious are those where the family is putting up a pup tent, or using the water pump, or packing the car for a trip.</p><p>In general, try to capture your family when they are actively doing something, ideally an entire process. Let it be a photo essay: “Mom making Thanksgiving dinner” or “Daddy taking the kids to the petting zoo.” Don’t choose only the “reveal” moments such as Mom presenting the turkey to the table; include a picture of her hurriedly putting on lipstick before Grandpa arrives, or the kids conked out, asleep in the back seat, on the car trip home.</p><p>A few exceptions: Nobody looks attractive or interesting while he’s swimming. Few people look great sitting on a towel on the beach, wearing a bathing cap. Also don’t take pictures of people eating dinner, even at a fancy dinner. And while it’s no longer relevant, it was never a good idea to photograph exhausted travelers arriving at an airport gate.</p><p>Include the photographer. I have few pictures of my father, because he was always the guy behind the camera. When he did ask someone to take a picture it was always posed, such as “Mom and Pop standing in front of the Grand Canyon.”</p><p>: Photos that capture you “being there” — which means most selfies — rarely have meaning.  matters far more.</p><p><strong>Take photos of daily life</strong>. I’m stunned by the pictures my father  take. There isn’t a single photo that represents what my parents did for a living. They weren’t the type to attend company picnics, fine. But I found nothing indicating “take your daughter to work” or “Mom typing up a report” or “the building I worked in” or “the woman Mom commuted to work with for 10 years.” That would be more understandable if my parents disliked their jobs, but both of them were passionate about their careers.</p><p>Take photos of people at rest. Even though I spent much of my childhood writing letters, there is only one photo of me with a pen in my hand — and that was taken by a friend at summer camp. Yet my friends and family all recall me with a book or pen within reach. My father never captured that essential part of who I was.</p><p>Some of the absences may reflect their superstitions. There are zero photos of any woman who is visibly pregnant. Maybe that was considered bad luck; I don’t know.</p><p>: Don’t limit photo-taking to special occasions.</p><p><strong>Take at least a short class in photography basics</strong>. Or read a basic book on the topic. As much as my father loved photography, he never got any kind of formal training. I spend a lot of editing time cropping images to take advantage of the simplest rule-of-thirds, for instance.</p><p>Even if you aren’t devoted to photography that much: Crop photos closely. My father took a lot of photos of “Mom in front of a pretty vista” but in the long run I care more about Mom’s expression than the expanse of mountains in the background. Thanks to iPhoto I can zoom in, but a lot of detail is lost.</p><p>: Take the best quality photos you can. Your grandchildren will appreciate it.</p>","contentLength":12639,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42835282"},{"title":"Amsterdam Compiler Kit for Cray X-MP","url":"https://github.com/kej715/ack","date":1737922658,"author":"basementcat","guid":191,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42833638"},{"title":"OpenJazz is a free, open-source version of the classic Jazz Jackrabbit games","url":"https://alister.eu/jazz/oj/about.php","date":1737913211,"author":"doener","guid":190,"unread":true,"content":"OpenJazz is a free, open-source version of the classic Jazz Jackrabbit™ games.\n     OpenJazz can be compiled on a wide range of operating systems, including Windows\n     98/Me/XP and Linux.\n     To play, you will need the files from one of the original games.\n     <p>With the demise of DOS-based operating systems, it became necessary\n     to use emulators to play old DOS games.\n     Jazz Jackrabbit™ deserves more - and would benefit greatly from new features.\n     </p><p>OpenJazz was started on the 23rd of August, 2005, by </p><a href=\"https://alister.eu/\">AJ Thomson</a>.\n     Academic pressures put the project on hold until late December 2005. The\n     source code was released on the 25th, and the first version with a degree of playability\n     was released on the 15th of January. Since then, a variety of ports have been released\n     by other people.\n     <p>In 2009, a multiplayer version was released.</p>","contentLength":870,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42831927"},{"title":"Qwen2.5-1M: Deploy your own Qwen with context length up to 1M tokens","url":"https://qwenlm.github.io/blog/qwen2.5-1m/","date":1737912255,"author":"meetpateltech","guid":189,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42831769"},{"title":"No one is disrupting banks – at least not the big ones","url":"https://www.popularfintech.com/p/no-one-is-disrupting-banks","date":1737900315,"author":"kazanins","guid":187,"unread":true,"content":"<p><strong>despite almost 30 years of trying, Fintech companies have not disrupted banks</strong></p><p><strong>they hardly challenged the key banking model - taking deposits and issuing loans</strong></p><p><strong>banks and Fintech companies will need to learn how to co-exist</strong></p><p><em><a href=\"https://x.com/jevgenijs\" rel=\"\">on X/Twitter</a></em></p><p><strong>The money center banks survived the “deposit flight”</strong></p><blockquote><p><em><strong>we expect to see a more visible growth trend</strong><strong>we can already see that trend in consumer checking deposits</strong></em></p><p><em>Jeremy Barnum, JPMorgan Q4 2024 earnings call</em></p></blockquote><p><strong>a perfect time for Fintech companies to get deposits</strong></p><p><strong>high-yield savings accounts to make people move their money from the incumbents</strong></p><p><strong>These customers want to bank with us now</strong></p><p><strong>for how long will Wells Fargo keep paying 4% to Cash App customers?</strong></p><blockquote><p><em><strong>these are the most valuable deposits in the franchise</strong></em></p><p><em>Alastair Borthwick, Bank of America Q4 2024 earnings call</em></p></blockquote><p><strong>At the end of Q3 2024, LendingClub had $9.5 billion in deposits, and SoFi had $24.4 billion</strong></p><p><strong>Fintechs haven’t managed to challenge banks in lending. </strong></p><p><strong>Affirm quickly got to 1.4 million Affirm Card cardholders</strong></p><p><strong>Robinhood claims that 2 million people are on the waitlist</strong></p><blockquote><p><em><strong>Robinhood Gold credit card crossed 2 million on the waitlist and is adding roughly 200,000 waitlist sign-ups per month</strong></em></p><p><em>Vlad Tenev, Robinhood 2024 Investor Day</em></p></blockquote><p><strong>in 2024, Amex opened 13 million new card accounts, Chase opened 10 million</strong></p><p><strong>JPMorgan finished 2024 with $233 billion in credit card loans</strong></p><blockquote><p><em><strong>We expect healthy card loan growth again this year, but below the 12% pace we saw in 2024</strong></em></p><p><em>Jeremy Barnum, JPMorgan Q4 2024 earnings call</em></p></blockquote><p><strong>last few years were ideal for building a credit card business as loan balances exploded</strong></p><blockquote><p><em><strong>a Fintech perspective on the consumer side, we really have not seen anything. Not that we don't look at it, not that we're not aware of it.</strong></em></p><p><em>Stephen Squeri, American Express Q4 2024 earnings call</em></p></blockquote><p><strong>Banks might be losing (or have already lost?) payment acceptance business to Fintech companies. </strong></p><blockquote><p><em><strong>have you considered about whether you should get rid of this business and deploy the capital to other areas where you're in a much stronger position</strong></em></p><p><em>Analyst’s question on U.S. Bank Q4 2024 earnings call</em></p></blockquote><p><strong>be losing the cross-border payments business</strong></p><p><strong>Ramp and Brex are certainly becoming a force in commercial cards</strong></p><blockquote><p><em><strong>we keep our eye on Ramp, Brex</strong><strong>they have good products, and they're making some inroads</strong></em></p><p><em>Stephen Squeri, American Express, Q4 2024 earnings call</em></p></blockquote><p><strong>…but (and that’s an important but!) big banks have figured out mobile too. </strong></p><p><strong>JPMorgan Chase reported 58 million active mobile users</strong></p><p><strong>threw billions on catching up with Fintech companies</strong><strong>still delivering crazy high profitability. </strong></p><blockquote><p><em><strong>we had probably reached peak modernization spend</strong><strong>to focus on features and new product development</strong></em></p><p><em>Jeremy Barnum, JPMorgan Q4 2024 earnings call</em></p></blockquote><p><strong>Fintech companies might be disrupting community banks, but was that the ambition? </strong></p><p><strong>a dozen or so largest banks (with $250+ in assets) generate 60% of the industry’s profit</strong></p><p><strong>banks and Fintech companies will need to learn how to co-exist</strong></p><div data-attrs=\"{&quot;url&quot;:&quot;https://www.popularfintech.com/p/no-one-is-disrupting-banks?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>Thanks for reading Popular Fintech! This post is public so feel free to share it.</p></div></div><p><em>Disclaimer: Information contained in this newsletter is intended for educational and informational purposes only and should not be considered financial advice. You should do your own research or seek professional advice before making any investment decisions.</em></p>","contentLength":3243,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42830155"},{"title":"Show HN: Bagels – TUI expense tracker","url":"https://github.com/EnhancedJax/Bagels","date":1737881871,"author":"EnhancedJax","guid":179,"unread":true,"content":"<p>Hi! I'm Jax and I've been building this cool little terminal app for myself to track my expenses and budgets!</p><p>Other than challenging myself to learn Python, I built this mainly around the habit of budget tracking at the end of the day. (I tried tracking on-the-go, but the balance was always out of sync.) All data is stored in a single sqlite file, so you can export and process them all you want!</p><p>The app is built using the textual API for Python! Awesome framework which feels like I'm doing webdev haha.</p>","contentLength":505,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42828833"},{"title":"The impact of competition and DeepSeek on Nvidia","url":"https://youtubetranscriptoptimizer.com/blog/05_the_short_case_for_nvda","date":1737819025,"author":"eigenvalue","guid":186,"unread":true,"content":"<p>As someone who spent ~10 years working as a generalist investment analyst at various long/short hedge funds (including stints at Millennium and Balyasny), while also being something of a math and computer nerd who has been studying deep learning since 2010 (back when Geoff Hinton was still talking about <a href=\"https://en.wikipedia.org/wiki/Restricted_Boltzmann_machine\">Restricted Boltzmann Machines</a> and everything was still programmed using <a href=\"https://en.wikipedia.org/wiki/MATLAB\">MATLAB</a>, and researchers were still trying to show that they could get better results at classifying handwritten digits than by using <a href=\"https://en.wikipedia.org/wiki/Support_vector_machine\">Support Vector Machines</a>), I'd like to think that I have a fairly unusual perspective on how AI technology is developing and how this relates to equity valuations in the stock market.</p><p>For the past few years, I have been working more as a developer, and have several popular open-source projects for working with various forms of AI models/services (e.g., see <a href=\"https://github.com/Dicklesworthstone/llm_aided_ocr\">LLM Aided OCR</a>, <a href=\"https://github.com/Dicklesworthstone/swiss_army_llama\">Swiss Army Llama</a>, <a href=\"https://github.com/Dicklesworthstone/fast_vector_similarity\">Fast Vector Similarity</a>, <a href=\"https://github.com/Dicklesworthstone/your-source-to-prompt.html\">Source to Prompt</a>, and <a href=\"https://github.com/pastelnetwork/python_inference_layer_server\">Pastel Inference Layer</a> for a few recent examples). Basically, I am using these frontier models all day, every day, in about as intense a way as possible. I have 3 Claude accounts so I don't run out of requests, and signed up for ChatGPT Pro within minutes of it being available.</p><p>I also try to keep on top of the latest research advances, and carefully read all the major technical report papers that come out from the major AI labs. So I think I have a pretty good read on the space and how things are developing. At the same time, I've shorted a ton of stocks in my life and have won the best idea prize on the Value Investors Club twice (for <a href=\"https://valueinvestorsclub.com/idea/TMS_INTERNATIONAL_CORP/5881178219\">TMS long</a> and <a href=\"https://valueinvestorsclub.com/idea/PETROLOGISTICS_LP/5967783148\">PDH short</a> if you're keeping track at home).</p><p>I say this not to brag, but rather to help establish my bona fides as someone who could opine on the subject without coming across as hopelessly naive to either technologists or professional investors. And while there are surely many people who know the math/science better, and people who are better at long/short investing in the stock market than me, I doubt there are very many who are in the middle of the Venn diagram to the extent I can claim to be.</p><p>With all that said, whenever I meet with and chat with my friends and ex colleagues from the hedge fund world, the conversation quickly turns to Nvidia. It's not every day that a company goes from relative obscurity to being worth more than the combined stock markets of England, France, or Germany! And naturally, these friends want to know my thoughts on the subject. Because I am such a dyed-in-the-wool believer in the long term transformative impact of this technology— I truly believe it's going to radically change nearly every aspect of our economy and society in the next 5-10 years, with basically no historical precedent— it has been hard for me to make the argument that Nvidia's momentum is going to slow down or stop anytime soon.</p><p>But even though I've thought the valuation was just too rich for my blood for the past year or so, a confluence of recent developments has caused me to flip a bit to my usual instinct, which is to be a bit more contrarian in outlook and to question the consensus when it seems to be more than priced in. The saying \"what the wise man believes in the beginning, the fool believes in the end\" became famous for a good reason.</p><p>Before we get into the developments that give me pause, let's pause to briefly review the bull case for NVDA shares, which is basically now known by everyone and his brother. Deep learning and AI are the most transformative technologies since the internet, and poised to change basically everything in our society. Nvidia has somehow ended up with something close to a monopoly in terms of the share of aggregate industry capex that is spent on training and inference infrastructure.</p><p>Some of the largest and most profitable companies in the world, like Microsoft, Apple, Amazon, Meta, Google, Oracle, etc., have all decided that they must do and spend whatever it takes to stay competitive in this space because they simply cannot afford to be left behind. The amount of capex dollars, gigawatts of electricity used, square footage of new-build data centers, and, of course, the number of GPUs, has absolutely exploded and seems to show no sign of slowing down. And Nvidia is able to earn insanely high 90%+ gross margins on the most high-end, datacenter oriented products.</p><p>We've just scratched the surface here of the bull case. There are many additional aspects to it now, which have made even people who were already very bullish to become incrementally more bullish. Besides things like the rise of humanoid robots, which I suspect is going to take most people by surprise when they are rapidly able to perform a huge number of tasks that currently require an unskilled (or even skilled) human worker (e.g., doing laundry, cleaning, organizing, and cooking; doing construction work like renovating a bathroom or building a house in a team of workers; running a warehouse and driving forklifts, etc.), there are other factors which most people haven't even considered.</p><p>One major thing that you hear the smart crowd talking about is the rise of \"a new scaling law,\" which has created a new paradigm thinking about how compute needs will increase over time. The original scaling law, which is what has been driving progress in AI since <a href=\"https://en.wikipedia.org/wiki/AlexNet\">AlexNet</a> appeared in 2012 and the Transformer architecture was invented in 2017, is the pre-training scaling law: that the more billions (and now trillions) worth of tokens we can use as training data, and the larger the parameter count of the models we are training, and the more FLOPS of compute that we expend on training those models on those tokens, the better the performance of the resulting models on a large variety of highly useful downstream tasks.</p><p>Not only that, but this improvement is somewhat knowable, to the point where the leading AI labs like OpenAI and Anthropic have a pretty good idea of just how good their latest models would be even before they started the actual training runs— in some cases, predicting the benchmarks of the final models to within a couple percentage points. This \"original scaling law\" has been vitally important, but always caused some doubts in the minds of people projecting the future with it.</p><p>For one thing, we seem to have already exhausted the world's accumulated set of high quality training data. Of course, that's not literally true— there are still so many old books and periodicals that haven't yet been properly digitized, and even if they have, are not properly licensed for use as training data. The problem is that, even if you give credit for all that stuff— say the sum total of \"professionally\" produced English language written content from the year 1500 to, say, the year 2000, it's not such a tremendous amount in percentage terms when you're talking about a training corpus of nearly 15 trillion tokens, which is the scale of current frontier models.</p><p>For a quick reality check of those numbers: Google Books has digitized around 40mm books so far; if a typical book has 50k to 100k words, or 65k to 130k tokens, then that's between 2.6T and 5.2T tokens just from books, though surely a large chunk of that is already included in the training corpora used by the big labs, whether it's strictly legal or not. And there are lots of academic papers, with the arXiv website alone having over 2mm papers. And the Library of Congress has over 3 billion digitized newspaper pages. Taken together, that could be as much as 7T tokens in total, but since much of this is in fact included in training corpora, the remaining \"incremental\" training data probably isn't all that significant in the grand scheme of things.</p><p>Of course, there are other ways to gather more training data. You could automatically transcribe every single YouTube video for example, and use that text. And while that might be helpful on the margin, it's certainly of much lower quality than, say, a highly respected textbook on Organic Chemistry as a source of useful knowledge about the world. So we've always had a looming \"data wall\" when it comes to the original scaling law; although we know we can keep shoveling more and more capex into GPUs and building more and more data centers, it's a lot harder to mass produce useful new human knowledge which is correct and incremental to what is already out there. Now, one intriguing response to this has been the rise of \"synthetic data,\" which is text that is itself the output of an LLM. And while this seems almost nonsensical that it would work to \"get high on your own supply\" as a way of improving model quality, it actually seems to work very well in practice, at least in the domain of math, logic, and computer programming.</p><p>The reason, of course, is that these are areas where we can mechanically check and prove the correctness of things. So we can sample from the vast universe of possible math theorems or possible Python scripts, and then actually check if they are correct, and only include them in our corpus if they are. And in this way, we can very dramatically expand our collection of high quality training data, at least in these kinds of areas.</p><p>And then there are all the other kinds of data we could be training AI on besides text. For example, what if we take the entire whole genome sequencing (around 200 GB to 300 GB uncompressed for a single human being) for 100 million people? That's a  of data obviously, although the vast majority of it would be nearly identical between any two people. Of course, this could be misleading to compare to textual data from books and the internet for various reasons:</p><ul><li>Raw genome size isn't directly comparable to token counts</li><li>The information content of genomic data is very different from text</li><li>The training value of highly redundant data isn't clear</li><li>The computational requirements for processing genomic data are different</li></ul><p>But it's still another large source of diverse information that we could train huge models on in the future, which is why I included it.</p><p>So while there is some hope in terms of being able to capture more and more additional training data, if you look at the rate at which training corpora have grown in recent years, it quickly becomes obvious that we are close to hitting a wall in terms of data availability for \"generally useful\" knowledge that can get us closer to the ultimate goal of getting artificial super-intelligence which is 10x smarter than John von Neumann and is an absolute world-class expert on every specialty known to man.</p><p>Besides the limited amount of available data, there have always been a couple other things that have lurked in the back of the mind of proponents of the pre-training scaling law. A big one of these is, after you've finished training the model, what are you supposed to do with all that compute infrastructure? Train the next model? Sure, you can do that, but given the rapid improvement in GPU speed and capacity, and the importance of electricity and other opex in the economic calculations, does it even really make sense to use your 2 year old cluster to train your new model? Surely you'd rather use the brand new data center you just built that costs 10x the old data center and is 20x more powerful because of better technology. The problem is, at some point you do need to amortize the up-front cost of these investments and recoup it with a stream of (hopefully positive) operating profit, right?</p><p>The market is so excited about AI that it has thankfully ignored this, allowing companies like OpenAI to post breathtaking from-inception, cumulative operating losses while garnering increasingly eye-popping valuations in follow-up investment rounds (although, to their credit, they have also been able to demonstrate very fast growing revenues). But eventually, for this situation to be sustainable over a full market cycle, these data center costs do need to eventually be recouped, hopefully with a profit, which over time is competitive with other investment opportunities on a risk-adjusted basis.</p><p>OK, so that was the pre-training scaling law. What's this \"new\" scaling law? Well, that's something that people really just started focusing on in the past year: inference time compute scaling. Before, the vast majority of all the compute you'd expend in the process was the up-front training compute to create the model in the first place. Once you had the trained model, performing inference on that model— i.e., asking a question or having the LLM perform some kind of task for you— used a certain, limited amount of compute.</p><p>Critically, the total amount of inference compute (measured in various ways, such as FLOPS, in GPU memory footprint, etc.) was much, much less than what was required for the pre-training phase. Of course, the amount of inference compute does flex up when you increase the context window size of the models and the amount of output that you generate from them in one go (although researchers have made breathtaking algorithmic improvements on this front relative to the initial quadratic scaling people originally expected in scaling this up). But essentially, until recently, inference compute was generally a lot less intensive than training compute, and scaled basically linearly with the number of requests you are handling— the more demand for text completions from ChatGPT, for instance, the more inference compute you used up.</p><p>With the advent of the revolutionary Chain-of-Thought (\"COT\") models introduced in the past year, most noticeably in OpenAI's flagship O1 model (but very recently in DeepSeek's new R1 model, which we will talk about later in much more detail), all that changed. Instead of the amount of inference compute being directly proportional to the length of the output text generated by the model (scaling up for larger context windows, model size, etc.), these new COT models also generate intermediate \"logic tokens\"; think of this as a sort of scratchpad or \"internal monologue\" of the model while it's trying to solve your problem or complete its assigned task.</p><p>This represents a true sea change in how inference compute works: now, the more tokens you use for this internal chain of thought process, the better the quality of the final output you can provide the user. In effect, it's like giving a human worker more time and resources to accomplish a task, so they can double and triple check their work, do the same basic task in multiple different ways and verify that they come out the same way; take the result they came up with and \"plug it in\" to the formula to check that it actually does solve the equation, etc.</p><p>It turns out that this approach works almost amazingly well; it is essentially leveraging the long anticipated power of what is called \"reinforcement learning\" with the power of the Transformer architecture. It directly addresses the single biggest weakness of the otherwise phenomenally successful Transformer model, which is its propensity to \"hallucinate\".</p><p>Basically, the way Transformers work in terms of predicting the next token at each step is that, if they start out on a bad \"path\" in their initial response, they become almost like a prevaricating child who tries to spin a yarn about why they are actually correct, even if they should have realized mid-stream using common sense that what they are saying couldn't possibly be correct.</p><p>Because the models are always seeking to be internally consistent and to have each successive generated token flow naturally from the preceding tokens and context, it's very hard for them to course-correct and backtrack. By breaking the inference process into what is effectively many intermediate stages, they can try lots of different things and see what's working and keep trying to course-correct and try other approaches until they can reach a fairly high threshold of confidence that they aren't talking nonsense.</p><p>Perhaps the most extraordinary thing about this approach, beyond the fact that it works at all, is that the more logic/COT tokens you use, the better it works. Suddenly, you now have an additional dial you can turn so that, as you increase the amount of COT reasoning tokens (which uses a lot more inference compute, both in terms of FLOPS and memory), the higher the probability is that you will give a correct response— code that runs the first time without errors, or a solution to a logic problem without an obviously wrong deductive step.</p><p>I can tell you from a lot of firsthand experience that, as good as Anthropic's Claude3.5 Sonnet model is at Python programming— and it is indeed VERY good— whenever you need to generate anything long and complicated, it invariably ends up making one or more stupid mistakes. Now, these mistakes are usually pretty easy to fix, and in fact you can normally fix them by simply feeding the errors generated by the Python interpreter, without any further explanation, as a follow-up inference prompt (or, more usefully, paste in the complete set of detected \"problems\" found in the code by your code editor, using what something called a Linter), it was still an annoying additional step. And when the code becomes very long or very complicated, it can sometimes take a lot longer to fix, and might even require some manual debugging by hand.</p><p>The first time I tried the O1 model from OpenAI was like a revelation: I was amazed how often the code would be perfect the very first time. And that's because the COT process automatically finds and fixes problems before they ever make it to a final response token in the answer the model gives you.</p><p>In fact, the O1 model used in OpenAI's ChatGPT Plus subscription for $20/month is basically the same model as the one used in the O1-Pro model featured in their new ChatGPT Pro subscription for 10x the price ($200/month, which raised plenty of eyebrows in the developer community); the main difference is that O1-Pro thinks for a lot longer before responding, generating vastly more COT logic tokens, and consuming a far larger amount of inference compute for every response.</p><p>This is quite striking in that, even a very long and complex prompt for Claude3.5 Sonnet or GPT4o, with ~400kb+ of context given, generally takes less than 10 seconds to begin responding, and often less than 5 seconds. Whereas that same prompt to O1-Pro could easily take 5+ MINUTES before you get a response (although OpenAI does show you some of the \"reasoning steps\" that are generated during the process while you wait; critically, OpenAI has decided, presumably for trade secret related reasons,to hide from you the exact reasoning tokens it generates, showing you instead a highly abbreviated summary of these).</p><p>As you can probably imagine, there are tons of contexts where accuracy is paramount— where you'd rather give up and tell the user you can't do it at all rather than give an answer that could be trivially proven wrong or which involves hallucinated facts or otherwise specious reasoning. Anything involving money/transactions, medical stuff, legal stuff, just to name a few.</p><p>Basically, wherever the cost of inference is trivial relative to the hourly all-in compensation of the human knowledge worker who is interacting with the AI system, that's a case where it become a complete no-brainer to dial up the COT compute (the major drawback is that it increases the latency of responses by a lot, so there are still some contexts where you might prefer to iterate faster by getting lower latency responses that are less accurate or correct).</p><p>Some of the most exciting news in the AI world came out just a few weeks ago and concerned OpenAI's new unreleased O3 model, which was able to solve a large variety of tasks that were previously deemed to be out of reach of current AI approaches in the near term. And the way it was able to do these hardest problems (which include exceptionally tough \"foundational\" math problems that would be very hard for even highly skilled professional mathematicians to solve), is that OpenAI threw insane amount of compute resources at the problems— in some cases, spending $3k+ worth of compute power to solve a single task (compare this to traditional inference costs for a single task, which would be unlikely to exceed a couple dollars using regular Transformer models without chain-of-thought).</p><p>It doesn't take an AI genius to realize that this development creates a new scaling law that is totally independent of the original pre-training scaling law. Now, you still want to train the best model you can by cleverly leveraging as much compute as you can and as many trillion tokens of high quality training data as possible, but that's just the beginning of the story in this new world; now, you could easily use incredibly huge amounts of compute just to do inference from these models at a very high level of confidence or when trying to solve extremely tough problems that require \"genius level\" reasoning to avoid all the potential pitfalls that would lead a regular LLM astray.</p><h2>But Why Should Nvidia Get to Capture All The Upside?</h2><p>Even if you believe, as I do, that the future prospects for AI are almost unimaginably bright, the question still remains, \"Why should one company extract the majority of the profit pool from this technology?\" There are certainly many historical cases where a very important new technology changed the world, but the main winners were not the companies that seemed the most promising during the initial stages of the process. The Wright Brothers' airplane company in all its current incarnations across many different firms today isn't worth more than $10b despite them inventing and perfecting the technology well ahead of everyone else. And while Ford has a respectable market cap of $40b today, it's just 1.1% of Nvidia's current market cap.</p><p>To understand this, it's important to really understand why Nvidia is currently capturing so much of the pie today. After all, they aren't the only company that even makes GPUs. AMD makes respectable GPUs that, on paper, have comparable numbers of transistors, which are made using similar process nodes, etc. Sure, they aren't as fast or as advanced as Nvidia's GPUs, but it's not like the Nvidia GPUs are 10x faster or anything like that. In fact, in terms of naive/raw dollars per FLOP, AMD GPUs are something like half the price of Nvidia GPUs.</p><p>Looking at other semiconductor markets such as the DRAM market, despite the fact that it is also very highly consolidated with only 3 meaningful global players (Samsung, Micron, SK-Hynix), gross margins in the DRAM market range from negative at the bottom of the cycle to ~60% at the very top of the cycle, with an average in the 20% range. Compare that to Nvidia's overall gross margin in recent quarters of ~75%, which is dragged down by the lower-margin and more commoditized consumer 3D graphics category.</p><p>So how is this possible? Well, the main reasons have to do with software— better drivers that \"just work\" on Linux and which are highly battle-tested and reliable (unlike AMD, which is notorious for the low quality and instability of their Linux drivers), and highly optimized open-source code in popular libraries such as <a href=\"https://en.wikipedia.org/wiki/PyTorch\">PyTorch</a> that has been tuned to work really well on Nvidia GPUs.</p><p>It goes beyond that though— the very programming framework that coders use to write low-level code that is optimized for GPUs, CUDA, is totally proprietary to Nvidia, and it has become a de facto standard. If you want to hire a bunch of extremely talented programmers who know how to make things go really fast on GPUs, and pay them $650k/year or whatever the going rate is for people with that particular expertise, chances are that they are going to \"think\" and work in CUDA.</p><p>Besides software superiority, the other major thing that Nvidia has going for it is what is known as interconnect— essentially, the bandwidth that connects together thousands of GPUs together efficiently so they can be jointly harnessed to train today's leading-edge foundational models. In short, the key to efficient training is to keep all the GPUs as fully utilized as possible all the time— not waiting around idling until they receive the next chunk of data they need to compute the next step of the training process.</p><p>The bandwidth requirements are extremely high— much, much higher than the typical bandwidth that is needed in traditional data center use cases. You can't really use traditional networking gear or fiber optics for this kind of interconnect, since it would introduce too much latency and wouldn't give you the pure terabytes per second of bandwidth that is needed to keep all the GPUs constantly busy.</p><p>Nvidia made an incredibly smart decision to purchase the Israeli company Mellanox back in 2019 for a mere $6.9b, and this acquisition is what provided them with their industry leading interconnect technology. Note that interconnect speed is a lot more relevant to the training process, where you have to harness together the output of thousands of GPUs at the same time, than the inference process (including COT inference), which can use just a handful of GPUs— all you need is enough VRAM to store the quantized (compressed) model weights of the already-trained model.</p><p>So those are arguably the major components of Nvidia's \"moat\" and how it has been able to maintain such high margins for so long (there is also a \"flywheel\" aspect to things, where they aggressively invest their super-normal profits into tons of R&amp;D, which in turn helps them improve their tech at a faster rate than the competition, so they are always in the lead in terms of raw performance).</p><p>But as was pointed out earlier, what customers really tend to care about, all other things being equal, is performance per dollar (both in up-front capex cost of equipment and in energy usage, so performance per watt), and even though Nvidia's GPUs are certainly the fastest, they are not the best price/performance when measured naively in terms of FLOPS.</p><p>But the thing is, all other things are NOT equal, and the fact that AMD's drivers suck, that popular AI software libraries don't run as well on AMD GPUs, that you can't find really good GPU experts who specialize in AMD GPUs outside of the gaming world (why would they bother when there is more demand in the market for CUDA experts?), that you can't wire thousands of them together as effectively because of lousy interconnect technology for AMD— all this means that AMD is basically not competitive in the high-end data center world, and doesn't seem to have very good prospects for getting there in the near term.</p><p>Well, that all sounds very bullish for Nvidia, right? Now you can see why the stock is trading at such a huge valuation! But what are the other clouds on the horizon? Well, there are few that I think merit significant attention. Some have been lurking in the background for the last few years, but too small to make a dent considering how quickly the pie has been growing, but where they are getting ready to potentially inflect upwards. Others are very recent developments (as in, the last 2 weeks) that might dramatically change the near-term trajectory of incremental GPU demand.</p><p>At a very high level, you can think of things like this: Nvidia operated in a pretty niche area for a very long time; they had very limited competition, and the competition wasn't particular profitable or growing fast enough to ever pose a real threat, since they didn't have the capital needed to really apply pressure to a market leader like Nvidia. The gaming market was large and growing, but didn't feature earth shattering margins or particularly fabulous year over year growth rates.</p><p>A few big tech companies started ramping up hiring and spending on machine learning and AI efforts around 2016-2017, but it was never a truly significant line item for any of them on an aggregate basis— more of a \"moonshot\" R&amp;D expenditure. But once the big AI race started in earnest with the release of ChatGPT in 2022— only a bit over 2 years ago, although it seems like a lifetime ago in terms of developments— that situation changed very dramatically.</p><p>Suddenly, big companies were ready to spend many, many billions of dollars incredibly quickly. The number of researchers showing up at the big research conferences like <a href=\"https://papers.nips.cc/\">Neurips</a> and <a href=\"https://icml.cc/\">ICML</a> went up very, very dramatically. All the smart students who might have previously studied financial derivatives were instead studying Transformers, and $1mm+ compensation packages for non-executive engineering roles (i.e., for independent contributors not managing a team) became the norm at the leading AI labs.</p><p>It takes a while to change the direction of a massive cruise ship; and even if you move really quickly and spend billions, it takes a year or more to build greenfield data centers and order all the equipment (with ballooning lead times) and get it all set up and working. It takes a long time to hire and onboard even smart coders before they can really hit their stride and familiarize themselves with the existing codebases and infrastructure.</p><p>But now, you can imagine that absolutely biblical amounts of capital, brainpower, and effort are being expended in this area. And Nvidia has the biggest target of any player on their back, because they are the ones who are making the lion's share of the profits TODAY, not in some hypothetical future where the AI runs our whole lives.</p><p>So the very high level takeaway is basically that \"markets find a way\"; they find alternative, radically innovative new approaches to building hardware that leverage completely new ideas to sidestep barriers that help prop up Nvidia's moat.</p><h2>The Hardware Level Threat</h2><p>For example, so-called \"wafer scale\" AI training chips from Cerebras, which dedicate an entire 300mm silicon wafer to an absolutely gargantuan chip that contains orders of magnitude more transistors and cores on a single chip (see this recent <a href=\"https://cerebras.ai/blog/100x-defect-tolerance-how-cerebras-solved-the-yield-problem\">blog post</a> from them explaining how they were able to solve the \"yield problem\" that had been preventing this approach from being economically practical in the past).</p><p>To put this into perspective, if you compare Cerebras' newest WSE-3 chip to Nvidia's flagship data-center GPU, the H100, the Cerebras chip has a total die area of 46,225 square millimeters compared to just 814 for the H100 (and the H100 is itself considered an enormous chip by industry standards); that's a multiple of ~57x! And instead of having 132 \"streaming multiprocessor\" cores enabled on the chip like the H100 has, the Cerebras chip has ~900,000 cores (granted, each of these cores is smaller and does a lot less, but it's still an almost unfathomably large number in comparison). In more concrete apples-to-apples terms, the Cerebras chip can do around ~32x the FLOPS in AI contexts as a single H100 chip. Since an H100 sells for close to $40k a pop, you can imagine that the WSE-3 chip isn't cheap.</p><p>So why does this all matter? Well, instead of trying to battle Nvidia head-on by using a similar approach and trying to match the Mellanox interconnect technology, Cerebras has used a radically innovative approach to do an end-run around the interconnect problem: inter-processor bandwidth becomes much less of an issue when everything is running on the same super-sized chip. You don't even need to have the same level of interconnect because one mega chip replaces tons of H100s.</p><p>And the Cerebras chips also work extremely well for AI inference tasks. In fact, you can try it today for free <a href=\"https://cloud.cerebras.ai/\">here</a> and use Meta's very respectable Llama-3.3-70B model. It responds basically instantaneously, at ~1,500 tokens per second. To put that into perspective, anything above 30 tokens per second feels relatively snappy to users based on comparisons to ChatGPT and Claude, and even 10 tokens per second is fast enough that you can basically read the response while it's being generated.</p><p>Cerebras is also not alone; there are other companies, like Groq (not to be confused with the <a href=\"https://x.ai/\">Grok</a> model family trained by Elon Musk's X AI). Groq has taken yet another innovative approach to solving the same fundamental problem. Instead of trying to compete with Nvidia's CUDA software stack directly, they've developed what they call a \"tensor processing unit\" (TPU) that is specifically designed for the exact mathematical operations that deep learning models need to perform. Their chips are designed around a concept called \"deterministic compute,\" which means that, unlike traditional GPUs where the exact timing of operations can vary, their chips execute operations in a completely predictable way every single time.</p><p>This might sound like a minor technical detail, but it actually makes a massive difference for both chip design and software development. Because the timing is completely deterministic, Groq can optimize their chips in ways that would be impossible with traditional GPU architectures. As a result, they've been demonstrating for the past 6+ months inference speeds of over 500 tokens per second with the Llama series of models and other open source models, far exceeding what's possible with traditional GPU setups. Like Cerebras, this is available today and you can try it for free <a href=\"https://console.groq.com/playground\">here</a>.</p><p>Using a comparable Llama3 model with \"speculative decoding,\" Groq is able to generate 1,320 tokens per second, on par with Cerebras and far in excess of what is possible using regular GPUs. Now, you might ask what the point is of achieving 1,000+ tokens per second when users seem pretty satisfied with ChatGPT, which is operating at less than 10% of that speed. And the thing is, it does matter. It makes it a lot faster to iterate and not lose focus as a human knowledge worker when you get instant feedback. And if you're using the model programmatically via the API, which is increasingly where much of the demand is coming from, then it can enable whole new classes of applications that require multi-stage inference (where the output of previous stages is used as input in successive stages of prompting/inference) or which require low-latency responses, such as content moderation, fraud detection, dynamic pricing, etc.</p><p>But even more fundamentally, the faster you can serve requests, the faster you can cycle things, and the busier you can keep the hardware. Although Groq's hardware is extremely expensive, clocking in at $2mm to $3mm for a single server, it ends up costing far less per request fulfilled if you have enough demand to keep the hardware busy all the time.</p><p>And like Nvidia with CUDA, a huge part of Groq's advantage comes from their own proprietary software stack. They are able to take the same open source models that other companies like Meta, DeepSeek, and Mistral develop and release for free, and decompose them in special ways that allow them to run dramatically faster on their specific hardware.</p><p>Like Cerebras, they have taken different technical decisions to optimize certain particular aspects of the process, which allows them to do things in a fundamentally different way. In Groq's case, it's because they are entirely focused on inference level compute, not on training: all their special sauce hardware and software only give these huge speed and efficiency advantages when doing inference on an already trained model.</p><p>But if the next big scaling law that people are excited about is for inference level compute— and if the biggest drawback of COT models is the high latency introduced by having to generate all those intermediate logic tokens before they can respond— then even a company that only does inference compute, but which does it dramatically faster and more efficiently than Nvidia can— can introduce a serious competitive threat in the coming years. At the very least, Cerebras and Groq can chip away at the lofty expectations for Nvidia's revenue growth over the next 2-3 years that are embedded in the current equity valuation.</p><p>Besides these particularly innovative, if relatively unknown, startup competitors, there is some serious competition coming from some of Nvidia's biggest customers themselves who have been making custom silicon that specifically targets AI training and inference workloads. Perhaps the best known of these is Google, which has been developing its own proprietary TPUs since 2016. Interestingly, although it briefly sold TPUs to external customers, Google has been using all its TPUs internally for the past several years, and it is already on its <a href=\"https://cloud.google.com/blog/products/compute/introducing-trillium-6th-gen-tpus\">6th generation</a> of TPU hardware.</p><p>Amazon has also been developing its own custom chips called <a href=\"https://press.aboutamazon.com/2023/11/aws-unveils-next-generation-aws-designed-chips\">Trainium2</a> and <a href=\"https://aws.amazon.com/ai/machine-learning/inferentia/\">Inferentia2</a>. And while Amazon is building out data centers featuring billions of dollars of Nvidia GPUs, they are also at the same time investing many billions in other data centers that use these internal chips. They have one cluster that they are bringing online for Anthropic that features over 400k chips.</p><p>Amazon gets a lot of flak for totally bungling their internal AI model development, squandering massive amounts of internal compute resources on models that ultimately are not competitive, but the custom silicon is another matter. Again, they don't necessarily need their chips to be better and faster than Nvidia's. What they need is for their chips to be good enough, but build them at a breakeven gross margin instead of the ~90%+ gross margin that Nvidia earns on its H100 business.</p><p>OpenAI has also announced their <a href=\"https://www.theregister.com/2024/09/04/openai_ai_chips_tsmc/\">plans</a> to build custom chips, and they (together with Microsoft) are obviously the single largest user of Nvidia's data center hardware. As if that weren't enough, Microsoft have themselves announced their <a href=\"https://azure.microsoft.com/en-us/blog/azure-maia-for-the-era-of-ai-from-silicon-to-software-to-systems/\">own</a> custom chips!</p><p>And Apple, the most valuable technology company in the world, has been blowing away expectations for years now with their highly innovative and disruptive custom silicon operation, which now completely trounces the CPUs from both Intel and AMD in terms of performance per watt, which is the most important factor in mobile (phone/tablet/laptop) applications. And they have been making their own internally designed GPUs and \"Neural Processors\" for years, even though they have yet to really demonstrate the utility of such chips outside of their own custom applications, like the advanced software based image processing used in the iPhone's camera.</p><p>While Apple's focus seems somewhat orthogonal to these other players in terms of its mobile-first, consumer oriented, \"edge compute\" focus, if it ends up spending enough money on its new contract with OpenAI to provide AI services to iPhone users, you have to imagine that they have teams looking into making their own custom silicon for inference/training (although given their secrecy, you might never even know about it directly!).</p><p>Now, it's no secret that there is a strong power law distribution of Nvidia's hyper-scaler customer base, with the top handful of customers representing the lion's share of high-margin revenue. How should one think about the future of this business when literally every single one of these VIP customers is building their own custom chips specifically for AI training and inference?</p><p>When thinking about all this, you should keep one incredibly important thing in mind: Nvidia is largely an IP based company. They don't make their own chips. The true special sauce for making these incredible devices arguably comes more from TSMC, the actual fab, and ASML, which makes the special EUV lithography machines used by TSMC to make these leading-edge process node chips. And that's critically important, because TSMC will sell their most advanced chips to anyone who comes to them with enough up-front investment and is willing to guarantee a certain amount of volume. They don't care if it's for Bitcoin mining ASICs, GPUs, TPUs, mobile phone SoCs, etc.</p><p>As much as senior chip designers at Nvidia earn per year, surely some of the best of them could be lured away by these other tech behemoths for enough cash and stock. And once they have a team and resources, they can design innovative chips (again, perhaps not even 50% as advanced as an H100, but with that Nvidia gross margin, there is plenty of room to work with) in 2 to 3 years, and thanks for TSMC, they can turn those into actual silicon using the exact same process node technology as Nvidia.</p><p>As if these looming hardware threats weren't bad enough, there are a few developments in the software world in the last couple years that, while they started out slowly, are now picking up real steam and could pose a serious threat to the software dominance of Nvidia's CUDA. The first of these is the horrible Linux drivers for AMD GPUs. Remember we talked about how AMD has inexplicably allowed these drivers to suck for years despite leaving massive amounts of money on the table?</p><p>Well, amusingly enough, the infamous hacker George Hotz (famous for jailbreaking the original iphone as a teenager, and currently the CEO of self-driving startup Comma.ai and AI computer company Tiny Corp, which also makes the open-source tinygrad AI software framework), recently announced that he was sick and tired of dealing with AMD's bad drivers, and desperately wanted to be able to to leverage the lower cost AMD GPUs in their TinyBox AI computers (which come in multiple flavors, some of which use Nvidia GPUs, and some of which use AMD GPUS).</p><p>Well, he is making his own custom drivers and software stack for AMD GPUs without any help from AMD themselves; on Jan. 15th of 2025, he <a href=\"https://x.com/__tinygrad__/status/1879615316378198516\">tweeted</a> via his company's X account that <em>\"We are one piece away from a completely sovereign stack on AMD, the RDNA3 assembler. We have our own driver, runtime, libraries, and emulator. (all in ~12,000 lines!)\"</em> Given his track record and skills, it is likely that they will have this all working in the next couple months, and this would allow for a lot of exciting possibilities of using AMD GPUs for all sorts of applications where companies currently feel compelled to pay up for Nvidia GPUs.</p><p>OK, well that's just a driver for AMD, and it's not even done yet. What else is there? Well, there are a few other areas on the software side that are a lot more impactful. For one, there is now a massive concerted effort across many large tech companies and the open source software community at large to make more generic AI software frameworks that have CUDA as just one of many \"compilation targets\".</p><p>That is, you write your software using higher-level abstractions, and the system itself can automatically turn those high-level constructs into super well-tuned low-level code that works extremely well on CUDA. But because it's done at this higher level of abstraction, it can just as easily get compiled into low-level code that works extremely well on lots of other GPUs and TPUs from a variety of providers, such as the massive number of custom chips in the pipeline from every big tech company.</p><p>The most famous examples of these frameworks are MLX (sponsored primarily by Apple), Triton (sponsored primarily by OpenAI), and JAX (developed by Google). MLX is particularly interesting because it provides a PyTorch-like API that can run efficiently on Apple Silicon, showing how these abstraction layers can enable AI workloads to run on completely different architectures. Triton, meanwhile, has become increasingly popular as it allows developers to write high-performance code that can be compiled to run on various hardware targets without having to understand the low-level details of each platform.</p><p>These frameworks allow developers to write their code once using high powered abstractions and then target tons of platforms automatically— doesn't that sound like a better way to do things, which would give you a lot more flexibility in terms of how you actually run the code?</p><p>In the 1980s, all the most popular, best selling software was written in hand-tuned assembly language. The PKZIP compression utility for example was hand crafted to maximize speed, to the point where a competently coded version written in the standard C programming language and compiled using the best available optimizing compilers at the time, would run at probably half the speed of the hand-tuned assembly code. The same is true for other popular software packages like WordStar, VisiCalc, and so on.</p><p>Over time, compilers kept getting better and better, and every time the CPU architectures changed (say, from Intel releasing the 486, then the Pentium, and so on), that hand-rolled assembler would often have to be thrown out and rewritten, something that only the smartest coders were capable of (sort of like how CUDA experts are on a different level in the job market versus a \"regular\" software developer). Eventually, things converged so that the speed benefits of hand-rolled assembly were outweighed dramatically by the flexibility of being able to write code in a high-level language like C or C++, where you rely on the compiler to make things run really optimally on the given CPU.</p><p>Nowadays, very little new code is written in assembly. I believe a similar transformation will end up happening for AI training and inference code, for similar reasons: computers are good at optimization, and flexibility and speed of development is increasingly the more important factor— especially if it also allows you to save dramatically on your hardware bill because you don't need to keep paying the \"CUDA tax\" that gives Nvidia 90%+ margins.</p><p>Yet another area where you might see things change dramatically is that CUDA might very well end up being more of a high level abstraction itself— a \"specification language\" similar to <a href=\"https://en.wikipedia.org/wiki/Verilog\">Verilog</a> (used as the industry standard to describe chip layouts) that skilled developers can use to describe high-level algorithms that involve massive parallelism (since they are already familiar with it, it's very well constructed, it's the lingua franca, etc.), but then instead of having that code compiled for use on Nvidia GPUs like you would normally do, it can instead be fed as source code into an LLM which can port it into whatever low-level code is understood by the new Cerebras chip, or the new Amazon Trainium2, or the new Google TPUv6, etc. This isn't as far off as you might think; it's probably already well within reach using OpenAI's latest O3 model, and surely will be possible generally within a year or two.</p><p>Perhaps the most shocking development which was alluded to earlier happened in the last couple of weeks. And that is the news that has totally rocked the AI world, and which has been dominating the discourse among knowledgeable people on Twitter despite its complete absence from any of the mainstream media outlets: that a small Chinese startup called DeepSeek released two new models that have basically world-competitive performance levels on par with the best models from OpenAI and Anthropic (blowing past the Meta Llama3 models and other smaller open source model players such as Mistral). These models are called <a href=\"https://api-docs.deepseek.com/news/news1226\">DeepSeek-V3</a> (basically their answer to GPT-4o and Claude3.5 Sonnet) and <a href=\"https://api-docs.deepseek.com/news/news250120\">DeepSeek-R1</a> (basically their answer to OpenAI's O1 model).</p><p>Why is this all so shocking? Well, first of all, DeepSeek is a tiny Chinese company that reportedly has under 200 employees. The story goes that they started out as a quant trading hedge fund similar to TwoSigma or RenTec, but after Xi Jinping cracked down on that space, they used their math and engineering chops to pivot into AI research. Who knows if any of that is really true or if they are merely some kind of front for the CCP or the Chinese military. But the fact remains that they have released two incredibly detailed technical reports, for <a href=\"https://github.com/deepseek-ai/DeepSeek-V3/blob/main/DeepSeek_V3.pdf\">DeepSeek-V3</a> and <a href=\"https://github.com/deepseek-ai/DeepSeek-R1/blob/main/DeepSeek_R1.pdf\">DeepSeekR1</a>.</p><p>These are heavy technical reports, and if you don't know a lot of linear algebra, you probably won't understand much. But what you should really try is to download the free DeepSeek app on the AppStore <a href=\"https://apps.apple.com/us/app/deepseek-ai-assistant/id6737597349\">here</a> and install it using a Google account to log in and give it a try (you can also install it on Android <a href=\"https://play.google.com/store/apps/details?id=com.deepseek.chat&amp;hl=en_US&amp;pli=1\">here</a>), or simply try it out on your desktop computer in the browser <a href=\"https://chat.deepseek.com/\">here</a>. Make sure to select the \"DeepThink\" option to enable chain-of-thought (the R1 model) and ask it to explain parts of the technical reports in simple terms.</p><p>This will simultaneously show you a few important things:</p><ul><li><p>One, this model is absolutely legit. There is a lot of BS that goes on with AI benchmarks, which are routinely gamed so that models appear to perform great on the benchmarks but then suck in real world tests. Google is certainly the worst offender in this regard, constantly crowing about how amazing their LLMs are, when they are so awful in any real world test that they can't even reliably accomplish the simplest possible tasks, let alone challenging coding tasks. These DeepSeek models are not like that— the responses are coherent, compelling, and absolutely on the same level as those from OpenAI and Anthropic.</p></li><li><p>Two, that DeepSeek has made profound advancements not just in model quality, but more importantly in model training and inference efficiency. By being extremely close to the hardware and by layering together a handful of distinct, very clever optimizations, DeepSeek was able to train these incredible models using GPUs in a dramatically more efficient way. By some measurements, over ~45x more efficiently than other leading-edge models. DeepSeek claims that the complete cost to train DeepSeek-V3 was just over $5mm. That is absolutely nothing by the standards of OpenAI, Anthropic, etc., which were well into the $100mm+ level for training costs for a single model as early as 2024.</p></li></ul><p>How in the world could this be possible? How could this little Chinese company completely upstage all the smartest minds at our leading AI labs, which have 100 times more resources, headcount, payroll, capital, GPUs, etc? Wasn't China supposed to be crippled by Biden's restriction on GPU exports? Well, the details are fairly technical, but we can at least describe them at a high level. It might have just turned out that the relative GPU processing poverty of DeepSeek was the critical ingredient to make them more creative and clever, necessity being the mother of invention and all.</p><p>A major innovation is their sophisticated mixed-precision training framework that lets them use 8-bit floating point numbers (FP8) throughout the entire training process. Most Western AI labs train using \"full precision\" 32-bit numbers (this basically specifies the number of gradations possible in describing the output of an artificial neuron; 8 bits in FP8 lets you store a much wider range of numbers than you might expect— it's not just limited to 256 different equal-sized magnitudes like you'd get with regular integers, but instead uses clever math tricks to store both very small and very large numbers— though naturally with less precision than you'd get with 32 bits.) The main tradeoff is that while FP32 can store numbers with incredible precision across an enormous range, FP8 sacrifices some of that precision to save memory and boost performance, while still maintaining enough accuracy for many AI workloads.</p><p>DeepSeek cracked this problem by developing a clever system that breaks numbers into small tiles for activations and blocks for weights, and strategically uses high-precision calculations at key points in the network. Unlike other labs that train in high precision and then compress later (losing some quality in the process), DeepSeek's native FP8 approach means they get the massive memory savings without compromising performance. When you're training across thousands of GPUs, this dramatic reduction in memory requirements per GPU translates into needing far fewer GPUs overall.</p><p>Another major breakthrough is their multi-token prediction system. Most Transformer based LLM models do inference by predicting the next token— one token at a time. DeepSeek figured out how to predict multiple tokens while maintaining the quality you'd get from single-token prediction. Their approach achieves about 85-90% accuracy on these additional token predictions, which effectively doubles inference speed without sacrificing much quality. The clever part is they maintain the complete causal chain of predictions, so the model isn't just guessing— it's making structured, contextual predictions.</p><p>One of their most innovative developments is what they call Multi-head Latent Attention (MLA). This is a breakthrough in how they handle what are called the Key-Value indices, which are basically how individual tokens are represented in the attention mechanism within the Transformer architecture. Although this is getting a bit too advanced in technical terms, suffice it to say that these KV indices are some of the major uses of VRAM during the training and inference process, and part of the reason why you need to use thousands of GPUs at the same time to train these models— each GPU has a maximum of 96 gb of VRAM, and these indices eat that memory up for breakfast.</p><p>Their MLA system finds a way to store a compressed version of these indices that captures the essential information while using far less memory. The brilliant part is this compression is built directly into how the model learns— it's not some separate step they need to do, it's built directly into the end-to-end training pipeline. This means that the entire mechanism is \"differentiable\" and able to be trained directly using the standard optimizers. All this stuff works because these models are ultimately finding much lower-dimensional representations of the underlying data than the so-called \"ambient dimensions\". So it's wasteful to store the full KV indices, even though that is basically what everyone else does.</p><p>Not only do you end up wasting tons of space by storing way more numbers than you need, which gives a massive boost to the training memory footprint and efficiency (again, slashing the number of GPUs you need to train a world class model), but it can actually end up improving model quality because it can act like a \"regularizer,\" forcing the model to pay attention to the truly important stuff instead of using the wasted capacity to fit to noise in the training data. So not only do you save a ton of memory, but the model might even perform better. At the very least, you don't get a massive hit to performance in exchange for the huge memory savings, which is generally the kind of tradeoff you are faced with in AI training.</p><p>They also made major advances in GPU communication efficiency through their DualPipe algorithm and custom communication kernels. This system intelligently overlaps computation and communication, carefully balancing GPU resources between these tasks. They only need about 20 of their GPUs' streaming multiprocessors (SMs) for communication, leaving the rest free for computation. The result is much higher GPU utilization than typical training setups achieve.</p><p>Another very smart thing they did is to use what is known as a Mixture-of-Experts (MOE) Transformer architecture, but with key innovations around load balancing. As you might know, the size or capacity of an AI model is often measured in terms of the number of parameters the model contains. A parameter is just a number that stores some attribute of the model; either the \"weight\" or importance a particular artificial neuron has relative to another one, or the importance of a particular token depending on its context (in the \"attention mechanism\"), etc.</p><p>Meta's latest Llama3 models come in a few sizes, for example: a 1 billion parameter version (the smallest), a 70B parameter model (the most commonly deployed one), and even a massive 405B parameter model. This largest model is of limited utility for most users because you would need to have tens of thousands of dollars worth of GPUs in your computer just to run at tolerable speeds for inference, at least if you deployed it in the naive full-precision version. Therefore most of the real-world usage and excitement surrounding these open source models is at the 8B parameter or highly quantized 70B parameter level, since that's what can fit in a consumer-grade Nvidia 4090 GPU, which you can buy now for under $1,000.</p><p>So why does any of this matter? Well, in a sense, the parameter count and precision tells you something about how much raw information or data the model has stored internally. Note that I'm not talking about reasoning ability, or the model's \"IQ\" if you will: it turns out that models with even surprisingly modest parameter counts can show remarkable cognitive performance when it comes to solving complex logic problems, proving theorems in plane geometry, SAT math problems, etc.</p><p>But those small models aren't going to be able to necessarily tell you every aspect of every plot twist in every single novel by Stendhal, whereas the really big models can potentially do that. The \"cost\" of that extreme level of knowledge is that the models become very unwieldy both to train and to do inference on, because you always need to store every single one of those 405B parameters (or whatever the parameter count is) in the GPU's VRAM at the same time in order to do any inference with the model.</p><p>The beauty of the MOE model approach is that you can decompose the big model into a collection of smaller models that each know different, non-overlapping (at least fully) pieces of knowledge. DeepSeek's innovation here was developing what they call an \"auxiliary-loss-free\" load balancing strategy that maintains efficient expert utilization without the usual performance degradation that comes from load balancing. Then, depending on the nature of the inference request, you can intelligently route the inference to the \"expert\" models within that collection of smaller models that are most able to answer that question or solve that task.</p><p>You can loosely think of it as being a committee of experts who have their own specialized knowledge domains: one might be a legal expert, the other a computer science expert, the other a business strategy expert. So if a question comes in about linear algebra, you don't give it to the legal expert. This is of course a very loose analogy and it doesn't actually work like this in practice.</p><p>The real advantage of this approach is that it allows the model to contain a huge amount of knowledge without being very unwieldy, because even though the aggregate number of parameters is high across all the experts, only a small subset of these parameters is \"active\" at any given time, which means that you only need to store this small subset of weights in VRAM in order to do inference. In the case of DeepSeek-V3, they have an absolutely massive MOE model with <a href=\"https://x.com/eliebakouch/status/1872304368462004608\">671B parameters</a>, so it's much bigger than even the largest Llama3 model, but only 37B of these parameters are active at any given time— enough to fit in the VRAM of two consumer-grade Nvidia 4090 GPUs (under $2,000 total cost), rather than requiring one or more H100 GPUs which cost something like $40k each.</p><p>It's rumored that both ChatGPT and Claude use an MoE architecture, with some leaks suggesting that GPT-4 had a total of 1.8 trillion parameters split across 8 models containing 220 billion parameters each. Despite that being a lot more doable than trying to fit all 1.8 trillion parameters in VRAM, it still requires multiple H100-grade GPUs just to run the model because of the massive amount of memory used.</p><p>Beyond what has already been described, the technical papers mention several other key optimizations. These include their extremely memory-efficient training framework that avoids tensor parallelism, recomputes certain operations during backpropagation instead of storing them, and shares parameters between the main model and auxiliary prediction modules. The sum total of all these innovations, when layered together, has led to the ~45x efficiency improvement numbers that have been tossed around online, and I am perfectly willing to believe these are in the right ballpark.</p><p>One very strong indicator that it's true is the cost of DeepSeek's API: despite this nearly best-in-class model performance, DeepSeek charges something like <a href=\"https://x.com/ai_for_success/status/1881371370120216618\">95% less money</a> for inference requests via its API than comparable models from OpenAI and Anthropic. In a sense, it's sort of like comparing Nvidia's GPUs to the new custom chips from competitors: even if they aren't quite as good, the value for money is so much better that it can still be a no-brainer depending on the application, as long as you can qualify the performance level and prove that it's good enough for your requirements and the API availability and latency is good enough (thus far, people have been <a href=\"https://x.com/VictorTaelin/status/1873876097794007545\">amazed</a> at how <a href=\"https://x.com/artificialguybr/status/1882979975692984373\">well</a> DeepSeek's infrastructure has held up despite the truly incredible surge of demand owing to the performance of these new models).</p><p>But unlike the case of Nvidia, where the cost differential is the result of them earning monopoly gross margins of 90%+ on their data-center products, the cost differential of the DeepSeek API relative to the OpenAI and Anthropic API could be simply that they are nearly 50x more compute efficient (it might even be significantly more than that on the inference side— the ~45x efficiency was on the training side). Indeed, it's not even clear that OpenAI and Anthropic are making great margins on their API services— they might be more interested in revenue growth and gathering more data from analyzing all the API requests they receive.</p><p>Before moving on, I'd be remiss if I didn't mention that many people are speculating that DeepSeek is simply lying about the number of GPUs and GPU hours spent training these models because they actually possess far more H100s than they are supposed to have given the export restrictions on these cards, and they don't want to cause trouble for themselves or hurt their chances of acquiring more of these cards. While it's certainly possible, I think it's more likely that they are telling the truth, and that they have simply been able to achieve these incredible results by being extremely clever and creative in their approach to training and inference. They explain how they are doing things, and I suspect that it's only a matter of time before their results are widely replicated and confirmed by other researchers at various other labs.</p><h2>A Model That Can Really Think</h2><p>The newer R1 model and technical report might even be even more mind blowing, since they were able to beat Anthropic to Chain-of-thought and now are basically the only ones besides OpenAI who have made this technology work at scale. But note that the O1 preview model was only released by OpenAI in mid-September of 2024. That's only ~4 months ago! Something you absolutely must keep in mind is that, unlike OpenAI, which is incredibly secretive about how these models really work at a low level, and won't release the actual model weights to anyone besides partners like Microsoft and other who sign heavy-duty NDAs, these DeepSeek models are both completely open-source and permissively licensed. They have released extremely detailed technical reports explaining how they work, as well as the code that anyone can look at and try to copy.</p><p>With R1, DeepSeek essentially cracked one of the holy grails of AI: getting models to reason step-by-step without relying on massive supervised datasets. Their DeepSeek-R1-Zero experiment showed something remarkable: using pure reinforcement learning with carefully crafted reward functions, they managed to get models to develop sophisticated reasoning capabilities completely autonomously. This wasn't just about solving problems— the model organically learned to generate long chains of thought, self-verify its work, and allocate more computation time to harder problems.</p><p>The technical breakthrough here was their novel approach to reward modeling. Rather than using complex neural reward models that can lead to \"reward hacking\" (where the model finds bogus ways to boost their rewards that don't actually lead to better real-world model performance), they developed a clever rule-based system that combines accuracy rewards (verifying final answers) with format rewards (encouraging structured thinking). This simpler approach turned out to be more robust and scalable than the process-based reward models that others have tried.</p><p>What's particularly fascinating is that during training, they observed what they called an \"aha moment,\" a phase where the model spontaneously learned to revise its thinking process mid-stream when encountering uncertainty. This emergent behavior wasn't explicitly programmed; it arose naturally from the interaction between the model and the reinforcement learning environment. The model would literally stop itself, flag potential issues in its reasoning, and restart with a different approach, all without being explicitly trained to do this.</p><p>The full R1 model built on these insights by introducing what they call \"cold-start\" data— a small set of high-quality examples— before applying their RL techniques. They also solved one of the major challenges in reasoning models: language consistency. Previous attempts at chain-of-thought reasoning often resulted in models mixing languages or producing incoherent outputs. DeepSeek solved this through a clever language consistency reward during RL training, trading off a small performance hit for much more readable and consistent outputs.</p><p>The results are mind-boggling: on AIME 2024, one of the most challenging high school math competitions, R1 achieved 79.8% accuracy, matching OpenAI's O1 model. On MATH-500, it hit 97.3%, and it achieved the 96.3 percentile on Codeforces programming competitions. But perhaps most impressively, they managed to distill these capabilities down to much smaller models: their 14B parameter version outperforms many models several times its size, suggesting that reasoning ability isn't just about raw parameter count but about how you train the model to process information.</p><p>The recent <a href=\"https://x.com/orikron/status/1882503121320214777\">scuttlebutt</a> on Twitter and Blind (a corporate rumor website) is that these models caught Meta completely off guard and that they perform better than the new Llama4 models which are still being trained. Apparently, the Llama project within Meta has attracted a lot of attention internally from high-ranking technical executives, and as a result they have something like 13 individuals working on the Llama stuff who each individually earn more per year in total compensation than the combined training cost for the DeepSeek-V3 models which outperform it. How do you explain that to Zuck with a straight face? How does Zuck keep smiling while shoveling multiple billions of dollars to Nvidia to buy 100k H100s when a better model was trained using just 2k H100s for a bit over $5mm?</p><p>But you better believe that Meta and every other big AI lab is taking these DeepSeek models apart, studying every word in those technical reports and every line of the open source code they released, trying desperately to integrate these same tricks and optimizations into their own training and inference pipelines. So what's the impact of all that? Well, naively it sort of seems like the aggregate demand for training and inference compute should be divided by some big number. Maybe not by 45, but maybe by 25 or even 30? Because whatever you thought you needed before these model releases, it's now a lot less.</p><p>Now, an optimist might say \"You are talking about a mere constant of proportionality, a single multiple. When you're dealing with an exponential growth curve, that stuff gets washed out so quickly that it doesn't end up matter all that much.\" And there is some truth to that: if AI really is as transformational as I expect, if the real-world utility of this tech is measured in the trillions, if inference-time compute is the new scaling law of the land, if we are going to have armies of humanoid robots running around doing massive amounts of inference constantly, then maybe the growth curve is still so steep and extreme, and Nvidia has a big enough lead, that it will still work out.</p><p>But Nvidia is pricing in a LOT of good news in the coming years for that valuation to make sense, and when you start layering all these things together into a total mosaic, it starts to make me at least feel extremely uneasy about spending ~20x the 2025 estimated sales for their shares. What happens if you even see a slight moderation in sales growth? What if it turns out to be 85% instead of over 100%? What if gross margins come in a bit from 75% to 70%— still ridiculously high for a semiconductor company?</p><p>At a high level, NVIDIA faces an unprecedented convergence of competitive threats that make its premium valuation increasingly difficult to justify at 20x forward sales and 75% gross margins. The company's supposed moats in hardware, software, and efficiency are all showing concerning cracks. The whole world— thousands of the smartest people on the planet, backed by untold billions of dollars of capital resources— are trying to assail them from every angle.</p><p>On the hardware front, innovative architectures from Cerebras and Groq demonstrate that NVIDIA's interconnect advantage— a cornerstone of its data center dominance— can be circumvented through radical redesigns. Cerebras' wafer-scale chips and Groq's deterministic compute approach deliver compelling performance without needing NVIDIA's complex interconnect solutions. More traditionally, every major NVIDIA customer (Google, Amazon, Microsoft, Meta, Apple) is developing custom silicon that could chip away at high-margin data center revenue. These aren't experimental projects anymore— Amazon alone is building out massive infrastructure with over 400,000 custom chips for Anthropic.</p><p>The software moat appears equally vulnerable. New high-level frameworks like MLX, Triton, and JAX are abstracting away CUDA's importance, while efforts to improve AMD drivers could unlock much cheaper hardware alternatives. The trend toward higher-level abstractions mirrors how assembly language gave way to C/C++, suggesting CUDA's dominance may be more temporary than assumed. Most importantly, we're seeing the emergence of LLM-powered code translation that could automatically port CUDA code to run on any hardware target, potentially eliminating one of NVIDIA's strongest lock-in effects.</p><p>Perhaps most devastating is DeepSeek's recent efficiency breakthrough, achieving comparable model performance at approximately 1/45th the compute cost. This suggests the entire industry has been massively over-provisioning compute resources. Combined with the emergence of more efficient inference architectures through chain-of-thought models, the aggregate demand for compute could be significantly lower than current projections assume. The economics here are compelling: when DeepSeek can match GPT-4 level performance while charging 95% less for API calls, it suggests either NVIDIA's customers are burning cash unnecessarily or margins must come down dramatically.</p><p>The fact that TSMC will manufacture competitive chips for any well-funded customer puts a natural ceiling on NVIDIA's architectural advantages. But more fundamentally, history shows that markets eventually find a way around artificial bottlenecks that generate super-normal profits. When layered together, these threats suggest NVIDIA faces a much rockier path to maintaining its current growth trajectory and margins than its valuation implies. With five distinct vectors of attack— architectural innovation, customer vertical integration, software abstraction, efficiency breakthroughs, and manufacturing democratization— the probability that at least one succeeds in meaningfully impacting NVIDIA's margins or growth rate seems high. At current valuations, the market isn't pricing in any of these risks.</p><p>I hope you enjoyed reading this article. If you work at a hedge fund and are interested in consulting with me on NVDA or other AI-related stocks or investing themes, I'm already signed up as an expert on <a href=\"https://glginsights.com/\">GLG</a> and <a href=\"https://www.colemanrg.com/\">Coleman Research</a>.</p>","contentLength":71791,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42822162"},{"title":"Using the most unhinged AVX-512 instruction to make fastest phrase search algo","url":"https://gab-menezes.github.io/2025/01/13/using-the-most-unhinged-avx-512-instruction-to-make-the-fastest-phrase-search-algo.html","date":1737668307,"author":"cmcollier","guid":185,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42808355"},{"title":"Show HN: 3D printing giant things with a Python jigsaw generator","url":"https://calbryant.uk/blog/3d-printing-giant-things-with-jigsaw-generator/","date":1737639304,"author":"naggie","guid":172,"unread":true,"content":"<p>I really like the idea of a fully automated pipeline when I build anything – it’s highly satisfying to see a machine do all the work for you. Combine this with parametric design, and it makes iteration and customisation a breeze. My flagship example is my recent <a href=\"https://calbryant.uk/blog/speakers/\">speaker project.</a></p><p>With the previous speaker project I was literally at the margins for the largest speaker I could comfortably make with my 3D printer – without significantly more work splitting up the design. I was looking to see what large format printers were out there – there are a handful but they’re expensive and possibly not as capable as what I have now.</p><p>Then I happened to watch a video where Richard from <a href=\"https://www.retrocollective.co.uk/\" target=\"_blank\" rel=\"noopener\">RMC</a> 3D prints an <a href=\"https://www.youtube.com/watch?v=SONO6LTHuR8\" target=\"_blank\" rel=\"noopener\">entire arcade machine</a> using a farm of relatively small printers. After creating the model,  he split it into macro layers, each of which where split into smaller parts that had a dovetail slot for assembly. It apparently worked really well.</p><p><strong>What if I could automate this process?</strong></p><p>In the last article about speaker design I mention the possibility of floor-standing speakers, glossing over the fact that I’d have to segment the print. If I constrained the system to work on panel-type designs such as this speaker system, it would be quite straightforward to implement.</p><p>I already wrote a system to place the parts nested on individual beds; I decided to adapt that code to also be able to split up panels into a what is effectively a jigsaw. I could use dovetail joins to do this, allowing something that can be easily glued and requiring no extra parts like dowels.</p><p>If I got it right, it would divide the parts through complex geometry without a significant impact on the final finish.</p><p>Dovetail joins are a traditional way to join wood together. They’re generally used for strength, but also aesthetics. They can be manually cut, or made using a handheld router (using a jig) or CNC router.</p><p>The strength comes from the tightening/wedging effect when pulling the join apart. If the dovetail is tapered, the join can also tighten when it aligns too – this is highly desirable for gluing, as it means the glue will not be scraped away.</p><p>I took a look at some dovetail implementations in OpenSCAD, but none had all the features I needed.</p><p>I desired an approach that would subtract plastic once such that we end up with a fully mated join straight away. In theory this would simplify the design such that the two parts don’t need 2 separate, complicated and overlapping negatives to subtract.</p><p>This calls for a thin “shell” type structure, like a zig-zagging ribbon; even better it should be tapered!</p><p>OpenSCAD, being <a href=\"https://en.wikipedia.org/wiki/Constructive_solid_geometry\" target=\"_blank\" rel=\"noopener\">CSG</a> based is not well suited to creating thin shells, so this can be a bit awkward to do.</p><p>Here is the deconstruction of the dovetail profile, after a few iterations to remove artefacts and optimise.</p><p>Interestingly, step 8 was originally done as an intersection, but I found that it absolutely destroyed OpenSCAD performance. You’re talking one frame every few minutes instead of dozens per second!</p><p>I didn’t remove the interfering edges at first – see the hanging artefacts screenshot later on. I was confused and thought it was a bug at first, until I examined the 3D tooth again.</p><p>Here’s the code that does exactly what you see above, complete with annotations to show what step corresponds to what. Only 68 lines!</p><div><div><div><div><table><tbody><tr><td><pre tabindex=\"0\"><code></code></pre></td><td><pre tabindex=\"0\"><code data-lang=\".scad\"></code></pre></td></tr></tbody></table></div></div><a href=\"https://calbryant.uk/blog/3d-printing-giant-things-with-jigsaw-generator/dovetail.scad\" target=\"_blank\">Download</a><a href=\"javascript:;\">Copy</a></div></div><p>I made several test prints to find what felt like the right set of parameters for the ratios described above. I settled on quite a small tooth, as it would reduce the size of any artefacts produced. Plus, the fit felt tighter.</p><p>In case you’re wondering, I found the 0.2mm interference fit that Richard used in the video worked best, leaving a bit of play and somewhere for the glue to go.</p><p>Performance was kept in check by limiting the number of faces () in the tooth code. This was a good compromise, smooth enough and reduces stress concentration sufficiently.</p><p>I am a little concerned about the <a href=\"https://en.wikipedia.org/wiki/Z-fighting\" target=\"_blank\" rel=\"noopener\">Z-fighting</a> hat occurs when the parts are joined. Usually I make sure the parts intersect a little to avoid this. It looks fine, I’ll just hope I don’t have any manifolding issues later on for now.</p><p>Sometimes the top part of a tapered tooth can be suspended in mid-air – this occurs when a boundary occurs at a tooth edge. This is a problem as it will cause spaghetti when printing, not to mention missing chunks in the final design.</p><p>I realised I could at least detect and remove these artefacts in the (post-processing) code by looking for independent tiny fragments that aren’t touching the bed. I can at least then prevent the spaghetti; there will still be a hole in the design but I presume most of the time that can be addressed in the finishing step.</p><h2>Automatically splitting up STLs</h2><p>Now that I had geometry to create the joins in-place, I needed to automate the process so I can cut up an <a href=\"https://www.xkcd.com/974/\" target=\"_blank\" rel=\"noopener\">arbitrary</a> design to fit on a given printer.</p><p>As I’ve mentioned, this only has to work on panels so I have the luxury of only having to operate in 2D and assume the parts are mainly flat and rectangular.</p><p>To automate it, I figured it would be far easier to do this (mostly) outside of OpenSCAD and operate on <a href=\"https://en.wikipedia.org/wiki/STL_(file_format)\" target=\"_blank\" rel=\"noopener\">STLs</a> directly. That way this system will work on 3D printed models from any CAD software.</p><p>I have already developed some part nesting software using <a href=\"https://github.com/secnot/rectpack\" target=\"_blank\" rel=\"noopener\">rectpack</a> and <a href=\"https://pypi.org/project/numpy-stl/\" target=\"_blank\" rel=\"noopener\">numpy-stl</a>, so I decided to use that as a base.</p><p>The resulting code is straightforward. Here’s how it works:</p><ol><li>Load the STL file and find the bounding box of the model</li><li>Rotate it so the aspect ratio matches the bed of the printer (and optionally, so the design is at its longest along the same axis as the printer bed)</li><li>Calculate how m any sub-divisions are necessary on each axis to produce parts that will fit on the bed (margin of tooth size required)</li><li>Execute an OpenSCAD template that will subtract the dovetail teeth from the model, translating the STL so each cut is in the right place</li><li>Split those STLs into separate files with  cli</li><li>Remove any edge artefacts by looking for small objects</li></ol><p>I refactored by nesting code to allow adding the dovetail splitting code without causing a mess. After a lot of debugging I ran the code, only to be disappointed! It took 4 hours to run per operation, only to fail with these errors:</p><ul><li><code>ERROR: CGAL error in CGALUtils::applyBinaryOperator difference: CGAL ERROR: assertion violation!</code></li><li><code>ERROR: The given mesh is not closed! Unable to convert to CGAL_Nef_Polyhedron</code></li></ul><p>OpenSCAD uses the <a href=\"https://www.cgal.org/\" target=\"_blank\" rel=\"noopener\">CGAL</a> library which is notoriously slow, and it can produce non-manifold meshes. The speaker design I made produces <a href=\"https://blender.stackexchange.com/questions/7910/what-is-non-manifold-geometry\" target=\"_blank\" rel=\"noopener\">non-manifold</a> STLs – I think they have holes in due to some OpenSCAD implementation issues, or something with my code.</p><p>Those errors above are likely to be caused by these non-manifold edges. What could I do? I didn’t want to get this far only to abandon the project. Luckily, recently OpenSCAD has integrated a new geometry library called <a href=\"https://github.com/elalish/manifold\" target=\"_blank\" rel=\"noopener\">manifold</a> which is apparently several orders of magnitude faster and more robust.</p><p>I tried this using an unstable version of OpenSCAD with the  flag, and it worked! Not only did it work, but it computed the design in  This is 64500x improvement (and it works).</p><p>I should try manifold with the rest of the design. Manifold seems to use more memory and is multi-threaded, so I’d have to modify my build scripts which currently build 16 parts at once – last time I tried it overwhelmed the system.</p><p>Anyway, after an evening of more hacking I got it properly integrated and behaving as expected. Here’s <a href=\"https://calbryant.uk/blog/speakers/\">the previous speaker design</a> with a bed size reduced to 200x200 – this means it could be printed on a Prusa i3!</p><p>It seems to have worked exceptionally well. I like how the nesting algorithm has placed the split parts together as well to reduce required beds. This will decrease total printing time and effort. In one case (bed 17) the part did not fit in one bed, but was split so it could be.</p><p>Looking at the corners, it seems quite common for the above to occur. As we know where the intersections of dovetail joins are, we could skip teeth to avoid the issue. That’s for another day though.</p><p>I’ve linked the code above. It expects , ,  and , as well as the dovetail.scad to be in . I hacked it from 2 files, so it might need a few fixes to work.</p><p>The chosen profile is self-aligning, and increases the surface area for glue to bond. It’s easy to align against a straight edge if a silicone mat is used to prevent the glue from sticking to things it shouldn’t.</p><p>This has successfully unlocked a floor-standing speaker design using this method in the near future, after validating the design and experimenting with different adhesives and finishes. Or, perhaps I will repackage my small MDF subwoofer I built a few years ago.</p><p>I could have implemented this as part of the speaker design with about 12 special cases. This way I could also avoid edge artefacts and more carefully place the joins to avoid detailed geometry. However, this is less transferable to other designs and less elegant in my opinion.</p><p>With some improvements, I could have the best of both worlds:</p><ul><li>Give it the ability to vary the part division location to avoid complex geometry for the best part finish. This would involve evaluating potential cross-sections of the model for complexity; a simple heuristic of the number of faces in a given cross section would be a good start.</li><li>Do the same to try to avoid big gaps (for the brace, for instance)</li><li>Skip teeth where joins intersect as mentioned above</li><li>Skip teeth near voids/edges</li></ul><p>To do this, and possibly to replace the use of numpy-stl and/or OpenSCAD, I could look into <a href=\"https://trimsh.org\" target=\"_blank\" rel=\"noopener\">trimesh</a> which can do a lot more.</p><p>I’m confident the assembled parts will allow for a flawless finish if filled and sanded, given my experience with the last project.</p><p>I have made the code available linked to this post for the time being – I will happily package this up properly if there’s significant interest. I’m curious as to what other people could do with the idea or variant thereof.</p><div role=\"doc-endnotes\"><ol><li><p>…because I’m a coder at heart&nbsp;</p></li><li><p>derived from an imperfect scanned reference. Impressive.&nbsp;</p></li><li><p>The video doesn’t do justice to the monumental amount of work this represents.&nbsp;</p></li><li><p>OK so technically it’s not arbitrary, but it’s a good word! I had to get that XKCD reference in there somewhere.&nbsp;</p></li><li><p>Of course you could go the other way and print something giant on my 256x256 X1C bed, but then I’d be doing the title justice!&nbsp;</p></li><li><p>I had assumed I’d want to mill the next speaker, but my last project was such as success I will happily take the advantages!&nbsp;</p></li></ol></div><p>Please <a href=\"https://calbryant.uk/cdn-cgi/l/email-protection#c9aaa8a5a5a8a7e7abbbb0a8a7bd89aea4a8a0a5e7aaa6a4\">email me</a> with any corrections or feedback.</p>","contentLength":10535,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42803822"},{"title":"Using generative AI as part of historical research: three case studies","url":"https://resobscura.substack.com/p/the-leading-ai-models-are-now-very","date":1737588561,"author":"benbreen","guid":184,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42798649"},{"title":"So you wanna write Kubernetes controllers?","url":"https://ahmet.im/blog/controller-pitfalls/","date":1737585200,"author":"gokhan","guid":183,"unread":true,"content":"<p>Any company using Kubernetes eventually starts looking into developing their\ncustom controllers. After all, what’s not to like about being able to provision\nresources with declarative configuration: <a href=\"https://youtu.be/zCXiXKMqnuE?t=128\">Control loops</a> are fun,\nand <a href=\"https://kubebuilder.io/\">Kubebuilder</a> makes it extremely easy to get started with writing Kubernetes\ncontrollers. Next thing you know, customers in production are relying on the\nbuggy controller you developed without understanding how to design idiomatic\nAPIs and building reliable controllers.</p><p>Low barrier to entry combined with good intentions and the “illusion of\n implementation” is not a recipe for\nsuccess while developing production-grade controllers. I’ve seen the real-world\nconsequences of controllers developed without adequate understanding of\nKubernetes and the controller machinery at multiple large companies. We went\nback to the drawing board and rewritten nascent controller implementations a few\ntimes to observe which mistakes people new to controller development\nmake.</p><h2>Design CRDs like Kubernetes APIs</h2><p>It takes less than 5 minutes to write a Go struct and generate a Kubernetes\nCustomResourceDefinition (CRD) from it thanks to controller-gen. Then it takes\nseveral months to <a href=\"https://www.linkedin.com/blog/engineering/infrastructure/how-linkedin-moved-its-kubernetes-apis-to-a-different-api-group\">migrate</a> from this poorly designed API to a better v2 design\nwhile the old API is being used in productionDon’t do yourself that.</p><p>If you’re serious about developing long-lasting production grade controllers,\nyou have to deeply understand the <a href=\"https://github.com/kubernetes/community/blob/8a99192b3780b656f9dd53c0c37d9372a1c975f9/contributors/devel/sig-architecture/api-conventions.md\">API Conventions</a> that\nKubernetes uses to design its builtin APIs. Then, you need to study the builtin\nAPIs, and think about things like “why is this field here”, “why is this field\nnot a boolean”, “why is this a list of objects and not a string array”. Only\nwhen you’re able to reason about the builtin Kubernetes APIs and their design\nprinciples, you’ll be able to design a long-lasting custom resource API.</p><ol><li><p>They don’t understand the difference between  and  and who\nshould be updating each field (more about this later ).</p></li><li><p>They don’t understand how to embed a child object within a parent object\n(e.g. how  becomes a ) so they end up\nre-creating child object properties in the parent object, usually with a\nworse organized structure.</p></li><li><p>They don’t understand field semantics well (e.g. zero values, defaulting,\nvalidation) and end up with fields that are not set, or set to wrong values\naccepted into the API.\nI covered this topic in my\n<a href=\"https://ahmet.im/blog/crd-generation-pitfalls/\">CRD generation pitfalls article</a>. If the behavior of the\nAPI is not clear when a field is not set, you’ve already failed.\n<a href=\"https://github.com/kubernetes/community/blob/8a99192b3780b656f9dd53c0c37d9372a1c975f9/contributors/devel/sig-architecture/api-conventions.md\">API conventions</a> guide covers this topic fairly well.</p></li></ol><p>If you study the builtin Kubernetes APIs extensively, you’ll find out things like\n field is not a “must have”, and not all APIs offer a  field.\nI would go as far as to say that you should also study custom APIs of projects\nlike Knative, Istio and other popular controllers to develop a better\nunderstanding of organizing fields, and how to reuse some core types Kubernetes\nalready offers (like , ).</p><h2>Single-responsibility controllers</h2><p>Time and time again we find engineers adding new unrelated responsibilities to\nexisting controllers because it seems like a good place their  can be\nshoved into. Kubernetes core controllers don’t have this problem for a reason.</p><p>One of the main Kubernetes <a href=\"https://github.com/kubernetes/design-proposals-archive/blob/acc25e14ca83dfda4f66d8cb1f1b491f26e78ffe/architecture/principles.md#design-principles\">design principles</a> is that controllers have clear\ninputs and outputs —and they do a well-defined job. For example, the Job\ncontroller watches  objects and creates s, which is a clear mental\nmodel to reason about. Similarly, each API is designed to offer a well defined\nfunctionality. A controller’s output can be an input to another controller.\nThis is all what the <a href=\"https://en.wikipedia.org/wiki/Unix_philosophy#Origin\">UNIX\nphilosophy</a> suggests for\na well reasoned system.</p><p>I recommend studying the common <a href=\"https://youtu.be/zCXiXKMqnuE?t=539\">controller shapes</a> (great talk by Daniel Smith,\none of the architects of kube-apiserver) and the core Kubernetes controllers.\nYou’ll notice that each core controller in Kubernetes core has a very clear job\nand inputs/outputs that can be explained in a small diagram. If your controller\nisn’t like this, you’re probably misarchitecting either your controller, or your\nCRDs.</p><p>If you architect your APIs and controllers correctly, your controllers will run\nin harmony as if they’re integrating with Kubernetes core APIs or an\noff-the-shelf operator.</p><p>When you controller design doesn’t quite feel right, or has too many\ninputs/outputs, does too much, or in general doesn’t , you’re\nprobably doing it unidiomatically. I struggled with this a lot myself,\nespecially while developing controllers that manage external resources that have\na non-declarative configuration paradigm.</p><p>Assuming you use kubebuilder (which uses <a href=\"https://github.com/kubernetes-sigs/controller-runtime\">controller-runtime</a> like\nalmost everyone else to develop a controller, and you implement the\n method that controller-runtime invokes every time one of your\ninputs change. This is where your controller does its magic, and since it’s\npossible to implement this method in any way, most beginners dump their\nspaghetti here.</p><p>Therefore, large projects like Knative define their own <a href=\"https://github.com/knative/pkg/tree/accfe36491888e45ce8bd923ff8996283c055ae1/reconciler\">common controller\nshapes</a>\nwhere every controller runs the same set steps in the same order.  By developing\na common controller shape/framework, you create a “guardrail” so that other\nengineers don’t deviate and introduce bugs in the reconciliation flow easily.</p><p>Sadly, controller-runtime is not opinionated about this topic. Your best bet is\nto read other controllers (like <a href=\"https://github.com/kubernetes-sigs/cluster-api\">Cluster\nAPI</a> to learn the idioms and\nmaster the reconciliation flow.</p><p>There are also new projects like <a href=\"https://github.com/reddit/achilles-sdk\">Apollo SDK by\nReddit</a> that claims to offer\nfinite-state machines for controller-runtime reconcilers.</p><p>Over time, we found that almost all our controllers have a similar\nreconciliation flow. Here’s a pseudo-code of how our controllers look like:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Most notably, you’ll see here that we always initialize conditions and always\nupdate status inside  even if the reconciliation fails.</p><p>I recommend enforcing a similar common shape for controllers developed at your\ncompany (you can use custom kubebuilder plugins during scaffolding, but you\ncan’t really  that either).</p><h2>Report  and </h2><p>I practically never seen a beginner engineer create a CRD that has properly\ndesigned  fields (if one exists, at all). Kubernetes <a href=\"https://github.com/kubernetes/community/blob/8a99192b3780b656f9dd53c0c37d9372a1c975f9/contributors/devel/sig-architecture/api-conventions.md\">API\nconventions</a> discuss this at length, so I’ll keep it\nbrief. If an API object is reconciled by a controller, the resource should\nexpose its status in  fields. For example, there’s no ConfigMap\ncontroller so ConfigMap doesn’t have a  field.</p><p>At LinkedIn, our custom API objects have a  field, similar to\nthe Kubernetes core or <a href=\"https://github.com/knative/pkg/blob/accfe36491888e45ce8bd923ff8996283c055ae1/apis/condition_types.go#L58-L85\">Knative\nconditions</a>,\nand we use something similar to <a href=\"https://github.com/knative/pkg/blob/accfe36491888e45ce8bd923ff8996283c055ae1/apis/condition_set.go\">Knative condition set manager</a> that provides\nhigh-level accessor methods to set the conditions, and sort them etc.</p><p>This helps us define and report conditions for API objects in a high-level way\nin the reconciler code:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Every time we mark a condition, the condition manager recalculates the top-level\n condition, which all our objects have as Kubernetes API conventions\nsuggest. Other controllers and humans consume this top-level condition to\nunderstand how the objects are doing (plus you get to use <a href=\"https://github.com/ahmetb/kubectl-cond/\"></a>\non your objects).</p><h2>Learn to use </h2><p>Something notable is that all our  have an \nfield. You’ll even see some popular community CRDs (like ArgoCD\n<a href=\"https://doc.crds.dev/github.com/argoproj/argo-cd/argoproj.io/Application/v1alpha1@v2.13.3\">Application</a>)\ndo not offer this field.</p><p>Essentially, this field tells us whether the condition is calculated based on\nthe last configuration of the object —or whether we’re looking at\na scale status information because the controller hasn’t gotten to reconciling\nthe object after the update.</p><p>For example, observing a  condition set to  alone means nothing\n(other than at some point in the past it was true). The condition offers a\nmeaningful status info if and only if the <code>cond.observedGeneration == metadata.generation</code>.</p><p> A controller we had in production didn’t have the notion\nof , so its callers would update the object’s  and\nimmediately check its  condition. This condition would almost always be\nstale, as the controller hadn’t reconciled the object yet. So the callers\ninterpreted an app rollout as , even though it hadn’t even started\nyet (and sometimes actually failed, but that failure was never noticed).</p><h2>Understand the cached clients</h2><p>controller-runtime, by default, gives you a client to the Kubernetes API which\nserves the reads from an in-memory cache (as it uses <a href=\"https://leftasexercise.com/2019/07/15/understanding-kubernetes-controllers-part-iii-informers/\">shared informers</a> from\n under the covers). This is mostly fine, as controllers are designed\nto operate on stale data —but it is detrimental if you didn’t know this\nwas the case since you might be writing buggy controllers due to this (more on\nthis later in “expectations” section).</p><p>When you perform a write (which directly hits the API server), its results may\nnot be immediately visible in the cached client. For example, when you delete an\nobject, it may still show up in the list result in a subsequent reconciliation\nto your surprise.</p><p>The lesser-known behavior of controller-runtime most beginners don’t realize is\nthat controller-runtime establishes new informers on-the-fly. Normally, when you\nspecify explicit event sources while building your controller (e.g. in\n<code>builder.{For,Owns,Watches}</code>), the informers are started and caches are started\nduring startup.</p><p>However, if you try to make queries with  on resources that\nyou haven’t declared upfront in your controller setup, controller-runtime will\ninitialize an informer on-the-fly and block on warming up its cache. This leads\nto issues like:</p><ul><li>Controller-runtime starting a watch for a resource type and start caching all\nits objects in memory (even if you were trying to query only one resource),\npotentially leading to the process running out of memory.</li><li>Unpredictable reconciliation times while the informer cache is syncing, during\nwhich your worker goroutine will be blocked from reconciling other resources.</li></ul><p>That’s why I recommend setting <code>ReaderFailOnMissingInformer: true</code> and disabling\nthis behavior so you’re fully aware of what kinds your controller is maintaining\nwatches/caches on. Otherwise, controller-runtime doesn’t provide any\nobservability on what informers it’s maintaining in the process.</p><p>controller-runtime offers <a href=\"https://pkg.go.dev/sigs.k8s.io/controller-runtime/pkg/cache#Options\">a lot of other cache knobs</a>, such as entirely\ndisabling the cache on certain types, dropping some fields from the in-memory\ncache, or limit the cache to certain namespaces. I recommend studying them to\nbetter understand how you can customize the cache behavior.</p><h2>Fast and offline reconciliation</h2><p>Reconciling an object that is alredy up-to-date (i.e. goal state == current\nstate) should be really fast and offline —meaning it should not make any\nAPI calls (to external APIs or writes to Kubernetes API). That’s why controllers\nuse <a href=\"https://ahmet.im/blog/controller-pitfalls/#understand-the-cached-clients\">cached clients</a> to serve reads from the\ncache to determine the state of the world.</p><p>I’ve seen many real-world controllers making API calls to external systems, or\nmake status updates to Kubernetes API (even when nothing has changed) every time\n got invoked. This is an anti-pattern, and a really bad idea for\nwriting scalable and reliable controllers:</p><ol><li><p>They bombarded the external APIs with unnecessary calls during controller\nstartup (or full resyncs, or when they had bugs causing infinite requeue\nloops)</p></li><li><p>When the external API was down, reconciliation would fail even though\nnothing has changed in the object. Depending on the implementation, this\ncan block the next steps in the reconciliation flow even though those steps\ndon’t depend on this external API call.</p></li><li><p>Logic that takes long to execute in a reconciliation loop will hog the worker\ngoroutine, and cause workqueue depth to increase, and reduce the\nthroughput/responsiveness of the controller as the worker goroutine is\noccupied with the slow task.</p></li></ol><p>Let’s go through a concrete example: Assume you have an S3Bucket controller that\ncreates and manages S3 buckets using AWS S3 API. If you make a query to S3 API\non every reconciliation, you’re doing it wrong. Instead, you should store the\nresult of the S3 API calls you made, in a field like\n<code>status.observedGeneration</code>, to reflect what’s the last generation of the object\nthat was successfully conveyed to S3 API. If this field has 0 value, the\ncontroller knows it needs to make a “Create Bucket” call to S3 API. When a\nclient updates the S3Bucket custom resource, its  will no\nlonger match its stored <code>status.observedGeneration</code>, so the controller knows it\nneeds to make a “Update Bucket” call to S3 API, and only upon success it will\nupdate the <code>status.observedGeneration</code> field. This way, you avoid making calls\nto the external S3 API when the object is already up-to-date.</p><p>Your  function signature returns\n<a href=\"https://pkg.go.dev/sigs.k8s.io/controller-runtime@v0.20.0/pkg/reconcile#Result\"></a>\n+ values. Usually beginners don’t have a solid grasp on what values to\nreturn from .</p><p>You should know that your  function is invoked every time your\nevent sources declared in <code>builder.{For,Owns,Watches}</code> changes. If you know\nthat, my general advice while returning reconciliation values:</p><ol><li><p>If you have s during reconciliation, return the error; not . Controller-runtime will requeue for you.</p></li><li><p>Use  only when there’s no error but something you started is\nstill in progress, and you want to check its status with the <a href=\"https://github.com/kubernetes/client-go/blob/9897373fe6348db656b1f4039033d509b8a4f241/util/workqueue/default_rate_limiters.go#L51-L53\">default backoff\nlogic</a>.</p></li><li><p>Use  only when you want to reconcile the object after\na certain time has passed. This is useful for implementing a wall-clock based\nperiodic reconciliation (e.g. a CronJob controller, or you want to retry\nreconciliation at a custom poll interval).</p></li></ol><p>It’s a <a href=\"https://groups.google.com/g/operator-framework/c/K7zwQiCJVYg/m/03NT2HYeCAAJ\">matter of\npreference</a>\nwhether your  function should make as much progress as possible in\na single run; or, return early every time you change something and requeue\nitself again. You’ll see the earlier approach is more unit-test friendly and\nwhat you’ll find more frequently in the open-source controllers because if your\nevent triggers are set up correctly, the object will get requeued anyway.</p><h2>Workqueue/resync mechanics</h2><p>OpenKruise has an <a href=\"https://openkruise.io/blog/learning-concurrent-reconciling/\">article about workqueue mechanics</a>, go read\nthat. I frequently see beginners not relying on assumptions like an object\nis guaranteed to be reconciled at the same time in different workers, so they\nend up implementing unnecessary locking mechanisms in their controllers.</p><p>Similarly, beginners frequently don’t understand  and  an\nobject gets reconciled. For example, when your controller updates the object\nit’s working on, it’ll be requeued for a reconciliation immediately again\n(because the update you made triggers watch event).</p><p>Even when no objects were updated, all watched resources will be requeued\nperiodically  to get reconciled again (called “resync” configured via\n option). This is the default behavior since the controllers may\nmiss watch events (very rare), or skip processing some events during leadership\nchange. But this behavior causes you to do a full reconciliation of all objects\ncached. So by default, your controller should assume it’ll reconcile the\nentire world periodically.</p><p> We had a controller that managed several thousand objects\nand it did a full resync every 20 minutes. Every object took several seconds to\nreconcile. So any time a client created or updated an object, it would not get\nreconciled until many minutes later, as it goes to the back of the workqueue\namong. If this happened during full resync or controller startup, it took\nmany minutes until any work was done on this object.</p><p>Starting with controller-runtime v0.20 has\n<a href=\"https://github.com/kubernetes-sigs/controller-runtime/releases/tag/v0.20.0\">introduced</a>\na <a href=\"https://github.com/alvaroaleman/controller-runtime/blob/bd6eede09a6d6fd3eebb374ee62c9338886a7e13/designs/priorityqueue.md\">priority\nqueue</a>\nimplementation for the workqueue. This would deprioritize reconciliation of\nobjects that were not edge-triggered (i.e. due to an create/update etc.) and\nmake the controller more responsive during full resyncs and controller startups.</p><p>That’s why understanding the workqueue semantics, worker count\n() and monitoring your controller’s reconciliation\nlatency, workqueue depth and active workers count is super important to know if\nyour controller scales or not.</p><p>We discussed above that controller-runtime client serves the  from an\ninformer cache, and doesn’t query the API server except during the\nstartup/resyncs.</p><p>This cache is kept up-to-date based on the received “watch” events from the API\nserver. Therefore, your controller will almost certainly read stale data at some\npoint, since the watch events arrive asynchronously after the writes you make.\nCached clients don’t offer <a href=\"https://arpitbhayani.me/blogs/read-your-write-consistency/\">read-your-writes\nconsistency</a>.</p><p>This means you need to program your  method with this assumption at\nall times. This is not at all intuitive, but a reality when you work with\na cached client. I’ll give several real-world examples:</p><p> You’re implementing the  controller. Controller sees\n*a\nReplicaSet with  , so it lists the pods with  (which\nis served from the cache), and you get 3 Pods. It turns out the informer cache\nwasn’t up-to-date, but the API actually had 5 pods.  Your controller creates 2\nmore pods, now you have 7 Pods.  Definitely not what you wanted.</p><p> Now you’re scaling down a ReplicaSet from 5 to 3. You list the\nPods, you see 5 Pods, you delete 2 Pods, and next time you list the Pods again,\nyou still see, you delete another 2 Pods. If your deletion logic is not\ndeterministic (e.g. sorting Pods by name), you scaled from 5 to 1\n—definitely not what you wanted.</p><p> For every object kind=, you create an object kind=. When\n gets updated, you update . The update succeeds, but next time you reconcile\n again, you don’t see an updated version of , so you update  to the\ngoal state again, and you get a  error because you’re updating the old\nversion of the object. But you already updated it, why update again?</p><p>If you don’t know how to solve these problems in your controller, it’s likely\nbecause you haven’t seen the “expectations” pattern before.</p><p>In this case, controllers need to do in memory bookkeeping of their expectations\nthat resulted from the successful writes they made.\nOnce an expectation is recorded, the controller knows it needs to wait for the\ncache to catch up (which will trigger another reconciliation), and not do its\njob based on the stale result it sees from the cache.</p><p>You can see many core controllers <a href=\"https://github.com/kubernetes/kubernetes/blob/a882a2bf50e630a9ffccbd02b8f759ea51de1c8f/pkg/controller/controller_utils.go#L119-L132\">use this\npattern</a>,\nand Elastic operator also has a <a href=\"https://github.com/elastic/cloud-on-k8s/blob/6c1bf954555e5a65a18a17450ccddab46ed7e5a5/pkg/controller/common/expectations/expectations.go#L16-L78\">great\nexplanation</a>\nalongside their implementation. We implemented a couple of variants of these\nat LinkedIn ourselves.</p><p>Usually when you have controller development questions, join the Kubernetes\nslack and ask in the #controller-runtime channel. The maintainers are very\nhelpful!  If you’re looking for a good controller implementation, I recommend\nstudying the <a href=\"https://github.com/kubernetes-sigs/cluster-api/\">Cluster API</a>\ncodebase.  Also, Operator SDK has a <a href=\"https://sdk.operatorframework.io/docs/best-practices/best-practices/\">best practices\nguide</a> you\nshould check out.</p><p>I’m not the most experienced person to write a detailed guide on this, but I’ll\nbe writing more about beginner pitfalls and controller development anti-patterns.</p><p>At LinkedIn we use a controller development exercise <a href=\"https://twitter.com/diptanu\">a former\ncolleague</a> came up with to onboard new engineers to\nget them to understand the controller machinery. This exercise touches many\naspects of controller development and gets people familiar with core Kubernetes\nAPIs:</p><blockquote><p>\nImplement a SequentialJob API and controller. The API should\nallow users to specify a series of run-to-completion (batch job) container\nimages to run sequentially.</p><ul><li><em>How do users specify the list of containers? (Do you use the core types?)</em></li><li><em>Do you report status? How is status calculated? How do you surface job failures?</em></li><li><em>Where do you validate user inputs? Where do you report reconciliation failures?</em></li><li><em>What happens if the SequentialJob changes while the jobs are running?</em></li><li><em>How are the child resources you created are cleaned up?</em></li></ul></blockquote><p>I hope this article helps you be a better controller developer. If you feel like\nthis sort of work resonates with you, we’re usually hiring nowadays <a href=\"https://www.linkedin.com/jobs/view/4118956306/\">[1]</a>\n[<a href=\"https://www.linkedin.com/jobs/view/4033362822/\">2</a>] so reach out to me for a referral!</p><p><em>Thanks to Mike Helmick for reading drafts of this article and giving feedback.</em></p>","contentLength":19657,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://news.ycombinator.com/item?id=42798230"}],"tags":["dev","hn"]}