{"id":"BRWJ2YmdUFoz1jUcCg5P21RYgb4CmSRDHkju2uMS7GB1447d","title":"Mouse Vs Python","displayTitle":"Dev - Python Blog","url":"https://blog.pythonlibrary.org/feed","feedLink":"https://www.blog.pythonlibrary.org/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":4,"items":[{"title":"Python 101 – An Intro to Working with INI files Using configparser","url":"https://www.blog.pythonlibrary.org/2025/04/09/python-101-an-intro-to-working-with-ini-files-using-configparser/","date":1744201820,"author":"Mike","guid":301,"unread":true,"content":"<p>Many programs require configuration. Most have a default configuration and many allow the user to adjust that configuration. There are many different types of configuration files. Some use text files while others use databases. Python has a standard library called  that you can use to work with Microsoft Windows INI files.</p><p>In this tutorial, you will cover the following topics:</p><ul></ul><p>By the end of this tutorial, you will be able to use INI configuration files programmatically with Python.</p><p>There are many examples of INI files on the Internet. You can find one over in the <a href=\"https://mypy.readthedocs.io/en/stable/config_file.html\">Mypy documentation</a>. Mypy is a popular type checker for Python. Here is the  file that they use as an example:</p><pre data-enlighter-language=\"ini\"># Global options:\n\n[mypy]\nwarn_return_any = True\nwarn_unused_configs = True\n\n# per-module options:\n\n[mypy-mycode.foo.*]\ndisallow_untyped_defs = True\n\n[ypy-mycode.bar]\nwarn_return_any = False\n\n[mypy-somelibrary]\nignore_missing_imports = True</pre><p>Sections are denoted by being placed inside square braces. Then, each section can have zero or more settings. In the next section, you will learn how to create this configuration file programmatically with Python.</p><p>The <a href=\"https://docs.python.org/3/library/configparser.html\">documentation</a> for Python’s module is helpful. They tell you how to recreate an example INI file right in the documentation. Of course, their example is not the Mypy example above. Your job is a little bit harder as you need to be able to insert comments into your configuration, which isn’t covered in the documentation. Don’t worry. You’ll learn how to do that now!</p><p>Open up your Python editor and create a new file called . Then enter the following code:</p><pre data-enlighter-language=\"python\"># create_config.py\n\nimport configparser\n\nconfig = configparser.ConfigParser(allow_no_value=True)\n\nconfig[\"mypy\"] = {\"warn_return_any\": \"True\",\n                  \"warn_unused_configs\": \"True\",}\nconfig.set(\"mypy\", \"\\n# Per-module options:\")\n\nconfig[\"mypy-mycode.foo.*\"] = {\"disallow_untyped_defs\": \"True\"}\nconfig[\"ypy-mycode.bar\"] = {\"warn_return_any\": \"False\"}\nconfig[\"mypy-somelibrary\"] = {\"ignore_missing_imports\": \"True\"}\n\nwith open(\"custom_mypy.ini\", \"w\") as config_file:\n    config_file.write(\"# Global options:\\n\\n\")\n    config.write(config_file)\n\n</pre><p>The documentation states that&nbsp; parameter allows for including sections that do not have values. You need to add this to be able to add comments in the middle of a section to be added as well. Otherwise, you will get a .</p><p>To add entire sections, you use a dictionary-like interface. Each section is denoted by the key, and that section’s values are added by setting that key to another dictionary.</p><p>Once you finish creating each section and its contents, you can write the configuration file to disk. You open a file for writing, then write the first comment. Next, you use the  method to write the rest of the file.</p><p>Try running the code above; you should get the same INI file as the one at the beginning of this article.</p><p>The library makes editing your configuration files mostly painless. You will learn how to change a setting in the config file and add a new section to your pre-existing configuration.</p><p>Create a new file named  and add the following code to it:</p><pre data-enlighter-language=\"python\"># edit_config.py\n\nimport configparser\n\nconfig = configparser.ConfigParser()\nconfig.read(\"custom_mypy.ini\")\n\n# Change an item's value\nconfig.set(\"mypy-somelibrary\", \"ignore_missing_imports\", \"False\")\n\n# Add a new section\nconfig[\"new-random-section\"] = {\"compressed\": \"True\"}\n\nwith open(\"modified_mypy.ini\", \"w\") as config_file:\n    config.write(config_file)\n</pre><p>In this case, after create the instance, you call to read the specified configuration file. Then you can set any value you want.</p><p>Unfortunately, you cannot use dictionary-like syntax to set values. Instead, you must use which takes the following parameters:</p><ul><li> – The name of the section.</li><li> – The option you wish to change.</li><li> – The new value you want to set.</li></ul><p>Adding a new section works like it did when you created the initial sections in the last code example. You still use dictionary-like syntax where the new section is the key and the value is a dictionary of one or more settings to go in your section.</p><p>When you run this code, it will create an INI file with the following contents:</p><pre data-enlighter-language=\"ini\">[mypy]\nwarn_return_any = True\nwarn_unused_configs = True\n\n[mypy-mycode.foo.*]\ndisallow_untyped_defs = True\n\n[ypy-mycode.bar]\nwarn_return_any = False\n\n[mypy-somelibrary]\nignore_missing_imports = False\n\n[new-random-section]\ncompressed = True\n\n</pre><p>Good job! You’ve just learned how to modify an INI file with Python!</p><p>Now you are ready to learn about reading INI files.</p><p>You already caught a glimpse of how to read a configuration file in the previous section. The primary method is by calling the ‘s method.</p><p>Here’s an example using the new INI file you just created:</p><pre data-enlighter-language=\"python\">&gt;&gt;&gt; import configparser\n&gt;&gt;&gt; config = configparser.ConfigParser()\n&gt;&gt;&gt; config.read(r\"C:\\code\\modified_mypy.ini\")\n['C:\\\\code\\\\modified_mypy.ini']\n&gt;&gt;&gt; config[\"mypy\"]\n&lt;Section: mypy&gt;\n&gt;&gt;&gt; config[\"mypy\"][\"warn_return_any\"]\n'True'\n&gt;&gt;&gt; config[\"unknown\"]\nTraceback (most recent call last):\n  Python Shell, prompt 8, line 1\n    config[\"unknown\"]\n  File \"c:\\users\\Mike\\appdata\\local\\programs\\python\\python312\\lib\\configparser.py\", line 941, in __getitem__\n    raise KeyError(key)\nbuiltins.KeyError: 'unknown'</pre><p>You can access individual values using dictionary syntax. If you happen to try to access a section or an option that does not exist, you will receive a .</p><p>The  has a second reading method called  that you can use as well. Here is an example:</p><pre data-enlighter-language=\"python\">&gt;&gt;&gt; sample_config = \"\"\"\n... [mypy]\n... warn_return_any = True\n... warn_unused_configs = True\n... \n... # Per-module options:\n... \n... [mypy-mycode.foo.*]\n... disallow_untyped_defs = True\n... \"\"\"\n&gt;&gt;&gt; config = configparser.ConfigParser(allow_no_value=True)\n&gt;&gt;&gt; config.read_string(sample_config)\n&gt;&gt;&gt; config[\"mypy\"][\"warn_return_any\"]\n'True'</pre><p>You use  to read in a multiline string and then access values inside of it. Pretty neat, eh?</p><p>You can also grab the section and them use list comprehensions to extract the options from each section:</p><pre data-enlighter-language=\"python\">&gt;&gt;&gt; config.sections()\n['mypy', 'mypy-mycode.foo.*']\n&gt;&gt;&gt; [option for option in config[\"mypy\"]]\n['warn_return_any', 'warn_unused_configs']</pre><p>The code above is a handy example for getting at the configuration options quickly and easily.</p><p>Having a way to configure your application makes it more useful and allows the user more control over how their copy of the application works. In this article, you learned how about the following topics:</p><ul></ul><p>The <a href=\"https://docs.python.org/3/library/configparser.html\">configparser library</a> has more features than what is covered here. For example, you can use interpolation to preprocess values or customize the parser process. Check out the documentation for full details on those and other features.</p><p>In the meantime, have fun and enjoy this neat feature of Python!</p><p>You might also be interested in these related articles:</p>","contentLength":6763,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How to Download the Latest Release Assets from GitHub with Python","url":"https://www.blog.pythonlibrary.org/2025/04/07/how-to-download-the-latest-release-assets-from-github-with-python/","date":1744057533,"author":"Mike","guid":300,"unread":true,"content":"<p>I recently needed to figure out how to write an updater script for a project I was working on. The application is released on an internal GitHub page with compressed files and an executable. I needed a way to check the latest release artifacts in GitHub and download them.</p><p>Let’s find out how all this works!</p><p>You will need to download and install a couple of packages to make this all work. Specifically, you will need the following:</p><p>You can install both of these using pip. Open up your terminal and run the following command:</p><pre data-enlighter-language=\"generic\">python -m pip install PyGithub requests</pre><p>Once this finishes, you should have everything you need to get the latest GitHub release assets.</p><h2>Downloading the Latest Release Assets</h2><p>The only other item you will need to make this work is a <a href=\"https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/managing-your-personal-access-tokens\">GitHub personal access token</a>. You will need to create one of those. Depending on your use case, you may want to create what amounts to a bot account to make your token last a little longer.</p><p>The next step is to write some code. Open up your favorite Python IDE and create a new file. Then add the following code to it:</p><pre data-enlighter-language=\"python\">import requests\n\nfrom&nbsp;github&nbsp;import&nbsp;Auth\nfrom&nbsp;github&nbsp;import&nbsp;Github\nfrom pathlib import Path\n\ntoken =  \"YOUR_PERSONAL_ACCESS_TOKEN\"\n\nheaders = CaseInsensitiveDict()\nheaders[\"Authorization\"] = f\"token {token}\"\nheaders[\"Accept\"] = \"application/octet-stream\"\nsession = requests.Session()\n\nauth = Auth.Token(token)  # Token can be None if the repo is public\ng = Github(auth=auth)\n\n# Use this one if you have an internal GitHub instance:\n#g = Github(auth=auth, base_url=\"https://YOUR_COMPANY_URL/api/v3\")\n\nrepo = g.get_repo(\"user/repo\")  # Replace with the proper user and repo combo\nfor release in repo.get_releases():\n    # Releases are returned with the latest first\n    print(release)\n    break\n\nfor asset in release.get_assets():\n    print(asset.name)\n    destination = Path(r\"C:\\Temp\") / asset.name\n    response = session.get(asset.url, stream=True, headers=headers)\n    with open(destination, \"wb\") as f:\n        for chunk in response.iter_content(1024*1024):\n            f.write(chunk)\n    print(f\"Downloaded asset to {destination}\")\n</pre><p>The first half of this code is your imports and boilerplate for creating a GitHub authentication token and a requests Session object. If you work for a company and have an internal GitHub instance, see the commented-out code and use that instead for your GitHub authentication.</p><p>The next step is to get the GitHub repository and loop over its releases. By default, the iterable will return the items with the latest first and the oldest last. So you break out of the loop on the first release found to get the latest.</p><p>At this point, you loop over the assets in the release. In my case, I wanted to find an asset that was an executable and download it, but this code downloads all the assets.</p><p>This is a pretty short example, but it demonstrates one of the many things you can do with the handy <a href=\"https://github.com/PyGithub/PyGithub\">PyGitHub</a> package. You should check it out if you need to script other tasks in GitHub.</p>","contentLength":2987,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"ANN: Spring Python eBook Sale 2025","url":"https://www.blog.pythonlibrary.org/2025/04/03/ann-spring-python-ebook-sale-2025/","date":1743682261,"author":"Mike","guid":299,"unread":true,"content":"<p data-pm-slice=\"1 1 []\">I am running a Spring sale on all my currently published Python books. You can get 25% off any of my complete books by using this code at checkout: </p><p>I have books on the following topics:</p><ul><li>Image Processing with Python</li><li>JupyterLab and Jupyter Notebook</li><li>Creating GUIs with wxPython</li></ul><p>Start learning some Python today!</p>","contentLength":304,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Textual – How to Add Widgets to a Container","url":"https://www.blog.pythonlibrary.org/2025/04/01/textual-how-to-add-widgets-to-a-container/","date":1743515056,"author":"Mike","guid":298,"unread":true,"content":"<p>Textual is an excellent Python package for creating beautiful user interfaces in your terminal. By default, Textual will arrange your widgets starting at the top of the screen and appending them in a vertically oriented stack. Each GUI or TUI toolkit provides a way to lay out your widgets. Textual is no different in this respect. They use an object called a&nbsp;.</p><p>You can use containers to create the following types of layouts:</p><ul></ul><p>You will be learning how to use all three of these types of layouts. You will also learn how to add more widgets at runtime.</p><h2>Creating a Vertical Layout</h2><p>The default orientation in Textual is to arrange widgets vertically. You don’t even need to use a CSS file to apply this orientation.</p><p>But what does a vertical layout mean anyway? A vertical layout is when you add widgets to your application vertically, from top to bottom. Here is an illustration of what that might look like:</p><p>Adding widgets to a Textual application will lay out the widgets similarly to the image above. If you want to see that for yourself, then open up your Python editor and create a new file named `vertical.py`.</p><p>Then enter the following code into your new script:</p><pre data-enlighter-language=\"python\"># vertical.py\n\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Button\n\n\nclass VerticalApp(App):\n\n    def compose(self) -&gt; ComposeResult:\n        yield Button(\"OK\")\n        yield Button(\"Cancel\")\n        yield Button(\"Go!\")\n\n\nif __name__ == \"__main__\":\n    app = VerticalApp()\n    app.run()</pre><p>Now open up a terminal and run your code. When you do so, you will see three buttons onscreen, with the topmost being your “OK” button and the bottom being the “Go!” button.</p><p>Here is a screenshot of the application to give you an idea of what it looks like:</p><p><img decoding=\"async\" src=\"https://www.blog.pythonlibrary.org/wp-content/uploads/2025/04/vertical-1024x551.png\" alt=\"Textual vertical (no CSS)\" width=\"1024\" height=\"551\" srcset=\"https://www.blog.pythonlibrary.org/wp-content/uploads/2025/04/vertical-1024x551.png 1024w, https://www.blog.pythonlibrary.org/wp-content/uploads/2025/04/vertical-300x161.png 300w, https://www.blog.pythonlibrary.org/wp-content/uploads/2025/04/vertical-768x413.png 768w, https://www.blog.pythonlibrary.org/wp-content/uploads/2025/04/vertical-1536x827.png 1536w, https://www.blog.pythonlibrary.org/wp-content/uploads/2025/04/vertical.png 2018w\" sizes=\"(max-width: 1024px) 100vw, 1024px\">\nYou can change the widget size, color, and more using each widget’s&nbsp;&nbsp;attribute, but using CSS is simpler. Let’s update the code above to use a&nbsp;&nbsp;file:</p><pre data-enlighter-language=\"python\"># verical_css.py\n\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Button\n\n\nclass VerticalApp(App):\n    CSS_PATH = \"vertical.tcss\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Button(\"OK\")\n        yield Button(\"Cancel\")\n        yield Button(\"Go!\")\n\n\nif __name__ == \"__main__\":\n    app = VerticalApp()\n    app.run()</pre><p>Now that you are referring to a CSS file, you should go ahead and write one. If you don’t, you will get an error when you attempt to run the code that says the CSS file could not be found.</p><p>Go ahead and open your favorite text editor or use your Python editor to create a file named `vertical.tcss`. Then enter the following code:</p><pre data-enlighter-language=\"css\">Screen {\n    layout: vertical;\n}\n\nButton {\n    width: 100%;\n    color: yellow;\n    background: red;\n}</pre><p dir=\"auto\">You do not need the&nbsp;&nbsp;portion of the CSS since that is technically taken care of automatically by Textual. Remember,&nbsp;&nbsp;is the default widget when you launch an application. However, it is always good to be explicit so you understand what is happening. If you want the output to look exactly like the previous example, you can delete this CSS’s&nbsp;&nbsp;portion and try running the code that way.</p><p dir=\"auto\">If you decide to include the&nbsp;&nbsp;portion of the CSS, you will make all of the&nbsp;&nbsp;widgets 100% wide, which means they will all stretch across the entire width of the screen. The CSS also defines the button text to be yellow and the buttons themselves to have a read background color.</p><p dir=\"auto\">When you run this code, you will see something like the following:</p><p dir=\"auto\">That’s a fun way to change your vertically oriented widget layout. But what happens if you set the height of the&nbsp;&nbsp;widgets to 50%? Well, you have three widgets. Three times 50 will be 150%, which is greater than what can be shown all at once. Textual will add a scrollbar if you add widgets that go off-screen.</p><p dir=\"auto\">Try adding that setting to your CSS and re-run the code. You should see something like the following:</p><p dir=\"auto\">You should spend a few moments trying out various width and height sizes. Remember, you don’t have to use percentages. You can also use Textual’s other unit types.</p><p dir=\"auto\">: All style attributes can be adjusted at runtime, which means you can modify the layout at runtime, too. Use this wisely so as not to confuse the user!</p><p dir=\"auto\">When you finish experimenting, you will be ready to learn how horizontal layouts work!</p><p dir=\"auto\">Laying widgets out horizontally, left-to-right, requires a little more work than laying them out vertically. But the change is still pretty minor, and in many ways, it affects only one line in the CSS file.</p><p dir=\"auto\">But before you change the CSS, you will want to update your Python code to point to the new CSS file. Open your Python editor and copy the previous example to a new file. Save it with the same&nbsp;&nbsp;and update the&nbsp;&nbsp;to point to a new CSS file named&nbsp;:</p><pre data-enlighter-language=\"python\"># horizontal.py\n\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Button\n\n\nclass HorizontalApp(App):\n    CSS_PATH = \"horizontal.tcss\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Button(\"OK\")\n        yield Button(\"Cancel\")\n        yield Button(\"Go!\")\n\n\nif __name__ == \"__main__\":\n    app = HorizontalApp()\n    app.run()</pre><p dir=\"auto\">Yes, this code is almost the same as the previous example, except the&nbsp;&nbsp;variable. That’s okay. The point is to show you how you can change the layout.</p><p dir=\"auto\">Create your&nbsp;&nbsp;file in a Python or text editor to make a horizontally oriented layout. Then enter the following CSS:</p><pre data-enlighter-language=\"css\">Screen {\n    layout: horizontal;\n}\n\nButton {\n    height: 100%;\n    color: yellow;\n    background: red;\n    border: solid green;\n}</pre><p dir=\"auto\">The CSS above added a border to the buttons to make them stand out a bit more. Depending on the terminal, the widgets appear to blend together more when arranged horizontally. You can add space around the widgets by setting the&nbsp;&nbsp;style, though.</p><p dir=\"auto\">When you run this code, you should see something like the following:</p><p>When using a horizontal layout, the horizontal scrollbar will not automatically appear if the widgets do not fit the screen. If you want to have a horizontal scrollbar, then you will need to set&nbsp;, like in the following CSS:</p><pre data-enlighter-language=\"css\">Screen {\n    layout: horizontal;\n    overflow-x: auto;\n}\n\nButton {\n    height: 100%;\n    color: yellow;\n    background: red;\n    border: solid green;\n}</pre><p dir=\"auto\">Now, set the widgets’ width to greater than 33% so that the scrollbar will appear. Spend some time experimenting, and you’ll soon figure it out!</p><p dir=\"auto\">The Textual package has several&nbsp;<a href=\"https://textual.textualize.io/api/containers\" rel=\"nofollow\">utility containers</a>&nbsp;you can use to lay out your widgets. You are most likely to use&nbsp;,&nbsp;, or&nbsp;&nbsp;containers. You can also combine the containers to create more complex layouts.</p><p dir=\"auto\">Here is a full list of the containers included with Textual at the time of writing:</p><ul dir=\"auto\"></ul><p dir=\"auto\">You will most likely use the&nbsp;,&nbsp;,&nbsp;, and&nbsp;&nbsp;containers the most.</p><p dir=\"auto\">Practicing is the best learning method, especially when laying out user interfaces. You can start your container journey by opening your Python editor and creating a new file called&nbsp;. Then enter the following code:</p><pre data-enlighter-language=\"python\"># horizontal_container.py\n\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Button\nfrom textual.containers import Horizontal\n\n\nclass HorizontalApp(App):\n\n    def compose(self) -&gt; ComposeResult:\n        yield Horizontal(\n            Button(\"OK\"),\n            Button(\"Cancel\"),\n            Button(\"Go!\"),\n        )\n\n\nif __name__ == \"__main__\":\n    app = HorizontalApp()\n    app.run()</pre><p dir=\"auto\">You import the&nbsp;&nbsp;container from&nbsp;. The main contents of a container is its widgets. You reuse the widgets from the previous example here. Pay attention and note that you do not need to use&nbsp;&nbsp;inside the container. You can simply add the widget instances instead.</p><p dir=\"auto\">When you run this code, you will see something like this:</p><p dir=\"auto\">What will happen if you use your&nbsp;&nbsp;file with this code? Try adding it to the code above and re-run your example.</p><p dir=\"auto\">The result will look familiar:</p><p dir=\"auto\">The real benefit using containers comes when you nest them. You’ll find out about that concept next!</p><p dir=\"auto\">Nesting containers allows you to combine horizontally and vertically oriented widgets, resulting in rows and columns of widgets. This design pattern can create some pretty nice layouts.</p><p dir=\"auto\">To start, create a new file called&nbsp;&nbsp;in your Python editor. Then add this code to it:</p><pre data-enlighter-language=\"python\"># nested_containers.py\n\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Button\nfrom textual.containers import Horizontal, Vertical\n\n\nclass NestedApp(App):\n\n    def compose(self) -&gt; ComposeResult:\n        yield Vertical(\n            Horizontal(\n                Button(\"One\"),\n                Button(\"Two\"),\n                classes=\"row\",\n            ),\n            Horizontal(\n                Button(\"Three\"),\n                Button(\"Four\"),\n                classes=\"row\",\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    app = NestedApp()\n    app.run()</pre><p dir=\"auto\">Your code above has a single&nbsp;&nbsp;container with two&nbsp;&nbsp;containers inside. You can think of the&nbsp;&nbsp;containers as “rows”. You can see that you set the&nbsp;&nbsp;parameters to “row” to identify them. Each row contains two&nbsp;&nbsp;widgets.</p><p dir=\"auto\">When you run this code, you will see something like this:</p><p dir=\"auto\">This example doesn’t use any CSS. You should do that! Update the code to include a CSS file called&nbsp;, like the code below:</p><pre data-enlighter-language=\"python\"># nested_containers.py\n\nfrom textual.app import App, ComposeResult\nfrom textual.widgets import Button\nfrom textual.containers import Horizontal, Vertical\n\n\nclass NestedApp(App):\n    CSS_PATH = \"nested.tcss\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Vertical(\n            Horizontal(\n                Button(\"One\"),\n                Button(\"Two\"),\n                classes=\"row\",\n            ),\n            Horizontal(\n                Button(\"Three\"),\n                Button(\"Four\"),\n                classes=\"row\",\n            ),\n        )\n\n\nif __name__ == \"__main__\":\n    app = NestedApp()\n    app.run()</pre><p>Then, create the&nbsp;&nbsp;file. You will be putting the following CSS rules into it:</p><pre data-enlighter-language=\"css\">Button {\n    content-align: center middle;\n    background: green;\n    border: yellow;\n    height: 1fr;\n    width: 1fr;\n}</pre><p dir=\"auto\">Here, you set various rules for the&nbsp;&nbsp;widgets to follow. You want the buttons to be green with a yellow border. You also set the width and height to&nbsp;, which causes the buttons to expand to fit all the horizontal and vertical space.</p><p dir=\"auto\">When you run this version of your code, you can see that the user interface has changed significantly:</p><p dir=\"auto\">Nice! You should spend some time adjusting the style rules and seeing how to change these layouts.</p><p dir=\"auto\">Learning how to create layouts is a fundamental skill that you will need to master to be able to create engaging, intuitive user interfaces. Fortunately, Textual gives you enough tools that you can create your user interfaces fairly easily. No; you don’t get a What-you-see-is-what-you-get (WYSIWYG) tool as you do with some GUI toolkits, such as QT Creator. But you do get live-coding with CSS, and since most of your user interface layouts are controlled there, tweaking the user interface is so nicer.</p><h2 dir=\"auto\">Want to Learn More Textual?</h2><p>You will learn everything you need to know about Textual from this book. You will also create TEN small applications to apply what you learn. Check it out today!</p>","contentLength":11013,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","python"]}