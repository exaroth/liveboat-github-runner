{"id":"EfcLDDAkyqguXw9Vbtcae7fRhxCsY1chPUNLpwbK9oHS42b4dGEMeGvA2hWHB2j3LFSAo7qhibLNgPBcA5djbGp95Jk5T","title":"top scoring links : programming","displayTitle":"Reddit - Programming","url":"https://www.reddit.com/r/programming/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/programming/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Hacking Super Mario 64 using Algebraic Topology","url":"https://happel.ai/posts/covering-spaces-geometries-visualized/","date":1772408396,"author":"/u/Lalelul","guid":564,"unread":true,"content":"<p>Covering spaces are a fundamental concept in topology. Some typical examples can be seen <a href=\"https://happel.ai/posts/l2-invariants/\">in this previous post</a>.</p><div><p> A  of a topological space  is a topological space  together with a continuous surjective map  such that for every point , there exists an open neighborhood  of  such that  for some discrete set  (called the fiber over ), and the map  restricted to each component of  is a homeomorphism onto .</p></div><div><div><div><div><p> A  between topological spaces  and  is a bijective map  such that both  and its inverse  are continuous. Explicitly:</p><ol type=\"1\"><li> is continuous (preimages of open sets are open),</li><li> is continuous (images of open sets are open, i.e.&nbsp; is an ).</li></ol><p>If such an  exists,  and  are called , written .</p><p>Homeomorphisms are precisely the <strong>isomorphisms in the category </strong> of topological spaces and continuous maps.</p><div><figure><figcaption>Example of a homeomorphism between a doughnut and a coffee cup</figcaption></figure></div></div></div></div></div><div><div><figure><figcaption>Typical example illustrating a covering space</figcaption></figure></div></div><div><p> A  of a topological space  is a covering space  of  that is simply connected, meaning that it has no nontrivial loops. The universal cover is unique up to homeomorphism and serves as a ‚Äúuniversal‚Äù object in the category of covering spaces of .</p></div><section><h2 data-anchor-id=\"the-universal-cover-of-a-doughnut\">The universal cover of a doughnut</h2><p>A filled torus (a doughnut) is a 3-manifold homeomorphic to , where  is the 2-dimensional disk. There exists a deformation retract from the doughnut to a circle, so the fundamental group of the doughnut is .</p><p>But what does any of that even mean? Let‚Äôs visualize the universal cover of the doughnut. Let us start with Bob, who lives in the following little world:</p><div><figure></figure></div><p>When Bob drives along the road past the stop sign, he will eventually return to the same point at which he started. However, he would reach invisible walls, it he intended to walk along the grass, or jump to the sky. The road is the only way to get around, and it loops back on itself.</p><p>Topologically, Bobs world is a doughnut, and the road is a loop around the hole of the doughnut. If we were to stretch it (don‚Äôt worry, this wont harm Bob, he does not even notice!), we would get the following picture:</p><div><figure></figure></div><p>These kinds of worlds typically occur in video games, and famously the ideas which I will elaborate on in this post were used in the Super Mario 64 community to ‚Äúhack‚Äù the game to achieve various speedrunning goals:</p><p>(This is where the famous ‚Äúbut first, we will need to talk about parallel universes‚Äù quote comes from. In the SM64 community, covering spaces are known as ‚Äúparallel universes‚Äù). Wheather intentional (like in Pacman) or unintentional (like in Super Mario 64, due to casting ing point numbers to s), it is often the case that walking in a straight line long enough will eventually lead you back to the same point.</p><p>In the case of SM64 however, only the collision detection code is affected by this floating point arithmetic, but not the rendering engine. So there actually are some differences between the ‚Äúparallel universes‚Äù in SM64. In particular, when Mario moves to a different parallel universe, the same collisions are still detected, although he is rendered as floating in an empty space. We can encode this also in Bobs world:</p><p>Lets assume, we would double, triple, quadruple, etc. Bobs world and stack these copies on top of each other. Bob would never notice, as long as each copy is just a ‚Äúshallow‚Äù copy, meaning that each movement in the  (the original world) is mirrored in the copies. In this case, we would have a covering space of Bobs world, and the original world would be the base space.</p><div data-layout-ncol=\"3\"><div><div><div><figure></figure></div></div><div><div><figure><figcaption>Bob‚Äôs world stacked twice</figcaption></figure></div></div><div><div><figure><figcaption>Bob‚Äôs world stacked three times</figcaption></figure></div></div></div></div><p>You could now imagine if we would do the same for SM64. Only there, we would not render any of the terrain, but only Mario himself for the copies.</p><p>If we were to keep stacking these copies, we would get the following picture:</p><div data-layout-ncol=\"2\"><div><div><div><figure><figcaption>Bob‚Äôs world stacked four times</figcaption></figure></div></div><div><div><figure><figcaption>Bob‚Äôs world stacked five times</figcaption></figure></div></div></div><div><div><div><figure><figcaption>Bob‚Äôs world stacked five times</figcaption></figure></div></div><div><div><figure><figcaption>Bob‚Äôs world stacked five times</figcaption></figure></div></div></div><div><div><div><figure><figcaption>Bob‚Äôs world stacked  times</figcaption></figure></div></div></div></div><p>The infinitely stacked world  is the  of Bobs world , as it is simply connected and covers Bobs world (see <a href=\"https://happel.ai/posts/covering-spaces-geometries-visualized/#def-universal-cover\">the definition of universal cover</a> above).</p><div><div><p>I sometimes changed the ground texture and was too lazy to rerender all the images, so please excuse this inconsistency in the images.</p></div></div><section><h3 data-anchor-id=\"further-elaboration-regarding-super-mario-64\">Further elaboration regarding Super Mario 64</h3><div><div><p>Because Super Mario 64 maps still use only IEEE‚Äë754 32bit ing point numbers for positions, they are only  covering space, not  covering space of the collision detection space, which uses s I will elaborate below.</p></div></div><table><tbody><tr><td></td></tr><tr><td>\n(Video by <a href=\"https://www.youtube.com/watch?v=wjge1bVobN0\">Bismuth</a>) The world of Super Mario 64 is more or less a 3-dimensional torus . Marios position is stored as a float, but cast down to a short for the collision detection, meaning that only values up between  and  are actually detected as different positions for the collision detection. Therefor marios position detection is calculated in , and his actual position is calculated in , here we still need to mod out, because of Nintendo 64 IEEE‚Äë754 floating point arithmetic.\n</td></tr></tbody></table><p>Casting from  to  gives rise to the retraction  and its section  which lifts  to , is exploted in SM64 speed running. In particular  is a covering space of  with fiber , which are all points, where Mario transitions from one ‚Äúparallel universe‚Äù to the next.</p><p>By carefully choosing Marios position  and velocity , the SM64 community was able to reach a desired positions  in  up to collision detection (for reaching some door, collecting a star, etc.). They did this by checking which  SM64 actually uses for calculations and then making the right choices, so that  for some  and for all other  is not a position that would trigger a collision detection with negative consequences (like resetting ).</p><div><figure><figcaption>Schematic of picking the correct  as shown in <a href=\"https://www.youtube.com/@Bismuth9\">Bismuth</a>s Video</figcaption></figure></div></section></section><section><h2 data-anchor-id=\"hyperbolic-geometry-from-the-universal-cover-widetildes1-vee-s1\">Hyperbolic geometry from the universal cover </h2><p>In the previous example we considered a space which has only one road looping back on itself. The number of times you would walk around the road to get back to the ‚Äúsame‚Äù point (or an equivalent point in a different copy) can be encoded using this ‚Äúwinding number‚Äù trick:</p><p>Assume Bob had a dog ‚ÄúSnoopy‚Äù on a leash and it walks along the road, while Bob was standing still. If the dog follows the road once and comes back to Bob, this results in the leash being wrapped around the hole in his space: In other words, Bob would need to walk around the hole once to untangle it.</p><p>In fact, we could encode in which copy of Bobs world Snoopy is, by counting how many times the leash is wrapped around the hole.</p><p>This ‚Äúwrapping a leash around the hole‚Äù action that Snoopy can perform is actually a <a href=\"https://en.wikipedia.org/wiki/Group_action\">group action</a> of  on the base space (Bobs space): For each integer , Snoopy can wrap the leash around the hole  times, and  corresponds to Snoopy walking around the hole  times clockwise and then  times counterclockwise.</p><div><div><div><div><p> Let  be a topological space and  a basepoint. A  based at  is a continuous map  with . Two loops  are <strong>homotopic relative to </strong> (written ) if there exists a continuous map  such that  for all . This is an equivalence relation; denote the equivalence class of  by .</p><p>The  of  at  is  equipped with the group operation of :  The identity element is the class of the constant loop , and the inverse of  is  where .</p><p>If  is path-connected, the isomorphism type of  is independent of the basepoint , and we write simply .</p></div></div></div></div><p>If we would think of the invisible walls in Bobs world as actual walls, say by a street lamp, we would get the following picture:</p><div data-layout-ncol=\"4\"><div><div><div><figure><figcaption>Snoopy being tangled  times around the hole/lamp</figcaption></figure></div></div><div><div><figure><figcaption>Snoopy being tangled  times around the hole/lamp</figcaption></figure></div></div><div><div><figure><figcaption>Snoopy being tangled  times around the hole/lamp</figcaption></figure></div></div><div><div><figure><figcaption>Snoopy being tangled  times around the hole/lamp</figcaption></figure></div></div></div></div><p>So we have that one line removed in Bobs space results in an infinite () amount of copies in the universal cover, but what is we would remove two lines?</p><div><figure><figcaption>A world with two lines removed. Now there are two ways (red and blue) for a leash to get tangled up and ‚Äúall their combinations‚Äù (there are two generators of the fundamental group of this space)</figcaption></figure></div><p>Let‚Äôs ‚Äúunfold‚Äù this world again, like we did with the torus and the world, where moving through the wall along the road ‚Äúteleported‚Äù Bob back to the other side. I will place a small house and some water into this barren world, so bob can have a nice place to live:</p><table><tbody><tr><td></td></tr><tr><td>\nUnfolding the space with two lines removed (Bobs home) to a double doughnut.\n</td></tr></tbody></table><div><div><p>This is  the space where Super Mario 64 takes place! SM64 would be the space  (a 3-dimensional torus). We would get this space by removing putting portals from the left to the right, from the top to the bottom and from the floor to the ceiling in a box, which was Bobs road-trip world from before!</p></div></div><p>In this double dougnut world, the fundamental group would be the free group on two generators:</p><div><figure><figcaption></figcaption></figure></div><p>And if we form the universal cover of this space, we get the following hyperbolic space (notice that I shrinked copies the the base space/‚Äúparallel universes‚Äù), because hyperbolic space does not fit into the Euclidean plane:</p><div data-layout-ncol=\"2\"><div><div><div><figure><figcaption>The universal cover of the double doughnut is a hyperbolic space</figcaption></figure></div></div><div><div><figure><figcaption>The universal cover of the double doughnut is a hyperbolic space, where we only shrink the xy plane, but not the height</figcaption></figure></div></div></div></div><div><div data-bs-toggle=\"collapse\" data-bs-target=\".callout-6-contents\" aria-controls=\"callout-6\" aria-expanded=\"false\" aria-label=\"Toggle callout\"><div>\nDefinition: Hyperbolic Space\n</div></div><div><div><p>The <strong>-dimensional hyperbolic space</strong> is the unique (up to isometry) simply connected, complete Riemannian manifold of constant sectional curvature .</p><p>Two standard models make this concrete:</p><p><strong>Poincar√© half-space model.</strong> Take the open upper half-space  equipped with the Riemannian metric whose components on the coordinate tangent vectors are  Geodesics are semicircles (or rays) orthogonal to the boundary hyperplane .</p><p> Take the open unit ball  with metric  This model is : angles between curves equal their Euclidean counterparts.</p><p>Each point  has tangent vectors  (which we write as the partial derivatives) at  given local coordinates (i.e.&nbsp;a basis ). The collection  forms a basis of .</p><p>A  on a smooth manifold  is a family of inner products  varying smoothly in , such that each  is symmetric and positive-definite. In local coordinates the metric is completely determined by its values on basis tangent vectors:  with the matrix  positive-definite at every point. The length of a tangent vector  is then .</p><p>For the Poincar√© half-space model in dimension 2, the metric evaluates on the coordinate tangent vectors  as  i.e.&nbsp;the coordinate tangent vectors are orthogonal and each has length  ‚Äî shrinking to zero as  approaches the boundary , which is what makes the space ‚Äúinfinitely large‚Äù near the boundary.</p><p>Often people write these metrics as , where each  is a  (1-form), i.e.&nbsp;an element of the dual space . For finite dimensional vectorspaces there is a canonical isomorphism between them and their dual: given the coordinate basis  of , there is a unique  of  defined by  This extends to isomorphisms . Under this identification, the bilinear form  on  is represented by the symmetric tensor  acting on pairs of tangent vectors via  which recovers exactly the inner products  from before. So both descriptions carry identical information;</p><p>For this reason, we may also write for the Poincar√© half-space model in dimension 2:</p><p>The key difference from Euclidean geometry is that a circle of radius  has circumference , and volumes grow  rather than polynomially: </p></div></div></div></section><section><h2 data-anchor-id=\"how-does-this-relate-to-glitchesexplots\">How does this relate to glitches/explots?</h2><p>I got asked this question by Bartfeels24 on Reddit (see below). This is my reply, if you are still wondering about the :</p><p>In SM64, positions are stored as tuples of three . However, a programmer at nintendo thought that casting to s for collision detection would be fine. (a completely valid idea tbh, after all Mario was never intended to move out of bounds).</p><p>Casting s to s however implicitly calculates a mod operation (in fact mod 65536 for each float in the tuple).</p><p>This little oversight can be exploited: Say mario wants to collect a star to finish a level. He needs to position himself somewhat close to the star, but only his position after modulo 65536 is used for collision detection. We can use another exploit to make Mario gain massive velocity and the physics engine will allow him to clip through walls with it. However, with great velocity comes the price of leaving the map (going out of bounds). Therefor, we use the module operation to still force a collision detection with the star.</p><p>This technique is more deeply rooted. Choosing wrong datatypes, or casting without care leaves you open to attacks. Whenever you cast some data structure to another one by ‚Äúremoving‚Äù information, such attacks can happen:</p><section><h3 data-anchor-id=\"real-life-example-hacking-your-bank-to-get-infinite-money\">Real life example: Hacking your bank to get infinite money</h3><p>Say, your bank would internally work with arbitrary floating point numbers for money, but they only charge you during transfers the rounded value up to a cent. If you transfer 0.009‚Ç¨ to another account, this account would get 0.009‚Ç¨, but you account would get charged 0.00‚Ç¨. Infinite money glitch irl.</p><p>But this really happens every time you perform some operations after ‚Äúcasting‚Äù (retracting) your data to a smaller data type for some processing</p></section></section><section><ol type=\"1\"><li> I drew  from this video ‚ÄúNot Knot‚Äù by the Geometry Center / Geometry Supercomputer Project in 1991, directed by Charlie Gunn and Delle Maxwell.</li><li> A video about different geometries on </li></ol></section>","contentLength":13156,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ricxxm/hacking_super_mario_64_using_algebraic_topology/"},{"title":"Fooling Go's X.509 Certificate Verification","url":"https://danielmangum.com/posts/fooling-go-x509-certificate-verification/","date":1772400985,"author":"/u/ketralnis","guid":565,"unread":true,"content":"<p>Below are two <a href=\"https://en.wikipedia.org/wiki/X.509\">X.509</a> certificates. The\nfirst is the Certificate Authority (CA) root certificate, and the second is a\nleaf certifcate signed by the private key of the CA.</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>If you downloaded these certificates, you could visually see that the latter\nreferences the former as its Issuer. If you were to use a tool like  to\nverify that the leaf is signed by the private key of root, you would see that it\nis.</p><blockquote><p>Unless of course you are reading this blog post from the year 2126 or you\nhave changed the system time on your machine. If the former, I am exceedingly\ndissapointed that humanity is still using .</p></blockquote><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>Now, if you wanted to write a Go program that verified this chain of trust, it\nmight look something like the following.</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>But if you ran that program, you might be surprised to see the following.</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>If you used this CA certificate instead, you would see the expected output.</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>At first glance these certificates appear to be identical. You could use\n to view the contents of both certificates, and you would get identical\noutput.</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>However, if you were to compare the bytes of the certificates, you would see\nthat there is a very slight difference; two bytes to be exact.</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>The ASN.1 specification defines a set of data types, each with an associated tag\n(non-negative integer identifier), which precedes the length and the value when\nusing DER encoding (see <a href=\"https://letsencrypt.org/docs/a-warm-welcome-to-asn1-and-der/\">this\npost</a> from <a href=\"https://letsencrypt.org\">Let‚Äôs\nEncrypt</a> for more information).  can once\nagain be used to see the data types of different fields in the certificate that\nis successfully verified.</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>In the diff view of the two CA certificates, the bytes that differed preceded\nthe  string in two different places: the Subject and the Issuer, which\nare the same since this is a self-signed certificate. They were also followed by\na  byte, which aligns with the number of characters in  (i.e. the\nlength of the value). The differing leading byte suggests differing ASN.1 data\ntypes for these fields. The CA certificate for which validation is successful\nuses  (), and you can use  with the failing CA\ncertificate to see that it uses  instead ().</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>This still doesn‚Äôt explain why  verifies successfully with either CA\ncertificate, while the Go program does not. To dig further, you can compile and\nstep through the program with , starting with a breakpoint on .</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>Stepping through <a href=\"https://github.com/golang/go/blob/de0d77c6f8c3977d90b5541a34bca9da32494e38/src/crypto/x509/verify.go#L538\">the\nfunction</a>,\nyou eventually arrive at the point where you are building the candidate\ncertificate chains.</p><blockquote><p>Add a breakpoint for this function using <code>b crypto/x509.(*Certificate).buildChains</code>.</p></blockquote><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>As part of evaluating whether the certificate pool provided has a candidate\nchain, <a href=\"https://github.com/golang/go/blob/de0d77c6f8c3977d90b5541a34bca9da32494e38/src/crypto/x509/cert_pool.go#L132\"> is\ncalled</a>\non the  (it is also called on the , but there are no\nintermediate certificates provided in this example).</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Finally, you arrive at the <a href=\"https://github.com/golang/go/blob/de0d77c6f8c3977d90b5541a34bca9da32494e38/src/crypto/x509/cert_pool.go#L144\">source of the\nfailure</a>.\nA potential parent for the leaf certificate should have a Subject that matches\nthe Issuer of the leaf (i.e. the leaf should refer to it as the certificate that\nwas used for signing).</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>The keys in the <a href=\"https://github.com/golang/go/blob/de0d77c6f8c3977d90b5541a34bca9da32494e38/src/crypto/x509/cert_pool.go#L18\"> map of a\n</a>\ncontain the Subject of the CA certificates. When using the CA certificate that\ncaused verification failure, stepping through the loop above you can see that\nthere are zero iterations, or, that there are no CA certificates with a Subject\nthat matches the leaf Issuer. How could that be? The key observation is that the\nraw Subject and Issuer, the literal bytes, are being used for comparison.</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>We saw earlier that the two CA certificates differed in the ASN.1 data types\nused for their Subject. Expectedly, if you check the data type of the Issuer in\nthe leaf certificate, you‚Äôll see that it is a , matching the CA\ncertificate that was verified successfully.</p><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"fallback\"></code></pre></div><p>Whether this is the correct behavior has been an <a href=\"https://github.com/golang/go/issues/31440\">ongoing\ndebate</a> in the Go project, and the\nmatter is complicated by some tools, such as  as seen in this post,\ntreating different ASN.1 data types for strings as equivalent when verifying\ncertificates. Typically you‚Äôll be using the same tooling or services for\ngenerating CA certificates and the leaf certificates they sign, so the encoding\nwill likely be consistent. However, given that leaf certificates are typically\nmuch shorter lived than CA certificates, your tooling may evolve over time,\npotentially causing discrepancies in newly generated leaves.</p><p>Though Go‚Äôs handling of this scenario results in\n<a href=\"https://authzed.com/blog/fail-open\">fail-closed</a> behavior, it can still cause\noutages and downtime, making it important to be aware of how you are generating\ncertificates and how they are expected to be verified.</p>","contentLength":4417,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ri9vt8/fooling_gos_x509_certificate_verification/"},{"title":"Why is the first C++ (m)allocation always 72 KB?","url":"https://joelsiks.com/posts/cpp-emergency-pool-72kb-allocation/","date":1772400950,"author":"/u/ketralnis","guid":567,"unread":true,"content":"<p>: I updated the title to to clarify that this observation is specific to my environment. The original title may have implied a universal behavior, which isn‚Äôt the case. Thanks for the feedback!</p><p>; The C++ standard library sets up exception handling infrastructure early on, allocating memory for an ‚Äúemergency pool‚Äù to be able to allocate memory for exceptions in case malloc ever runs out of memory.</p><p>I like to spend (some of) my time hacking and experimenting on custom memory allocators with my own malloc implementation(s). While unit tests are useful for correctness, the ultimate test is seeing how the allocator behaves in real-world programs. On Linux, overriding the default malloc is surprisingly simple: wrap the standard allocation functions (e.g., malloc, calloc, realloc, free, and utilities like malloc_usable_size), compile your implementation into a shared library, and use  to force programs to load it first. For example, you can test your allocator with a simple command like this:</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>To better understand how programs allocate memory, I built a debug tool that logs the size of every allocation request to a file. You have to be careful when creating debug tools like this when implementing malloc to not internally use malloc to log output. Otherwise, you risk an infinite loop and a crash. To solve this I‚Äôm using a stack-allocated buffer together with low-level functions like creat, write and snprintf to safely capture the data.</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>While analyzing allocation patterns across different programs, I noticed something unusual: the very first allocation is always 73728 bytes (72 KB). Every program I tested exhibited this behavior, as confirmed by my debug logs:</p><p>To track down the first call to malloc, I use gdb to set a breakpoint into my own malloc function to inspect the backtrace.</p><p>: Setting a breakpoint on the ‚Äúmalloc‚Äù symbol will not only trigger for our own malloc, but also the dynamic linker‚Äôs (RTLD) internal malloc, so we have to be more specific. RTLD uses its own minimal malloc implementation for early memory allocation, before libc (or our own malloc) is loaded. I encourage you to take a look at glibc‚Äôs <a href=\"https://elixir.bootlin.com/glibc/glibc-2.43.9000/source/elf/dl-minimal-malloc.c\">elf/dl-minimal-malloc.c</a>, it is remarkably approachable.</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>The backtrace revealed that the first 72 KB allocation originated from libstdc++. While adding debug symbols helps narrow it down a bit, it‚Äôs hard to pinpoint the exact function responsible for the malloc call due to inlining. All we know is that the malloc call comes from something down the line from <code>__pool_alloc_base::_M_allocate_chunk</code>.</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>Identifying the exact caller took some time, but I narrowed it down by cross-referencing known functions in the assembly code with the libstdc++ source code. The investigation led me to <a href=\"https://github.com/gcc-mirror/gcc/blob/8758503918a91dacff4dbc7126eced21787fbfc9/libstdc%2B%2B-v3/libsupc%2B%2B/eh_alloc.cc#L235\">libstdc++-v3/libsupc++/eh_alloc.cc</a>, where ‚Äúeh‚Äù stands for ‚Äúexception handling‚Äù. This made sense because  is likely the first point where an exception could be thrown, so the exception-handling infrastructure must be initialized, which is presumably done lazily.</p><div><pre tabindex=\"0\"><code data-lang=\"c++\"></code></pre></div><h2>Exception Handling Infrastructure (Emergency Pool)</h2><p>The 72 KB call to malloc we‚Äôre seeing is memory for the so called ‚Äúemergency pool‚Äù, which is allocated in the constructor of the pool:</p><div><pre tabindex=\"0\"><code data-lang=\"c++\"></code></pre></div><p>Normally, exceptions are allocated directly via malloc, but if the malloc call fails, the exception is allocated from the emergency pool instead. This ensures that exceptions can still be thrown (to the extent of the size of the emergency pool) even when malloc fails, providing a last line of defense for error handling. The emergency pool is allocated lazily at program startup, since memory is more likely to be available then, which explains why we see this allocation so consistently.</p><div><pre tabindex=\"0\"><code data-lang=\"c++\"></code></pre></div><h2>Emergency Pool Sizing. Why 72 KB?</h2><p>Looking in the source file there is a brief explanation of how the size of the emergency pool is calculated. Both the object size and the number of objects are based on the wordsize, so 8 bytes on a 64-bit system.</p><div><pre tabindex=\"0\"><code data-lang=\"c++\"></code></pre></div><p>The object size (obj_size) and number of objects (obj_count) can be tuned manually via the  environment variable. We can empirically verify that the initial allocation is actually for the emergency pool by changing the number of objects in the pool. As expected, we see the initial allocation size go down when we change the number of objects:</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>As a side note, the emergency pool can also be disabled (i.e., not allocated), by setting the number of objects to 0. Alternatively, you can opt-in to use a fixed-size static buffer for the emergency pool by configuring <code>--enable-libstdcxx-static-eh-pool</code> when building libstdc++.</p><div><pre tabindex=\"0\"><code data-lang=\"txt\"></code></pre></div><p>However, in older Valgrind versions, this memory appeared as ‚Äústill reachable‚Äù rather than properly freed. While ‚Äústill reachable‚Äù memory isn‚Äôt technically a leak (the program still has references to it), it can be misleading. See post on <a href=\"https://stackoverflow.com/questions/45537965/how-does-a-c-library-implementation-allocate-memory-but-not-free-it-when-the-p\">Stack Overflow</a> detailing this behavior. Interestingly, this person sees a 71 KB allocation instead of 72 KB.</p><div><pre tabindex=\"0\"><code data-lang=\"txt\"></code></pre></div><p>Many developers mistakenly interpret this behavior as a memory leak, leading to unnecessary confusion. To address this, newer Valgrind versions now explicitly free the emergency pool during cleanup, providing clearer reports. This is implemented through the mechanisms shown below, which were added specifically for tools like Valgrind:</p><div><pre tabindex=\"0\"><code data-lang=\"c++\"></code></pre></div><div><pre tabindex=\"0\"><code data-lang=\"c++\"></code></pre></div><p>The memory allocated for the emergency pool explains why I‚Äôve been able to consistently observe a 72 KB allocation when testing my custom allocator. Since I‚Äôve implemented my custom allocator in C++, it inherently depends on libstdc++, which initializes the emergency pool on every program invocation. Interestingly, if I had written my allocator in C instead, which several popular malloc implementations are implemented in (<a href=\"https://github.com/microsoft/mimalloc\">mimalloc</a>, <a href=\"https://github.com/jemalloc/jemalloc\">jemalloc</a>), I would only see this initial allocation when testing C++ binaries, which explicitly link against libstdc++.</p><p>You might see a different allocation size (e.g., 71 KB instead of 72 KB), or no allocation at all. Factors like different versions of libstdc++, using libc++ instead, or even compiler flags can introduce variations. Still, in most cases, you‚Äôll likely see memory for the emergency pool allocated early, perhaps with different sizes or behaviors depending on the environment.</p><p>As you quickly find out when working with memory allocation is that almost everything needs to allocate memory. From time immemorial with RTLD needing its own malloc since it hasn‚Äôt loaded libc yet, or for the emergency pool, which only uses malloc to allocate memory for its own pool allocator!</p><p>Digging through the code and piecing this together was rewarding and fun. I hope you enjoyed the journey as much as I did!</p>","contentLength":6593,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ri9v90/why_is_the_first_c_mallocation_always_72_kb/"},{"title":"Decision trees ‚Äì the unreasonable power of nested decision rules","url":"https://mlu-explain.github.io/decision-tree/","date":1772400809,"author":"/u/ketralnis","guid":566,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ri9t3w/decision_trees_the_unreasonable_power_of_nested/"},{"title":"AWS Middle East Central (mec1-az2) down, apparently struck in war","url":"https://health.aws.amazon.com/health/status","date":1772395647,"author":"/u/iamapizza","guid":569,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ri7jpj/aws_middle_east_central_mec1az2_down_apparently/"},{"title":"The looming AI clownpocalypse","url":"https://honnibal.dev/blog/clownpocalypse","date":1772375935,"author":"/u/syllogism_","guid":568,"unread":true,"content":"<p>Over the last few years there‚Äôs been a big debate raging with keywords like ‚Äúthe singularity‚Äù,\n‚Äúsuperintelligence‚Äù, and ‚Äúdoomers‚Äù. I propose a sort of truce on that debate. The terms of\nthe truce are that everyone still gets to sneer at their erstwile opponents and their cringe\nidiot takes, but we also all agree that the question hasn‚Äôt been\n‚ÄúBut what if the dumbest possible version of everything happens? What then?‚Äù, because wtf,\nwhy would it?</p><p>Well. Times have changed.</p><p>The way current and imminent AI technologies are being deployed introduces very\ntangible risks. These risks don‚Äôt require superintelligence, and they‚Äôre\nnot ‚Äúexistential‚Äù. They‚Äôre plenty bad though. So the truce I‚Äôm proposing is that we all get to care\nabout these risks, without the ‚Äúdenialists‚Äù rushing to say ‚Äúsee it‚Äôs not existential!‚Äù or\nthe ‚Äúdoomers‚Äù getting to say ‚Äúsee I told you shit could get bad‚Äù.</p><p>I promise this is a serious post, even though the situation is so stupid my tone will often\ncrack. The basic thesis statement is that a self-replicating thing doesn‚Äôt have to be very smart\nto cause major problems. Generally we can plan ahead though, and contain the damage. Well, we \ndo that. In theory. Or we could spice things up a bit. Maybe run some bat-licking ecotours instead.\nWhy not?</p><p>Here‚Äôs a rough sketch of a bad scenario. Imagine you have some autonomous way to convert resources\ninto exploits ‚Äî hacks, basically. Maybe you have some prompts that try to trick Claude Code or Codex\ninto doing it, maybe you use open-source models. However works. Now, these exploits are going to pay out\nin various ways when you can land them. Lowest yield is just some compute, but maybe you can also steal\nsome dollars or crypto, or steal some data to sell, or even ransomware. The question is, what happens\nwhen we reach the tipping point where exploits become cheaper to autonomously develop than they yield on\naverage?</p><p>The general scenario is something I‚Äôve always thought was worth worrying about. But you know, maybe\nit could be okay, at least for a while ‚Äî after all, the stuff that‚Äôs making the exploits cheaper to\ndevelop should let us make everything more secure too, right? ‚Ä¶Right? Lol no, this is the clownpocalypse,\nwhere the bats taste great. We use coding agents to make everything way  secure.</p><p>The general mindset in the industry at the moment is that everything‚Äôs a frantic race, and if you‚Äôre worrying\nyou‚Äôre losing. The sheer pace of change in software systems would be a concern in itself, but there are so many\nother problems I almost don‚Äôt know where to start.</p><p>I guess I‚Äôll start with an example that would be easy to fix, but captures the zeitgeist pretty well. Coding agents\nlike Claude Code and Codex can read in ‚Äúskills‚Äù files, which are basically just Markdown files that get appended\nto the prompt (you can have code as well, but that‚Äôs not important here). Kind of nice. So everyone rushes to\npublish skills, you get sites to find and install skills like <a target=\"_blank\" href=\"https://skills.sh/\">Skills.sh</a>. Except, nobody\nbothered to even think far enough ahead to prohibit HTML comments in the Markdown. This means any skill you browse\non a website like Skills.sh could have hidden text that isn‚Äôt rendered to you, but can direct your agent to get\nup to various mischief. Remember that agents often have extremely broad permissions. During development loops\npeople often give the agent access to basically everything the developer has. People leave agents running\nunsupervised. This problem has been known for weeks. There was even a <a target=\"_blank\" href=\"https://x.com/theonejvo/status/2015892980851474595\">high-profile demonstration</a>\nof the vulnerability: Jamieson O‚ÄôReilly published a skill called ‚ÄúWhat Would Elon Do‚Äù (chef‚Äôs kiss), manipulated it\nto the top of a popular marketplace, and notified victims they‚Äôd been owned. The fix is trivial: obviously\nthe skills format should prohibit HTML comments, but to date there‚Äôs been zero move to actually do that.\nIt‚Äôs nobody‚Äôs problem and nobody seems to care.</p><p>O‚ÄôReilly demonstrated the unrendered text vulnerability in the <a target=\"_blank\" href=\"https://github.com/openclaw/openclaw\">OpenClaw</a> ecosystem, which is for sure\none of the four balloon animals of the AI clownpocalypse. I don‚Äôt know what the other three would be, but OpenClaw\nis a lock for one of them. So many stories of people just giving the agent all their keys and letting it drive,\nonly for it to immediately drive into a wall by deleting files, distributing sensitive information, racking\nup usage bills, deleting emails‚Ä¶And all of these things can honestly be considered expected usage, it isn‚Äôt\na ‚Äúbug‚Äù when a classifier makes an incorrect prediction, it‚Äôs part of the game. What  a bug are the <a target=\"_blank\" href=\"https://blogs.cisco.com/ai/personal-ai-agents-like-openclaw-are-a-security-nightmare\">thousands\nof misconfigured instances open to the internet</a>,\nalong with the hundreds of other security vulnerabilities. Mostly nobody cared though. It was still the fastest\ngrowing project in GitHub history, before being\n<a target=\"_blank\" href=\"https://www.cnbc.com/2026/02/15/openclaw-creator-peter-steinberger-joining-openai-altman-says.html\">acquihired into OpenAI</a>.</p><p>How did we get here? I dunno man, I really don‚Äôt. <a target=\"_blank\" href=\"https://en.wikipedia.org/wiki/Normalization_of_deviance\">Normalization of deviance</a> I guess? The literal phrase seems to capture\nthe current political meta, and there‚Äôs an air of resigned watch-the-world-burn apathy to everything. It doesn‚Äôt help\nthat insecurity is baked into LLMs pretty fundamentally. When ChatGPT was first released I thought prompt injection\nwould be this sort of quaint oversight, like oh they forgot to concatenate in a copy of the prompt vector high up\nin the network, so the model can tell which bit is the prompt alone and which bit is the prompt-plus-context. But\nnah nobody ever did that. I guess it didn‚Äôt work? Nobody talks about it, so as far as I can tell nobody‚Äôs even trying.\nSo we‚Äôve all just accepted that maybe one day our coding agent will read an html page that tricks it into deleting our home\ndirectory. Oopsie. Well I can run my agent sandboxed, so at least my files will be safe. But what if it tricks my agent\ninto including a comment in the source of my docs page that will trick a lot of  agents into including a comment that‚Ä¶\netc. Well, fortunately that hasn‚Äôt happened yet, and we all know that‚Äôs the main thing that counts when assessing\nthe severity of a potential vulnerability, right?</p><p>You see the go-fast-but-also-meh-whatever vibe everywhere if you look for it. Google‚Äôs LLM product, Gemini, insisted on shipping\nwith this one-click API key workflow, presumably because the product owners hated the idea of making users sign up through Google Cloud,\nwhich is a longer process than you need for something like OpenAI. Except, this introduced this whole separate auth flow,\nwhich has been recently upgraded from clusterfuck to catastrafuck. Previously I thought that the situation was just confusing:\nthe web pages for the two rival workflows don‚Äôt mention each other, there‚Äôs no vocabulary to describe the difference, and\nthere‚Äôs some features that only work if you auth one way but not the other. Clusterfuck.\nBut, recently we learned that <a target=\"_blank\" href=\"https://trufflesecurity.com/blog/google-api-keys-werent-secrets-but-then-gemini-changed-the-rules\">the Gemini API keys break a design assumption behind Google‚Äôs existing security posture</a>: keys aren‚Äôt\nsupposed to be secrets; you‚Äôre supposed to be able to embed them in client code, if you‚Äôre doing something like distributing a free\napp that has to access Google Maps. But now many of those existing keys are  auth keys for Gemini! So thousands of people had\nkeys lying around that could be used to steal money from them by using Gemini (e.g. to develop malware), having done absolutely nothing\nwrong themselves. Well, fortunately the vulnerability was found by professionals, and reported through the proper channels, so no\nharm done, right? Well, almost. The researchers did contact Google correctly, but then Google first denied the problem, and only\naccepted it when the researchers showed  were affected. So then the 90 day disclosure window started, and Google\nshuffled their feet a bit, rolled out a patchwork fix, and ultimately blew the deadline. So the report went live without a full fix\nin place. Catastrafuck.</p><p>So far even when they‚Äôve been bad, malware attacks haven‚Äôt been  bad. So okay, even if this does go wrong‚Ä¶how bad could the\nAI clownpocalypse be? This is where I ask for just a little imagination, along with some acceptance that today‚Äôs AI models are not entirely\nincompetent, and they‚Äôre getting more capable every day. Many current AI models are no longer really ‚Äúlanguage models‚Äù, in that the\nobjective they‚Äôve mostly been trained to do is predict successful reasoning paths, rather than predict likely text continuations.\nI wrote about this in a <a href=\"https://honnibal.dev/blog/ai-bubble\">previous post</a>. If there‚Äôs a malware going around suborning existing agents or co-opting hardware\nby installing its own agent onto it, it‚Äôs probably going to be using one of these reasoning-trained models. They‚Äôre much better for\ncoding, and the malware probably wants to execute multi-step plans. It wants to send phishing emails, do some social engineering,\nhunt around for crypto or bank details, maybe send some ‚Äúhelp stranded please send money‚Äù scam messages ‚Äî you get the picture.\nWell, those plans will involve reading a lot of text in, and the malware probably isn‚Äôt going to use a high capability model. At\nany point the model‚Äôs view of its current goal can drift. Instead of telling your grandmother to send money, it could tell her to\ndrink drain cleaner. Or it could message her ‚ÄúRawr XD *tackles you*‚Äú. I don‚Äôt want to make out like there‚Äôs this inner kill-bot,\nwaiting to be unleashed. It‚Äôs just that it could be anything.\nThere‚Äôs truly no way of knowing. Anthropic call it the <a target=\"_blank\" href=\"https://alignment.anthropic.com/2026/hot-mess-of-ai/\">‚Äúhot mess‚Äù</a> safety\nproblem, which I think is apt. In the clownpocalypse scenario you have millions of these hot messes.</p><p>How bad could that be? Hard to say! We‚Äôve seen ransomware attacks against hospitals already, so pencil that in as a possibility. Somewhere\na bot sends a message, ‚ÄúI‚Äôve infilitrated the hospital. Pay me or I‚Äôll change around all the data so people get the wrong medications and\ndie‚Äù. Is it bluffing? Probably, but what if it‚Äôs not? It‚Äôs not like you can even pay it ‚Äî it can just send the same message again. Some\nof these won‚Äôt be bluffs, and it could be anything. What happens if you hack a dam? The power grid? We got a lot of guys in their 80s with\nwealth and power around the world, what could they be tricked into doing if the wrong bot is able to slide into their DMs? Can the Russian\nmilitary be compromised? A lot of their frontline stuff is running off\n<a target=\"_blank\" href=\"https://militarnyi.com/en/news/investigation-80-of-russian-troops-linkups-on-the-front-line-produced-by-u-s-company-ubiquiti/\">consumer hardware</a>.\nAre there any Ukrainian drones that could be hacked and sent to bomb Berlin?\nSomewhere in Pakistan is there some dusty PC running Windows 98 hooked up to exactly the wrong network? The only thing we can be\nconfident about is that whatever the worst situation is, it‚Äôs extremely unlikely anyone will predict exactly that thing.</p><p>A lot of the AI safety debate has been like, ‚ÄúIs it possible to design a door so secure it wouldn‚Äôt be practical for anyone to pick it before\nsecurity guards arrive?‚Äù. I think that debate‚Äôs important, but like, look around. Door? What door? Oh, you mean those things\nwe used to have in entrance ways? Yeah nah those were bad for user experience. We‚Äôre all about on-ramps now.</p><p>If you think superintelligence is an urgent existential risk, I‚Äôm not asking you to stop caring about that or stop making the case. And if you think\nsuperintelligence is robot rapture nonsense, I‚Äôm not asking you to admit the folks you‚Äôve been calling libertarian edgelords were right about anything.\nBut we need to pause and take stock. It‚Äôs not going to take a superintelligence to wreck our shit. The coding agents are getting better and better, and\nwhat we‚Äôre doing with the technology is working really hard to make ourselves more and more exposed. We‚Äôre shipping the vulnerabilities super fast now though üí™.\nGo team I guess?</p><p>So what can be done? I mean, lots! I wouldn‚Äôt call it a clownpocalypse if it were some desperate dilemma. If we can just recognise the danger and honk the horn,\nwe could be rolling out meaningful fixes tomorrow. If you‚Äôre an AI consumer, start taking security posture much much more seriously. A lot of people are\nskating by on the idea that meh, I‚Äôm not really worth targeting specifically ‚Äî but that‚Äôs not going to be how it works. As soon as we reach that tipping\npoint where autonomous attacks have a positive return, it‚Äôs going to be a full-court press. We‚Äôre also going to face huge pressure on non-computational\ninterfaces ‚Äî all those processes that involve picking up a phone or manually emailing someone. Some of those problems will be really difficult, so the\nleast we can do is get ready and make sure we‚Äôre not making them worse. For the major AI providers, please please take much more prosaic safety and security\nissues more seriously. By all means, continue paying for papers about the hard problem of consciousness ‚Äî it‚Äôs not like philosopers are expensive, on the\nscale of things. But you  to be willing to introduce some product friction for security. It‚Äôs essential. If you don‚Äôt this is all going to blow up\nreally badly.</p><p>The following list was generated with AI assistance. I‚Äôve visited the links but haven‚Äôt read them all fully.</p>","contentLength":13178,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1rhyv48/the_looming_ai_clownpocalypse/"}],"tags":["dev","reddit"]}