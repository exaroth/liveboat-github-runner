{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Built a Git assistant CLI in Go","url":"https://www.reddit.com/r/golang/comments/1p8py8j/built_a_git_assistant_cli_in_go/","date":1764319255,"author":"/u/llyas__","guid":492,"unread":true,"content":"<p>I've been working on a lightweight Git assistant CLI in Go, inspired by tools like GitHub Copilot but focused on simplifying everyday Git tasks. It’s called , and it supports commands like showing the current branch, commit info, repo status, and even generating AI‑powered commit messages using OpenRouter.</p>","contentLength":311,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"When do Go processes return idle memory back to the OS?","url":"https://www.reddit.com/r/golang/comments/1p8ovc7/when_do_go_processes_return_idle_memory_back_to/","date":1764315040,"author":"/u/DeparturePrudent3790","guid":490,"unread":true,"content":"<p>My understanding is after a GC the spans which have no reachable objects are marked as idle and remain with the go process for future allocations. This is leading to overall memory usage of the process to be high by 50% that wants needed. </p><p>I want to understand by default when does the go process return the idle memory to the OS? </p>","contentLength":330,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go Pooling Strategies: sync.Pool vs Generics vs ResettablePool — Benchmarks and Takeaways","url":"https://www.reddit.com/r/golang/comments/1p8n0y2/go_pooling_strategies_syncpool_vs_generics_vs/","date":1764308434,"author":"/u/LearnedByError","guid":489,"unread":true,"content":"<p>I have been working on a web photo gallery personal project and playing with various A.I. as programming assistants. I have recently completed all of the features for my first release with most of the code constructed in conjunction with Gemini CLI and a portion from Claude Sonnet 4.5.</p><p>The vast majority of the code uses stdlib with a few 3rd party packages for SQLite database access and http sessions. The code can generally be broken into two categories: Web Interface and Server (HTMX/Hyperscript using TailwindCSS and DaisyUI served by net/http) and Image Ingestion. The dev process was traditional. Get working code first. If performance is a problem, profile and adjust.</p><p>The web performance tricks were primarily on the front-end.  and  worked admirably well with bog standard code.</p><p>The Image Ingestion code is where most of the performance improvement time was spent. It contains a worker pool curated to work as well as possible over different hardware (small to large), a custom  connection pool to over come some performance limitation of the stdlib pool, and heavily leverages sync.Pool to minimize allocation overhead.</p><p>I asked Copilot in VSCode to perform a Code Review. I was a bit surprised with its result. It was quite good. Many of the issues that it identified, like insufficient negative testing, I expected.</p><p>I did not expect it to recommend replacing my use of sync.Pool with generic versions for type safety and possible performance improvement. My naive pre-disposition has been to \"not\" use generics where performance is a concern. Nonetheless, this raised my curiosity. I asked Copilot to write benchmarks to compare the implementations.</p><p>The benchmark implementations are:</p><ul><li>Interface-based  using pointer indirection (e.g., , , ).</li><li>Generics-based pools: <ul><li> storing values (e.g.,  by value).</li><li> storing pointers (e.g., , ).</li></ul></li><li>A minimal  abstraction (calls  automatically on ) versus generic pointer pools, for types that can cheaply reset.</li></ul><p>Link to benchmarks below.</p><table><thead><tr></tr></thead><tbody><tr><td align=\"left\">Interface pointer ()</td></tr><tr><td align=\"left\">Generic value slice ()</td></tr><tr><td align=\"left\">Interface pointer ()</td></tr><tr><td align=\"left\">Generic value slice ()</td></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr></tr><tr><td align=\"left\">galleryImage (RGBA 1920x1080)</td></tr><tr><td align=\"left\">galleryImage (RGBA 1920x1080)</td></tr><tr><td align=\"left\">galleryImage (RGBA 1920x1080)</td></tr><tr><td align=\"left\">galleryImage (RGBA 1920x1080)</td></tr></tbody></table><p>These benchmarks were run on my dev server: <code>Intel(R) Xeon(R) CPU E5-2680 v3 @ 2.50GHz</code> (Linux, Go on amd64).</p><ul><li>For slices, a generic value pool () incurs allocations (value copy semantics). Prefer interface pointer pools () or a generic pointer pool to avoid allocations.</li><li>For pointer types (, ), both interface and generic pointer pools are allocation-free and perform similarly.</li><li>For  (Resettable), both approaches are zero-alloc; minor speed differences were observed - not significant</li><li>For large/complex objects ( which is image.Image wrapped in a struck), a generic pointer pool was ~2× faster than  in these tests, likely due to reduced interface overhead and reset work pattern.</li></ul><pre><code>go test -bench . -benchmem -run '^$' </code></pre><pre><code>go test -bench 'BufPool' -benchmem -run '^$' go test -bench 'BufferPool' -benchmem -run '^$' go test -bench 'Null(String|Int64)Pool_(GetPut|Parallel)$' -benchmem -run '^$' go test -bench 'MD5_(GetPut|Parallel)$' -benchmem -run '^$' go test -bench 'GalleryImage_(GetPut|Parallel)$' -benchmem -run '^$' </code></pre><p>Pools are powerful. Details matter! Use pointer pools. Avoid value slice pools. Expect parity across strategies (interface/generic) for pointer to small types. Generic may be faster is the type is large. And as always, benchmark your actual workloads. Relative performance can shift with different reset logic and usage patterns.</p><p>I hope you find this informative. I did.</p>","contentLength":3554,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"WebScraping in golang","url":"https://www.reddit.com/r/golang/comments/1p8dg89/webscraping_in_golang/","date":1764278649,"author":"/u/North_Fall_8333","guid":491,"unread":true,"content":"<div><p>Is webscraping in go a good idea? I'm used to using playwright and selenium for webscraping in java/kotlin but i've been focusing on learning golang recently is this a good idea and if yes than what should I use for it?</p></div>   submitted by   <a href=\"https://www.reddit.com/user/North_Fall_8333\"> /u/North_Fall_8333 </a>","contentLength":257,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"3rd party package for doing symmetric AES encryption?","url":"https://www.reddit.com/r/golang/comments/1p8ahvb/3rd_party_package_for_doing_symmetric_aes/","date":1764270824,"author":"/u/trymeouteh","guid":488,"unread":true,"content":"<p>Is there a simple to use, popular and well trusted package that makes AES CBC and AES GCM encryption and decryption simple without having to work with cipher blocks?</p><p>I am fine with having to generate a salt, iv, key on my own. Would like something more basic for encrypting and decryption.</p>","contentLength":288,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"NornicDB - drop-in replacement for neo4j - MIT - GPU accelerated vector embeddings - golang native - 2-10x faster","url":"https://www.reddit.com/r/golang/comments/1p87hko/nornicdb_dropin_replacement_for_neo4j_mit_gpu/","date":1764263385,"author":"/u/Dense_Gate_5193","guid":493,"unread":true,"content":"<p>timothyswt/nornicdb-amd64-cuda:latest</p><p>timothyswt/nornicdb-arm64-metal:latest</p><p>i just pushed up a Cuda/metal enabled image that will auto detect if you have a GPU mounted to the container, or locally when you build it from the repo </p><p>i have been running neo4j’s benchmarks for fastrp and northwind. Id like to see what other people can do with it </p><p>i’m gonna push up an apple metal image soon. (edit: done! see above) the overall performance from enabling metal on my M3 Max was 43% across the board. </p><p>initial estimates have me sitting anywhere from 2-10x faster performance than neo4j</p><p>edit: adding metal image tag </p><p>edit2: just realize metal isn’t accessible in docker but if you build and run the binary locally it has metal active </p>","contentLength":728,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","go"]}