{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Mitchell Hashimoto Recent Interview","url":"https://www.reddit.com/r/golang/comments/1i56aih/mitchell_hashimoto_recent_interview/","date":1737313955,"author":"/u/roma-glushko","guid":366,"unread":true,"content":"<p>(around 30:00 where they start touching the golang topic)</p><p>This is really interesting how Mitchell's option has changed on Golang. He spent a lot of time (like 10y or so) writing infrastructure services in Golang as a part of his HashiCorp business and probably not only.</p><p>His recent gig is a new terminal and he did not pick Golang for that one, which kinda make sense to me given what he wants to achieve there (eg a lot of low-level work with GPU, a need to be imported by other languages like Swift, etc.).</p><p>At the same time, Mitchell said that:</p><ul><li>He doesn't know where Golang stands in the tech stack right now. He would use PHP/Ruby for webdev and Rust/Zig for performance critical systems.</li><li>Generics made Golang worse (at least that how I understood him)</li><li>He think he cannot write Golang any longer after hacking with the new lang he is writing the terminal in</li></ul><p>Curious how this transformation could happen to such a prominent contributor to the Golang ecosystem. Is this just an sign of an awful burnout that repelled the dude away from Golang? Or anything else?</p><p>Anyway, just curious what do you think here, folks.</p>","contentLength":1106,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"What version of Go did this feature come in?","url":"https://www.reddit.com/r/golang/comments/1i54h8p/what_version_of_go_did_this_feature_come_in/","date":1737309525,"author":"/u/lickety-split1800","guid":363,"unread":true,"content":"<div><p>It had been a while since I had coded in Go, and I noticed that interface{} or any can be used in comparisons without type assertions. I thought I had made a typo, then did a double take as it worked without an error.</p><pre><code>package main import ( \"fmt\" ) func main() { var data any data = true whatType(data) // prints \"bool true\" data = \"true\" whatType(data) // prints \"string true\" } func whatType(data any) { if data == true { fmt.Println(\"bool true\") } if data == \"true\" { fmt.Println(\"string true\") } } </code></pre></div>   submitted by   <a href=\"https://www.reddit.com/user/lickety-split1800\"> /u/lickety-split1800 </a>","contentLength":540,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Waku: A CLI Project Generation Tool","url":"https://www.reddit.com/r/golang/comments/1i50hu2/waku_a_cli_project_generation_tool/","date":1737299303,"author":"/u/caffeinestack","guid":361,"unread":true,"content":"<p>Iâ€™m excited (and kinda nervous) to share , my first real project in Go! ðŸŽ‰</p><p>Waku is a project generation CLI tool designed to simplify setting up new projects and improve Developer Experience (DX). Think of it as a smarter copy-paste tool! It works with public/private repos or local directories as template sources.</p><p>Currently, thereâ€™s just one official style available, but the vision is to add more to cover most (and even some uncommon) use casesâ€”like a Go microservice, a React front-end, or a full-stack project with CI/CD baked in.</p><p>I created Waku because I got tired of setting up projects from scratch over and over. The goal is to make project setup painless, so you can skip the boring boilerplate and get straight to coding.</p><p>Iâ€™ve been using Waku myself and iterating on it for over half a year now, and so far, the feedback from developers has been pretty positive.</p><p>Itâ€™s still early days (), but thatâ€™s the vision for Waku moving forward.</p><p>Would love your to hear your thoughts, ideas, or contributions! Thank you.</p>","contentLength":1030,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Go is a Well-Designed Language, Actually","url":"https://mattjhall.co.uk/posts/go-is-well-designed-actually.html","date":1737283705,"author":"/u/finallyanonymous","guid":364,"unread":true,"content":"<blockquote><p>An ancient programmer proverb</p></blockquote><p>In many ways 2009 decided my future career. I was thirteen and had just scored my first goal in a competitive football match - a lovely one-two with the winger finished by a powerful strike into the top left corner. Sadly the talent scouts were missing that day. Whilst I was dreaming of Wembley, Go was announced to the world.</p><p>Go soon attracted a large following. People loved how simple it was, how optimised it was for web services and the tooling like . Every action has an equal and opposite reaction however, and so it was with Go. People hated how simple it was, how it was just for noddy REST APIs and the overzealous tooling.</p><blockquote><p>And so they didn't. They didn't design a language. It sorta just \"happened\".</p></blockquote><p>To me, a design is a plan or specification for something that fulfils a goal. For example, the goal of the BBC News website might be to inform users of the most relevant things that are going on in the world. The way they do that is by writing news articles, ordering them based on location and importance. The nuclear missile speeding towards me trumps the cat stuck up a tree.</p><p>It follows that a design can be evaluated on how well it achieves the design goal.</p><p>Go was designed at Google, where Russ Cox, Rob Pike, Ken Thompson and many others were working. Google was using Java and C++ at the time which the designers of Go felt were performant but hard to use. The compilers were slow, tooling was finicky and the languages had been designed at least a decade before. Cloud computing - large numbers of multicore servers working together - was becoming widespread.</p><p>They decided to design their own language and prioritised making it work at scale - in computing and man power. Rob Pike explains in <a href=\"https://go.dev/talks/2012/splash.article\">Go at Google</a>:</p><blockquote><p>The hardware is big and the software is big. There are many millions of lines of software, with servers mostly in C++ and lots of Java and Python for the other pieces. Thousands of engineers work on the code.</p></blockquote><p>Elsewhere Pike talks about the thousands of engineers he was targeting, in his usual modest, subtle way:</p><blockquote><p>The key point here is our programmers are Googlers, theyâ€™re not researchers. Theyâ€™re not capable of understanding a brilliant language.</p></blockquote><p>Top tip: if you're designing something, try to avoid belittling and patronising the people you are designing for.</p><p>Notwithstanding this quote, we get a pretty reasonable design goal: the language should make writing and maintaining large, concurrent server code easy; even across thousands of developers of differing skill levels.</p><p>Let's look at some complaints people have about Go and evaluate them against the design goal.</p><p>Go's filesystem API is often criticised for being geared towards Unix. Windows doesn't have file permissions in the way that Unix does, so Go just returns some made up ones. Furthermore Go takes a pretty simplistic approach to paths. An OS has a path separator and paths themselves are Go's  type - just a slice of bytes with no real checking or constraints.</p><p>This can be explained by the design goal. Go was designed for use at Google where their servers <a href=\"https://workspace.google.com/learn-more/security/security-whitepaper/page-4.html\">are all Linux</a>, like most servers. If you're designing a language that is aimed at servers, writing the filesystem API to be Unix-centric is not such a bad idea.</p><h3>No Operator or Function Overloading</h3><p>In Go, unlike Java, functions and methods only have one definition (once build tags and target are specified). Operators are implemented in the compiler, unlike C++, and so cannot be overloaded either.  In the  package, to add a  to a  you need to use the  method. If you want to add two days you can't just call <code>Add(0 /*years*/, 0 /*months*/, 2 /*days*/)</code>, you need to use .</p><p>To some this may seem inelegant but it is simpler. If you see a function call in Go you know there is one definition you need to check. If you see an operator you know it is for a built in type and will do something sensible, not <a href=\"https://github.com/zhuowei/nft_ptr?tab=readme-ov-file\">mint an NFT</a>.</p><p>It's fair to say that the current trend in programming languages is towards terseness. No wonder programmers hate Go's  style of error handling.</p><p>However, again, this was a deliberate choice:</p><blockquote><p>Although in contrast Go makes it more verbose to check errors, the explicit design keeps the flow of control straightforwardâ€”literally.</p></blockquote><p>Obvious control flow makes code more readable. Although languages with exceptions might be quicker to write, the code they produce is not as simple, and control flow is hidden.</p><p>Go is often criticised for being a bit of a throw-back by avoiding features like exceptions. Someone once asked the designers \"Why did you choose to ignore any research about type systems since the 1970s?\". Similar arguments has been <a href=\"https://www.bluxte.net/musings/2018/04/10/go-good-bad-ugly/#go-ignored-advances-in-modern-language-design\">repeated elsewhere</a>.</p><p>Firstly Rob Pike sees your snootiness, and doesn't care about it:</p><blockquote><p>Go was designed to address the problems faced in software development at Google, which led to a language that is not a breakthrough research language but is nonetheless an excellent tool for engineering large software projects.</p></blockquote><p>But secondly designing errors as explicit values has been a trend-(re)setter. Go, Rust and Zig have all chosen to use this approach. Swift, even though it uses exceptions, requires you to mark functions that can error in their signature.</p><p>Go doesn't play nicely with other languages. If you want to call a C function - for example to bind to SQLite - then you have to go through CGo. <a href=\"https://dave.cheney.net/2016/01/18/cgo-is-not-go\">CGo is not Go</a> and has a performance overhead. As goroutines - which have their own stack set up by the Go runtime - are the unit of execution, Go has to do some acrobatics to have the stack in the way C expects. This can be costly.</p><p>Go's FFI is not helped by it having its own compiler, linker and debugger. Much in the Go ecosystem is custom.</p><p>When we consider the design goal we can find justification. Server software has to be concurrent, and so goroutines were chosen. That necessarily makes calling C code more complicated, but the trade-off does at least fit with Go being used for concurrent systems where  talk to each other, not processes.</p><p>These decisions also gave Go a leg-up on tooling. The compiler being specific to Go means it can focus on compiling just Go as quickly as possible. The debugger can understand goroutines and all of Go's built in types.</p><p>That's subjective. For my part, I like it. The Go code I've looked at and worked on has generally been easy to read and understand. The lack of bells and whistles forces me to just write the damn code rather than building abstractions that don't hold their weight. I've also taught Go to a large group of graduates just out of university with success.</p><p>That doesn't mean I don't see its downsides. I've been sat in a call with a customer who was affected by a bug that we couldn't trace due to not checking an error. Easily prevented by linters; painful when you haven't turned them on. For ages Go didn't have generics which made it annoying to write generic data structures. Every time I receive a bug report on Windows I have to pause to think about whether Go has lulled me into a false sense of security.</p><p>Ultimately these are issues that have resulted from a trade-off that was deliberately made in the design process. You can say you don't like Go, or that it is a bad fit for a certain application, or it doesn't give you the things you need. Heck, you can even say you hate it. But don't say it wasn't (well) designed.</p>","contentLength":7301,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1i4vwjt/go_is_a_welldesigned_language_actually/"},{"title":"I wrote a DHCP Server in Go (personal project)","url":"https://www.reddit.com/r/golang/comments/1i4vroz/i_wrote_a_dhcp_server_in_go_personal_project/","date":1737283125,"author":"/u/umegbewe","guid":365,"unread":true,"content":"<p>Hey everyone, i wanted to share a project i have been working on. Early 2024, I came across DHCP when i tried building a network boot server that enables anyone to boot popular OS'es across the internet.</p><p>I just found the protocol fascinating, dug into the RFC's and found ended up implemented a server i named </p><ul><li>Instead of storing every free IP in a slice, I used a bitmap to track used/free addresses, searching in a ring-like fashion. This scales better for large address pools.</li><li>Boltdb for lease persistence (future work to swap out for other db's like redis, postgres, mysql etc)</li><li>The server exposes metrics, including active/free lease counts, so you can plug it into your existing monitoring stack.</li></ul><p>If youâ€™re interested in DHCP, network booting, or just want to explore lease-allocation algorithms in Go, check it out on GitHub <a href=\"https://github.com/umegbewe/dhcpd\">github.com/umegbewe/dhcpd</a></p><p>Iâ€™d love any feedback, ideas, or contributions especially if youâ€™ve dealt with DHCP servers or large IP pools before. Thanks for reading, and let me know what you think!</p>","contentLength":1026,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I wish this handy \"robustio\" package was exported, it used by \"go clean -modcache\"","url":"https://pkg.go.dev/cmd/go/internal/robustio","date":1737263463,"author":"/u/wolfeidau","guid":362,"unread":true,"content":"<section><p>Package robustio wraps I/O functions that are prone to failure on Windows,\ntransparently retrying errors up to an arbitrary timeout.\n</p><p>Errors are classified heuristically and retries are bounded, so the functions\nin this package do not completely eliminate spurious errors. However, they do\nsignificantly reduce the rate of failure in practice.\n</p><p>If so, the error will likely wrap one of:\nThe functions in this package do not completely eliminate spurious errors,\nbut substantially reduce their rate of occurrence in practice.\n</p></section><section><div><p>IsEphemeralError reports whether err is one of the errors that the functions\nin this package attempt to mitigate.\n</p><p>Errors considered ephemeral include:\n</p><ul><li>syscall.ERROR_ACCESS_DENIED</li><li>syscall.ERROR_FILE_NOT_FOUND</li><li>internal/syscall/windows.ERROR_SHARING_VIOLATION</li></ul><p>This set may be expanded in the future; programs must not rely on the\nnon-ephemerality of any given error.\n</p></div><div><p>ReadFile is like os.ReadFile, but on Windows retries errors that may\noccur if the file is concurrently replaced.\n</p><p>(See golang.org/issue/31247 and golang.org/issue/32188.)\n</p></div><div><p>RemoveAll is like os.RemoveAll, but on Windows retries errors that may occur\nif an executable file in the directory has recently been executed.\n</p><p>(See golang.org/issue/19491.)\n</p></div><div><p>Rename is like os.Rename, but on Windows retries errors that may occur if the\nfile is concurrently read or overwritten.\n</p><p>(See golang.org/issue/31247 and golang.org/issue/32188.)\n</p></div></section>","contentLength":1405,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1i4r29m/i_wish_this_handy_robustio_package_was_exported/"}]}