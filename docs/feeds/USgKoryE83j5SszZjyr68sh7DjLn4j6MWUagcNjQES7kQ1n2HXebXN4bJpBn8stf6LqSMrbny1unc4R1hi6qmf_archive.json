{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"How did you go about \"Writing an interpreter in Go\" (The book)","url":"https://www.reddit.com/r/golang/comments/1iau5os/how_did_you_go_about_writing_an_interpreter_in_go/","date":1737935210,"author":"/u/PeachKnight96","guid":561,"unread":true,"content":"<p>Did anyone here finish this book?</p><p>The author says we should follow along the book and type the code in our machine but I really don't understand this way of teaching. What am I learning if I only type this into my machine?</p>","contentLength":221,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"MoxyProxy, an Atreugo(fasthttp) proxy with web interface","url":"https://www.reddit.com/r/golang/comments/1iasbf8/moxyproxy_an_atreugofasthttp_proxy_with_web/","date":1737930237,"author":"/u/ShotgunPayDay","guid":559,"unread":true,"content":"<p>I wanted to make a proxy that was as easy as possible to configure with functionality that I've always wanted. Here is the list of features from the README:</p><ul><li>Built with Atreugo (fasthttp).</li><li>Simple Web Interface (html/template, HTMX, Surreal, BulmaCSS), hijacks /moxyproxy route</li><li>ACME autocert using TLS-ALPN-01. Activates upon setting DomainName and restarting application.</li><li>Automatically upgrade http:// to https:// when DomainName is set.</li><li>Wireguard Server automatic update/restart upon peer changes.</li><li>Wireguard Peer config generation through HTTPS GET /moxyproxy/wg with dedicated Token and new Peer Name.</li><li>Serve static assets from /moxyproxy/public and /moxyproxy/private (OAuth2 protected)</li><li>Built in OAuth2 to block non-logged in users and send JSON user data to upstream servers using \"moxyuser\" header.</li><li>User data is not stored in the proxy and is instead sent to client in compressed ZSTD then encrypted AES256/GCM cookie.</li><li>Built in RateLimiter that will return 429 Too Many Requests on any request.</li><li>Automatic IP banning (403 Forbidden) on 4xx Response which counts against the IPs LimiterBanCount for the day this includes responses from upstream servers: <ul><li>401 Unauthorized 5x penalty</li><li>400 Any other 400 1x penalty</li></ul></li><li>Minimal configuration needed to get started.</li></ul><p>It's still a work in progress and currently being used for my website and services.</p><p>Not production ready and there will probably be breaking changes. I still need to figure out a testing strategy and benchmarking to do fine tuning. I'd like to test HTTPS to HTTP with wireguard with a net/http server serving HTML which means using VPSs to test the round trip without it breaking the bank. Synthetic tests aren't going to show any real world performance.</p><p>Screenshots are in the README.</p>","contentLength":1726,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Someone has submitted my project on AUR.","url":"https://aur.archlinux.org/packages/bunster","date":1737905019,"author":"/u/yassinebenaid","guid":562,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1iah7j9/someone_has_submitted_my_project_on_aur/"},{"title":"Getting Started with Encore.go","url":"https://eltonminetto.dev/en/post/2025-01-25-intro-encore-part-1/","date":1737904579,"author":"/u/eminetto","guid":557,"unread":true,"content":"<p><a href=\"https://encore.dev/go\">Encore.go</a>&nbsp;has been on my radar for quite some time, when its beautiful website and examples caught my attention in a news article on Hacker News. But my excitement really increased after&nbsp;<a href=\"https://encore.dev/blog/open-source-decoupled\">this post</a>&nbsp;was published in December 2024. It announced that the framework would&nbsp;become an independent project, separated from the Encore Cloud tool.\nThis decision can make the framework more attractive to companies and developers who want to use it in their existing environments. I have nothing against <a href=\"https://encore.cloud\">Encore Cloud</a>, which seems to be a very interesting and robust solution, but this freedom of choice favors adoption in companies of different sizes.</p><p>Given this initial context, I decided to port a project that I use to write texts and lectures about microservices to Encore, and the result is a series of posts, this being the first. The initial idea is to divide the series as follows:</p><ol><li>Creating an API with a database (&lt;— you are here)</li><li>Interservice communication and authentication</li><li>Communication via Pub/Sub</li></ol><p>I may create new posts while writing the following parts, but the initial plan is defined. So, let’s go to the first part.</p><h2>Creating an API with a database</h2><p>To use Encore, we need to install its CLI, which we will use throughout the development cycle. Since I use macOS, I installed it using the command:</p><pre><code>brew install encoredev/tap/encore\n</code></pre><p>In&nbsp;the <a href=\"https://encore.dev/docs/ts/install\">documentation</a>,&nbsp;you can see the other possible installation methods.</p><p>With the CLI installed, we can use it to create the project:</p><p>Since I chose the option to create a project from scratch, the created directory only contains the files with the dependencies &nbsp;(&nbsp;and&nbsp;) and , which&nbsp;will be used by the CLI to manipulate the project. Its initial content is straightforward:</p><div><pre tabindex=\"0\"><code data-lang=\"json\"></code></pre></div><p>For now, we won’t need to change anything in&nbsp;, so let’s create the structure of the first microservice:</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>In addition to creating the directory, we initialize a file called , where we will define our API. The content of the first version was as follows:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Encore extensively uses the concept of&nbsp; to define the application’s behavior and generate the code necessary for execution. The first example of this is the creation of a&nbsp;:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>Another common feature of frameworks like Encore is the existence of conventions. The first one we will find here is the initialization of services. Since we have defined a service called&nbsp;, we can create a function called&nbsp; that will be invoked by the framework. In this function, we will inject the service dependencies, as we will do later in the project.</p><p>The following&nbsp;annotation we see in the code is the one that defines an API, as in the example:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>This declaration tells the framework that this is a public API (we’ll see more about this in the following parts of this series) whose path is  and that it will be accessed via the  method.\nAn API is a function that receives a&nbsp;context and a parameter struct (in this case, ) and returns a response struct (in this case, ).</p><p>One of the interesting features of the framework is the ease of accessing the parameter values: we can use the values ​​as , which is part of the received struct, without needing to convert the received JSON. More details about parameter handling and examples can be found&nbsp;in the official <a href=\"https://encore.dev/docs/go/primitives/defining-apis\">documentation</a>.</p><p>We can now run the project using the CLI:</p><div><pre tabindex=\"0\"><code data-lang=\"bash\"></code></pre></div><p>We can see that the API is available at the URL&nbsp; and the&nbsp;development dashboard, which is one of the biggest attractions of the framework. How it works can be seen below:</p><p>In the video, you can see the interesting features available, such as testing the API and viewing traces and application components. The dashboard will become even more useful as we add layers of complexity to the project.</p><p>The next step in developing the application is to define a database. We need to have Docker installed and running to do this since Encore will use it to create the database image. At the time of writing, the available database is PostgreSQL. In the , we will make the following changes:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>As you can see in the excerpt, Encore uses the concept of&nbsp;, which is very useful. It was necessary to create the directory&nbsp; and the file&nbsp;<code>user/migrations/1_create_tables.up.sql</code> with the following content:</p><div><pre tabindex=\"0\"><code data-lang=\"sql\"></code></pre></div><p>The database is created in the file, and a record is also inserted for use in tests via the dashboard. More details&nbsp;about migrations can be seen in the&nbsp;<a href=\"https://encore.dev/docs/go/primitives/databases#database-migrations\">documentation</a>.</p><p>Another interesting feature of the command&nbsp; is that it auto-reloads the application. Whenever something is changed in one of the project files, the application is recompiled and executed again, so your database should have been created successfully.</p><p>To finalize this first version of the project, I created other files to complement the functionality. Using a framework like Encore makes repetitive tasks much more straightforward, such as configuring routes, converting parameters and responses, etc. However, it does not eliminate the need to use good development practices, such as abstractions, decoupling, etc. With this in mind, I created other files that are important for our project:</p><ul><li><a href=\"https://github.com/eminetto/post-encore/blob/main/user/user.go\">user.go</a>, which defines what a&nbsp;“user” in the application is</li><li><a href=\"https://github.com/eminetto/post-encore/blob/main/user/service.go\">service.go</a>, which contains the application’s business rule and will be used by the API</li><li><a href=\"https://github.com/eminetto/post-encore/blob/main/user/security/jwt.go\">security/jwt.go</a>, which includes the logic for generating and validating JWT tokens</li></ul><p>With these auxiliary files, the final version of our API looks like this:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>In this new version, you can see that we initialize the service (in the function&nbsp;) with the injection of the business rule and the error handling provided by the framework.</p><p>Another advantage of using a framework like Encore is that it provides features that help with the critical task of writing tests. In this first version, we have two crucial components to test:</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>The highlight is the use of the package&nbsp;, which provides a way to ensure that tests can be executed in parallel (<code>et.EnableServiceInstanceIsolation()</code>) and the ease of using an exclusive database for tests (<code>testDB, err:= et.NewTestDatabase(ctx, \"user\")</code>).</p><p>The interesting thing is that migrations are used automatically, making the test easier to write and execute.</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>In this test, nothing from the framework was necessary; just good old Go, with its native advantages, was used.</p><p>An important detail: to run the tests, you must use the CLI. Therefore, instead of running them using the command:</p><p>There is a plugin for Goland that allows execution directly through the IDE, but the same is not yet true for VSCode, as can be seen in the&nbsp;official testing <a href=\"https://encore.dev/docs/go/develop/testing\">documentation</a>.</p><p>The objective of this first post was to present the basics of the framework and spark your curiosity about the next chapters in this series.</p><p>I’ll leave my opinions on the framework for the last part of the series so I can provide more arguments to say whether I liked the experience or not. But I can say that I’m having a lot of fun with the first steps. What about you, dear reader? What do you think of Encore so far? Leave your impressions in the comments.</p>","contentLength":6911,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1iah0ue/getting_started_with_encorego/"},{"title":"SQLC - migrating existing queries to a new schema","url":"https://www.reddit.com/r/golang/comments/1iaglnn/sqlc_migrating_existing_queries_to_a_new_schema/","date":1737903573,"author":"/u/Sliczzz","guid":558,"unread":true,"content":"<p>I've been happily using SQLC with Postgresql as an engine to enjoy type safe SQL in a project I've recently been working on. By now the application is quite mature and I have quite some queries (13 tables, 10-15 query files, 50-100 queries).</p><p>Now my application is evolving and I want to build another module, which needs its own separate schema. I could go all the way and split the application in two and have two databases, but for now a modular monolith with separate schemas will do just fine.</p><p>The problem I now have is that those queries/tables assume the schema being used is `public`. Now, I'd like to split my queries into 2 schemas (`game` and `lobby`), but from what I understand the only way to achieve this is to migrate every single query (and corresponding golang imports) to the new schema manually.</p><p>Is there a way to specify the schema context in which the queries are running and being generated without impacting the existing codebase too much (like, having to change all existing imports because the postgres schema changed)?</p>","contentLength":1041,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"sortedmap – sorted map implementation for Go with a heap and iterators under the hood","url":"https://www.reddit.com/r/golang/comments/1iaeqla/sortedmap_sorted_map_implementation_for_go_with_a/","date":1737898681,"author":"/u/egregors","guid":560,"unread":true,"content":"<p>Check this out: a generic map that maintains order (by keys or values). To be honest, I was surprised not to find something like this in the current state of things. Perhaps it solves too specific problems, idk. But anyway, here is my implementation: <a href=\"https://github.com/egregors/sortedmap\">sortedmap</a>. I believe it could be useful for someone.</p><p>The constructor expects a custom  function to define the ordering rule. To maintain order, I use a generic heap of key-value pairs with an  insert time complexity. The map access API is mostly inspired by standard library  and .</p><p>The only thing I don’t really like is the  method. In the current implementation, it requires a full scan of the heap to find the key-value pair to remove. I’ll probably find a more efficient way to handle this, but for now, in real-world use cases, it doesn’t seem like a major issue.</p><p><strong>Why do I need a sorted map?</strong></p><p>Quite simple: I need a recursive category tree that can be edited at runtime and must always remain ordered.</p>","contentLength":957,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}