{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Go 1.24's `go tool` is one of the best additions to the ecosystem in years","url":"https://www.jvt.me/posts/2025/01/27/go-tools-124/","date":1737978212,"author":"/u/profgumby","guid":292,"unread":true,"content":"<p>For those that aren't aware, one of the big changes in February's upcoming Go 1.24 release is the new <a href=\"https://tip.golang.org/doc/go1.24#tools\"></a> command, and  directive in the  to manage any tools your project uses. I'm  about this, and in my opinion, this is one of the best changes we've had in recent years in the ecosystem as a whole.</p><p>Within your Go codebases, there's often some additional tools that you need to have installed to be able to build/test/deploy the project.</p><p>Sometimes this will a dependency that's needed for ing, or it may be that you want to pipe your  output into a JUnit-compatible format, so your CI platform can provide more useful metadata.</p><p>For each of these, you have two choices:</p><ul><li>require that the user knows how to install them, i.e. by knowing to run  or  before building anything on the project</li><li>use the <a href=\"https://www.jvt.me/posts/2022/06/15/go-tools-dependency-management/\"> pattern</a> to make it so you can  run , and that'll call the right dependency via </li></ul><p>My preference is <a href=\"https://www.jvt.me/posts/2022/06/15/go-tools-dependency-management/\"> pattern</a>, but there are two key problems with this approach.</p><p>Firstly, there's a performance hit of using a . It's something that is  noticeable, moreso if your project relies upon a lot of  i.e. with lots of s, because prior to Go 1.24, the  invocations were not cached.</p><p>Secondly, it also leads to dependency tree bloat, because you have to record your dependency on i.e. <code>github.com/sqlc-dev/sqlc/cmd/sqlc</code> which then gets recorded in your , and then anyone using  will then see that as an indirect (transitive) dependency.</p><p>This was something we <a href=\"https://www.jvt.me/posts/2023/10/23/oapi-codegen-v2-decrease/\">worked on for 's v2 release</a> to further reduce unnecessary dependencies, and make things a bit cleaner for our consumers. This is somewhat mitigated by Go's <a href=\"https://go.dev/ref/mod#graph-pruning\">module graph pruning</a> which won't download dependencies that aren't used, but consumers may still see the dependencies coming in as an indirect dependency, which may not be ideal (especially as it can then bloat their indirect dependencies, which then gets passed on to their consumers and so on .</p><p>Dependency tree bloat can also be further mitigated by splitting your <a href=\"https://www.jvt.me/posts/2024/09/30/go-tools-module/\"> into a separate module</a>, which makes it more awkward to invoke dependencies but makes sure that none of your consumers will be seeing any tool-related dependencies.</p><p>For those who know me as co-maintainer of <a href=\"https://github.com/oapi-codegen/oapi-codegen\">oapi-codegen</a>, you'll know that the  pattern is our <a href=\"https://github.com/oapi-codegen/oapi-codegen#install\">explicit recommendation</a> and we believe is better than installing it as a binary, so it's probably unsurprising that I'm very excited about this as an option to manage dependencies.</p><p>Let's take a worked example of how we'd move over calls to  to the new  pattern.</p><p>For instance let's say that we have the following  in its own module:</p><pre tabindex=\"0\"><code data-lang=\"gomod\"># tools/go.mod\nmodule dmd.tanna.dev/tools\n\ngo 1.22.0\n\nrequire (\n\tgithub.com/99designs/gqlgen v0.17.49\n\tgithub.com/oapi-codegen/oapi-codegen/v2 v2.4.1\n\tgithub.com/sqlc-dev/sqlc v1.26.0\n)\n</code></pre><p>We can then see that we invoke this via :</p><div><pre tabindex=\"0\"><code data-lang=\"go\"></code></pre></div><p>To start migrating over to , we need to make sure that we've first pulled in the new version of Go in our top-level Go module:</p><div><pre tabindex=\"0\"><code data-lang=\"diff\"></code></pre></div><p>Next, we need to pull in a  dependency on 's CLI tool - notice that you need  to the command that's being invoked:</p><div><pre tabindex=\"0\"><code data-lang=\"sh\"></code></pre></div><p>We could also do this by hand, but doing it via  simplifies this a little.</p><p>From here, we'll notice that our  has a few other changes:</p><div><pre tabindex=\"0\"><code data-lang=\"diff\"></code></pre></div><ul><li>there is a  directive for <code>github.com/oapi-codegen/oapi-codegen/v2/cmd/oapi-codegen</code></li><li>the containing Go module for the CLI, <code>github.com/oapi-codegen/oapi-codegen/v2</code>, is now an  dependency</li><li>any other required dependencies of <code>github.com/oapi-codegen/oapi-codegen/v2/cmd/oapi-codegen</code> are now  dependencies</li></ul><p>Now we've done this, we could run:</p><div><pre tabindex=\"0\"><code data-lang=\"sh\"></code></pre></div><p>With this tool set up, we can now modify i.e. <code>internal/ecosystems/generate.go</code> like so to use the new :</p><div><pre tabindex=\"0\"><code data-lang=\"diff\"></code></pre></div><p>Then running <code>go generate ./internal/ecosystems</code> works as it did before ðŸš€</p><p>A less scientific view than Howard John's article above, but we can see a slight improvement in performance:</p><div><pre tabindex=\"0\"><code data-lang=\"sh\"></code></pre></div><p>Compare this to the previous implementation:</p><div><pre tabindex=\"0\"><code data-lang=\"sh\"></code></pre></div><p>Notice that the first call is similar in speed, but the use of 's subsequent calls are still faster.</p><p>I'm a big fan of the fact that as of Go 1.24+ the s will be cached, so even if you don't move over to , you'll get a performance boost!</p><p>Now, there are still a few things I've noticed while doing the migration that aren't necessarily what I expected.</p><p>Something interesting is that the usage of the  dependencies being treated as an  dependency is that they're present in the dependency tree, and treated like any other  dependency.</p><p>I'd also have preferred that we had just used  instead of , but I can see why this is likely the choice that's made - so they're treated like any other dependency - but making them less clear as only being required for tools could lead to issues with clashing dependencies, or where you upgrade an  dependency and then that breaks other things.</p><p>This means that tools such as Renovate need to be a little more involved in how to do the updates, but <a href=\"https://github.com/renovatebot/renovate/discussions/33867\">that's all in hand</a>.</p><h2> fails to run with Go 1.24rc2</h2><p>It may be interesting to find out what else gets affected by this - please give the RC a test!</p><p>Overall, I'm feeling very positive about it, and improving the way that dependencies get installed <em>if they should be built from source</em>, but there are dependencies such as  which <a href=\"https://golangci-lint.run/welcome/install/#install-from-sources\">don't recommend building from source</a> and instead using their pre-built binaries, which is fair, and is unlikely to change here.</p>","contentLength":5212,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1ib6sal/go_124s_go_tool_is_one_of_the_best_additions_to/"},{"title":"How did you go about \"Writing an interpreter in Go\" (The book)","url":"https://www.reddit.com/r/golang/comments/1iau5os/how_did_you_go_about_writing_an_interpreter_in_go/","date":1737935210,"author":"/u/PeachKnight96","guid":294,"unread":true,"content":"<p>Did anyone here finish this book?</p><p>The author says we should follow along the book and type the code in our machine but I really don't understand this way of teaching. What am I learning if I only type this into my machine?</p>","contentLength":221,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"MoxyProxy, an Atreugo(fasthttp) proxy with web interface","url":"https://www.reddit.com/r/golang/comments/1iasbf8/moxyproxy_an_atreugofasthttp_proxy_with_web/","date":1737930237,"author":"/u/ShotgunPayDay","guid":291,"unread":true,"content":"<p>I wanted to make a proxy that was as easy as possible to configure with functionality that I've always wanted. Here is the list of features from the README:</p><ul><li>Built with Atreugo (fasthttp).</li><li>Simple Web Interface (html/template, HTMX, Surreal, BulmaCSS), hijacks /moxyproxy route</li><li>ACME autocert using TLS-ALPN-01. Activates upon setting DomainName and restarting application.</li><li>Automatically upgrade http:// to https:// when DomainName is set.</li><li>Wireguard Server automatic update/restart upon peer changes.</li><li>Wireguard Peer config generation through HTTPS GET /moxyproxy/wg with dedicated Token and new Peer Name.</li><li>Serve static assets from /moxyproxy/public and /moxyproxy/private (OAuth2 protected)</li><li>Built in OAuth2 to block non-logged in users and send JSON user data to upstream servers using \"moxyuser\" header.</li><li>User data is not stored in the proxy and is instead sent to client in compressed ZSTD then encrypted AES256/GCM cookie.</li><li>Built in RateLimiter that will return 429 Too Many Requests on any request.</li><li>Automatic IP banning (403 Forbidden) on 4xx Response which counts against the IPs LimiterBanCount for the day this includes responses from upstream servers: <ul><li>401 Unauthorized 5x penalty</li><li>400 Any other 400 1x penalty</li></ul></li><li>Minimal configuration needed to get started.</li></ul><p>It's still a work in progress and currently being used for my website and services.</p><p>Not production ready and there will probably be breaking changes. I still need to figure out a testing strategy and benchmarking to do fine tuning. I'd like to test HTTPS to HTTP with wireguard with a net/http server serving HTML which means using VPSs to test the round trip without it breaking the bank. Synthetic tests aren't going to show any real world performance.</p><p>Screenshots are in the README.</p>","contentLength":1726,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Someone has submitted my project on AUR.","url":"https://aur.archlinux.org/packages/bunster","date":1737905019,"author":"/u/yassinebenaid","guid":295,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1iah7j9/someone_has_submitted_my_project_on_aur/"},{"title":"SQLC - migrating existing queries to a new schema","url":"https://www.reddit.com/r/golang/comments/1iaglnn/sqlc_migrating_existing_queries_to_a_new_schema/","date":1737903573,"author":"/u/Sliczzz","guid":290,"unread":true,"content":"<p>I've been happily using SQLC with Postgresql as an engine to enjoy type safe SQL in a project I've recently been working on. By now the application is quite mature and I have quite some queries (13 tables, 10-15 query files, 50-100 queries).</p><p>Now my application is evolving and I want to build another module, which needs its own separate schema. I could go all the way and split the application in two and have two databases, but for now a modular monolith with separate schemas will do just fine.</p><p>The problem I now have is that those queries/tables assume the schema being used is `public`. Now, I'd like to split my queries into 2 schemas (`game` and `lobby`), but from what I understand the only way to achieve this is to migrate every single query (and corresponding golang imports) to the new schema manually.</p><p>Is there a way to specify the schema context in which the queries are running and being generated without impacting the existing codebase too much (like, having to change all existing imports because the postgres schema changed)?</p>","contentLength":1041,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"sortedmap â€“ sorted map implementation for Go with a heap and iterators under the hood","url":"https://www.reddit.com/r/golang/comments/1iaeqla/sortedmap_sorted_map_implementation_for_go_with_a/","date":1737898681,"author":"/u/egregors","guid":293,"unread":true,"content":"<p>Check this out: a generic map that maintains order (by keys or values). To be honest, I was surprised not to find something like this in the current state of things. Perhaps it solves too specific problems, idk. But anyway, here is my implementation: <a href=\"https://github.com/egregors/sortedmap\">sortedmap</a>. I believe it could be useful for someone.</p><p>The constructor expects a custom  function to define the ordering rule. To maintain order, I use a generic heap of key-value pairs with an  insert time complexity. The map access API is mostly inspired by standard library  and .</p><p>The only thing I donâ€™t really like is the  method. In the current implementation, it requires a full scan of the heap to find the key-value pair to remove. Iâ€™ll probably find a more efficient way to handle this, but for now, in real-world use cases, it doesnâ€™t seem like a major issue.</p><p><strong>Why do I need a sorted map?</strong></p><p>Quite simple: I need a recursive category tree that can be edited at runtime and must always remain ordered.</p>","contentLength":957,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit"]}