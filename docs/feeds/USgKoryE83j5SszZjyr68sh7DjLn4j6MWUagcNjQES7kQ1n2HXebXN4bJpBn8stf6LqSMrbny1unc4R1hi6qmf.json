{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Any way to have live reload and bebugger work together inside a docker container ?","url":"https://www.reddit.com/r/golang/comments/1i99g1o/any_way_to_have_live_reload_and_bebugger_work/","date":1737761881,"author":"/u/TryallAllombria","guid":564,"unread":true,"content":"<p>Hey, I've been trying to make Delve and Air working together. I'm from the NodeJS world and i'm used to hit save to have my server reloading, but also keep my debugger alive during the process. It's a nice dev workflow and I was wondering how I could find the same workflow using golang ?</p><p>I tried numerous configuration, either delve is stopping my server from starting until I attach my debug process. Or it won't reload either my server or the delve debugger properly if I pass the --continue flag.</p><p>How are you working with live reload and debugger with golang ? Do you use a more manual approach by reloading your app yourself ? Or start a debug server when required ?</p>","contentLength":669,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Success with errors in Go: stack traces and metadata","url":"https://blog.gregweber.info/blog/go-errors-library/","date":1737752357,"author":"/u/gregwebs","guid":565,"unread":true,"content":"<p>There are several patterns for dealing with errors I encounter almost universally on Go projects:</p><ul><li>adding metadata to existing errors</li></ul><p>The first two can be handled with the help of a light-weight error library. There are a lot of error libraries available that do mostly the same things.\nI maintain <a href=\"https://github.com/gregwebs/errors\">github.com/gregwebs/errors</a>.</p><p>A Panic in Go produces a stack trace, but an error does not.</p><p>Adding a stack trace to your go code happens automatically with an error library that supports stack traces. If you use error creation functions:</p><pre data-lang=\"go\"><code data-lang=\"go\"></code></pre><p>These will create an error with a stack trace.\nWrapping functions (see next sections) will automatically add a stack trace as well.</p><p>I am told errors don't have traces because that this would have a negative performance impact.\nHowever, in almost all of my usage of Go, when an error is returned performance is no longer a concern.\nSometimes when errors can alter performance that indicates an error is being returned for what is a normal condition rather than an error condition.\nAn example of this is read APIs returning EOF.\nCertainly there are some cases where performance needs to be optimized on an error path. It's worth noting that the Zig language has figured out how to further <a href=\"https://ziglang.org/documentation/master/#Error-Return-Traces\">minimize the impact of collecting error traces</a> and allows them to be turned off in release builds.\nBelow we also see an example where a stack trace would not be helpful.\nIn these cases, one can still use standard APIs that don't add stack traces:</p><pre data-lang=\"go\"><code data-lang=\"go\"></code></pre><p>Additionally, the <a href=\"https://github.com/gregwebs/errors\">github.com/gregwebs/errors</a> library provides a 'WrapNoStack' function that can be used to wrap an error without adding a stack trace.</p><p>The standard way of adding metadata to Go errors is to wrap them in format strings:</p><pre data-lang=\"go\"><code data-lang=\"go\"></code></pre><p>I think that adding a new formatting verb for errors was a pragmatic choice to avoid dependency issues and match what users were currently doing, but I think the API is cryptic and limited compared to the library approach of:</p><pre data-lang=\"go\"><code data-lang=\"go\"></code></pre><p>There is also a  function for using formatting strings. However, as I have shifted towards structured logging I want all my metadata structured, including for errors.\nThe errors library features an slog compatible API for adding metadata called  where \"s\" stands for \"structured\".</p><pre data-lang=\"go\"><code data-lang=\"go\"></code></pre><p>A common pattern supported by the library is to accumulate attributes that can be used both with slog and for annotating errors:</p><pre data-lang=\"go\"><code data-lang=\"go\"></code></pre><p>With a stack trace and relevant metadata annotating an error, I can frequently open up a bug report just from seeing the error report without having to dig into logs. When I do need to dig into the logs, having metadata on the error helps greatly with tracking things down. If you have a request id/trace id you can attach that to the error to help find it in the logs.</p><p>Future maintainers of your code base will thank you when they can quickly track down errors.</p><p>Future posts will discuss approaches to:</p>","contentLength":2826,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1i95udo/success_with_errors_in_go_stack_traces_and/"},{"title":"Upgraded chat app","url":"https://www.reddit.com/r/golang/comments/1i93ao3/upgraded_chat_app/","date":1737745822,"author":"/u/DixGee","guid":563,"unread":true,"content":"<p>Hi everyone, I created a web chat app for anonymous chatting last month and posted here. Since then I made lots of changes and completely transformed the app using React, Go and Redis. Now users will have to be authenticated to start chatting. I want to add more features like detecting whether users are online, sharing files, etc. A big reason why I made this app was the idea of getting a job in go tbf. So far I've seen only roles for experienced candidates. If anyone can guide me on that, it would be really helpful.</p>","contentLength":522,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Profiling and Optimising Go Code","url":"https://www.reddit.com/r/golang/comments/1i8vsrl/profiling_and_optimising_go_code/","date":1737726589,"author":"/u/greatdharmatma","guid":568,"unread":true,"content":"   submitted by   <a href=\"https://www.reddit.com/user/greatdharmatma\"> /u/greatdharmatma </a>","contentLength":37,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"TIL: large capacity slices/maps in sync.Pool can waste memory","url":"https://www.reddit.com/r/golang/comments/1i8vbyh/til_large_capacity_slicesmaps_in_syncpool_can/","date":1737725174,"author":"/u/lzap","guid":567,"unread":true,"content":"<p>When I was browsing Go standard library I found this:</p><pre><code>var bufferPool = sync.Pool{New: func() any { return new([]byte) }} func getBuffer() *[]byte { p := bufferPool.Get().(*[]byte) *p = (*p)[:0] return p } func putBuffer(p *[]byte) { // Proper usage of a sync.Pool requires each entry to have approximately // the same memory cost. To obtain this property when the stored type // contains a variably-sized buffer, we add a hard limit on the maximum buffer // to place back in the pool. // // See if cap(*p) &gt; 64&lt;&lt;10 { *p = nil } bufferPool.Put(p) }https://go.dev/issue/23199 </code></pre><p>When a large object, a byte slice in this code, is created and put to the pool it essentially wastes (\"leaks\") that memory if <strong>not used to its full capacity</strong>. There is a massive discussion around this at <a href=\"https://go.dev/issue/23199\">https://go.dev/issue/23199</a> and it is interesting read.</p><p>The code (from the  package) essentially prevents putting slices with capacity higher than  so it mitigates a situation when a very large log is created and then for the rest of the whole application lifetime it could not be used at all.</p><p>Hopefully,  which are being introduced in Go 1.24 this spring will help to solve this easily and the sync.Pool from the standard library can take advantage of this. Though I would share it, found it intersting. Cheers.</p>","contentLength":1284,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Logging in Golang Libraries","url":"https://www.reddit.com/r/golang/comments/1i8timw/logging_in_golang_libraries/","date":1737718968,"author":"/u/roma-glushko","guid":566,"unread":true,"content":"<p>Hey folks, I want to implement logging in my library without imposing any specific library implementation on my end users. I would like to support:</p><p>Basically, I want to be able to log my errors that happen in a background goroutines and potentially some other useful info in that library.</p>","contentLength":287,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}]}