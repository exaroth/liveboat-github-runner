{"id":"USgKoryE83j5SszZjyr68sh7DjLn4j6MWUagcNjQES7kQ1n2HXebXN4bJpBn8stf6LqSMrbny1unc4R1hi6qmf","title":"top scoring links : golang","displayTitle":"Reddit - Go","url":"https://www.reddit.com/r/golang/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/golang/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"JSON Schema to Go struct? or alternatives","url":"https://www.reddit.com/r/golang/comments/1k3sb3j/json_schema_to_go_struct_or_alternatives/","date":1745171560,"author":"/u/One_Poetry776","guid":416,"unread":true,"content":"<div><p>I'm  to Go, and I'm looking for the most idiomatic or recommended way to deal with a JSON Schema.</p><p>Is there a recommended way to create/generate a model (Go struct or else) based on JSON Schema?</p><pre><code>{ \"$schema\": \"http://json-schema.org/draft-04/schema#\", \"type\": \"object\", \"properties\": { \"spec\": { \"type\": \"object\" }, \"metadata\": { \"type\": \"object\", \"properties\": { \"labels\": { \"type\": \"object\", \"properties\": { \"abc\": { \"type\": \"boolean\" } }, \"required\": [ \"abc\" ] } }, \"required\": [ \"labels\" ] } }, \"required\": [ \"spec\", \"metadata\" ] } </code></pre><p><code>obj.LoadFromSchema(schemaFile).Metadata.Labels // {\"abc\": true}</code></p><p>Any insight will be helpful! Cheers</p></div>   submitted by   <a href=\"https://www.reddit.com/user/One_Poetry776\"> /u/One_Poetry776 </a>","contentLength":666,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"15 Reasons I Love Go","url":"https://appliedgo.net/why-go/","date":1745162816,"author":"/u/ChristophBerger","guid":420,"unread":true,"content":"<div><p>Go became known for its built-in concurrency and the absence of inheritance. But Go has many more advantages than these. I collected 15 of them here. Each of them might not seem world-shaking when looked at in isolation, but taken together, they build a unique composition of features that make Go the language we Gophers could love to pieces.</p></div><p>Use these reasons as a decision aid. They are unbiased, guaranteed! ;)</p><p><strong>Go's simplicity and lightweight syntax make it an easy language to learn and adopt, especially for newer programmers.</strong></p><p>Unlike some languages, Go avoids complex features and minimizes bells and whistles. Developing in Go feels like a breath of fresh air, enabling you to focus on solving problems rather than wrestling with the language itself.</p><p>Go's simplicity and “boringness” make it the language of choice for mixed teams. Quoting Jonathan Hall, “I can take a group of juniors and seniors and put them together, and they can be productive together, without having to spend months ramping up the juniors to understand all the arcane syntax in a language.”</p><p>If you're looking for a modern language that gets out of your way, Go is your choice.</p><p><strong>One of Go's standout features is its unbelievably fast compiler.</strong> We're talking seconds for even large codebases.</p><p>This super quick feedback loop improves developer productivity tremendously. You don't waste precious time waiting for bloated builds. Instead, you can iterate rapidly and use the time saved to add more value to your programs. It's almost like using an interpreted language.</p><p>For this reason alone, Go is worth adopting if you value fast development speed.</p><h2>3. Go collects your garbage</h2><p><strong>Go's built-in garbage collection eliminates the need for manual memory management, making Go far easier to program than languages like C and C++.</strong></p><p>As a developer, you don't have to worry about freeing memory or tracking allocations. The garbage collector handles all of that for you efficiently and without pause. Programming in Go feels like a relief, knowing you can focus on high-level app logic rather than nitty-gritty memory details.</p><p>This simplicity is one reason Go is loved by so many developers today!</p><h2>4. Concurrency made easier</h2><p><strong>Concurrency is baked into Go, unlike many other languages.</strong></p><p>Goroutines and channels make it substantially easier to write asynchronous code that fully utilize multicore processors. Go uses a model called CSP that makes concurrency much easier to reason about. Concurrency is the future as Moore's Law ends, and Go makes it more approachable.</p><p>If you need to build high-performance backends and systems, Go's excellent concurrency support is a must-have feature.</p><p><strong>Go was designed from day one for scalability.</strong></p><p>Its hyper-lightweight threads (a.k.a. goroutines) and built-in concurrency features allow Go programs to take advantage of multicore CPUs and distributed computing clusters. Go handles all the scheduling of goroutines behind the scenes, enabling you to focus on your program's logic and architecture.</p><p>Some of the world's most demanding and highest-traffic systems are built with Go, including Docker, Kubernetes, CloudFlare, and Dropbox. If you need scalability, check out Go!</p><p><strong>Go is a statically typed language like Java or C++.</strong></p><p>This means that variables have a fixed type known at compile time, rather than changing dynamically like in Python. Static typing catches errors earlier in the dev process and improves runtime performance since types don't need to be checked at runtime.</p><p>Moreover, static typing means better self-documentation. And Go's type inference keeps the syntax simple. You get safety and speed without the verbosity.</p><p>For any large program, static typing is a must-have feature.</p><p><strong>Go ships with a robust standard library, so you can be productive right away.</strong></p><p>The standard library provides high-quality implementations for things like HTTP servers, JSON parsing, cryptography, and more.</p><p>No need for stitching together external libraries or reinventing the wheel. The standard library is cross-platform and has bindings for Windows and Linux systems programming.</p><p>Whether building a web app, utility, or system tool, you can get quite far with Go's standard library.</p><p><strong>Even though Go is garbage collected, it provides low-level access to memory and pointers like C for high-performance use cases.</strong></p><p>You can pass pointers to avoid copying data and write superfast programs that run closer to the metal.</p><p>Go gives you the control when you need it. Unlike many managed languages, Go recognizes that sometimes you require expressive low-level access to memory and internals for the hottest code paths.</p><p>Go helps write your code with sympathy for the underlying platform to extract the highest performance.</p><h2>9. Interfaces over inheritance</h2><p><strong>Interfaces in Go provide powerful polymorphism and abstraction capabilities.</strong></p><p>You can hide concrete implementation details behind simple interfaces. Types in Go implicitly satisfy interfaces by implementing the required methods. This enables loose coupling between components.</p><p>Interfaces are everywhere in Go - , , and more, are part of the standard library and help abstract away technical details. They are a key part of idiomatic Go code to decouple software elements and enable clean architecture and design.</p><p><strong>Unlike some languages, Go compiles down to static machine code rather than bytecode or being purely interpreted.</strong></p><p>This means you can trivially build Go programs for many platforms like Linux, macOS, and Windows. There's no need for virtual machines or interpreters. The compiled executables can be linked into C programs too.</p><p>Go's cross-platform abilities make deploying and shipping software simple. A binary with no dependencies can run anywhere. Cross-compilation even allows compiling a binary on Windows for Linux, or on Linux for BSD, or on macOS for Windows, without the need for installing toolchains of the target platform. That's a massive advantage for ops and infrastructure management.</p><p><strong>I love Go's toolchain. It is fairly complete and well-thought-out, and it significantly improves the development experience as a whole, as well as in small details.</strong></p><p>For example, the built-in formatting tool  automatically styles your code consistently. No more arguing over tabs versus spaces, or the placement of curlies!</p><p>Dependency management, testing, benchmarking, profiling, and more, are built-in features.</p><p>The Go toolchain is a one-stop shop for all development tooling requirements. It integrates seamlessly into your development flow, so you can focus on programming rather than setup.</p><h2>12. Built-in testing and benchmarking</h2><p><strong>Testing and benchmarking are built right into Go with the go test command.</strong></p><p>Writing unit tests in Go is easy and idiomatic. The testing package provides everything you need for basic tests up to complex mocked objects and code coverage reporting. No need for learning a new domain language: Go tests are written in plain Go.</p><p>By making testing ergonomic, Go supports development practices like Test-Driven Design (TDD). And the benchmarking tools allow comparing different versions of your code for performance.</p><p>With Go, continuous unit testing quickly becomes second nature to you, leading to more confidence in your code and much fewer regressions.</p><h2>13. A thriving open-source ecosystem</h2><p><strong>Go has a thriving open-source ecosystem with high-quality packages for nearly any need.</strong></p><p>The rich standard library provides the foundations, but Go's package ecosystem adds incredible value on top.</p><p>Packages like Gin or Echo for web frameworks, sqlc, jet, bob, Ent, or GORM for database access, and Go SDKs for countless public APIs give you ready-made building blocks for the task at your hand. Sharing and discovery are easy with the central package repository at <a href=\"https://pkg.go.dev\" rel=\"noopener\" target=\"_blank\">pkg.go.dev</a>. And Go's package management handles dependencies seamlessly.</p><p>Bottom line: Go's fantastic community and ecosystem make development productive and enjoyable.</p><p>The language and standard library are carefully evolved between releases. New versions of Go work with older codebases seamlessly in nearly all cases. You can update to the latest Go confident your software will compile and run without issue.</p><p>Backward compatibility enables a stable base to build on. Technical debt and rewrite costs are avoided. Compared to other languages, Go takes compatibility seriously to support long-term projects. Knowing your code will continue working with new Go releases is a weight off your shoulders.</p><p>And it gets even better. Since Go 1.21, modules can request to be compiled with a particular version of the Go toolchain, and the installed Go command will happily download and use that toolchain. This is a level of backward and forward compatibility other languages can only dream of.</p><p>All dependencies of a build are fully determined. No dependency can change unless explicitly updated in the  file. Moreover, the Go Sum database guarantees that module versions are immutable, making it impossible to inject modified code into an existing version. Finally, Go doesn't allow dependencies to execute code during builds, limiting the attack surface significantly.</p><p>With these measures in place, and considering other security-friendly features of Go such as static linking, focus on clear code, static typing, and a rich standard library that reduces the need for using external modules, Go is an obvious choice for security-aware projects.</p><p>It took only three of these properties to have me sold on Go: The clear syntax and semantics, concurrency, and the fast compiler. I quickly learned to know and admire the rest of these properties during my first steps in Go. So even if you can only check off three of these properties as relevant for you, give Go a try.</p>","contentLength":9640,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1k3p1bj/15_reasons_i_love_go/"},{"title":"Hookah - literally passes the hook around","url":"https://www.reddit.com/r/golang/comments/1k3ihra/hookah_literally_passes_the_hook_around/","date":1745139787,"author":"/u/halal-goblin69","guid":417,"unread":true,"content":"<p>I've developed , a lightweight webhook router, with rule based routing!,</p>","contentLength":72,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"IDE Survey","url":"https://www.reddit.com/r/golang/comments/1k3ibvb/ide_survey/","date":1745139052,"author":"/u/rashtheman","guid":419,"unread":true,"content":"<div><p>What IDE do you use when developing Go applications and why?</p></div>   submitted by   <a href=\"https://www.reddit.com/user/rashtheman\"> /u/rashtheman </a>","contentLength":93,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Built my first microservices projects in Go using gRPC 🚀","url":"https://www.reddit.com/r/golang/comments/1k3fujw/built_my_first_microservices_projects_in_go_using/","date":1745128475,"author":"/u/Financial_Job_1564","guid":418,"unread":true,"content":"<p>Over the past few weeks, I've developed an interest in microservices and decided to learn how to build them using Go.</p><p>In this project, I've implemented auth, order, and product services, along with an API Gateway to handle client requests. I’m using gRPC for internal service-to-service communication. While I know the code is still far from production-ready, I’d really appreciate any feedback you might have.</p>","contentLength":413,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Say \"no\" to overly complicated package structures","url":"https://laurentsv.com/blog/2024/10/19/no-nonsense-go-package-layout.html","date":1745115640,"author":"/u/ldemailly","guid":421,"unread":true,"content":"<p>It’s a recurring question on gopher slack and discord: «How should I set up my go project repository?».\nUnfortunately, there are a  of both outdated and overly complicated blogs, sample repositories and old projects out there.</p><p>One key philosophy of Go, is keeping things simple. More code writing, less structuring ahead of time (before it’s actually needed).</p><p>The official guide on this topic is <a href=\"https://go.dev/doc/modules/layout\">go.dev/doc/modules/layout</a> - which you should read if you haven’t already, then come back here. Despite that reference (and maybe in part because of it) people still tend to over complicate. For instance it says</p><blockquote><p> packages or commands  benefit from splitting off some functionality into supporting packages.  it’s recommended placing such packages into a directory named internal; […] Since other projects cannot import code from our internal directory, we’re free to refactor its API and generally move things around without breaking external users.</p></blockquote><p>Emphasis on  and  is mine. And seems to be missed by many. 99% of people do not need  when, be real, most of what gets written will never be reused much and even if it is, don’t worry about over publishing. And the  is, in my opinion wrong. Initially, make something useful and don’t worry that it’ll get such great adoption that you’re stuck into maintaining your early layout forever, you’re not… (see semver point below too).</p><p>Likewise, you don’t need to use  when you only have 1 binary (or even a few and no library).</p><p>In general because a feature exists, doesn’t mean to have to use it (e.g ). Or because some people have a convention doesn’t mean you should follow (like your mom probably used to say “if they jump off a bridge… will you?”, remember? ).</p><p>By the way, stick to 0.x semver (another pet peeve of mine is the v2/v3/… in go) for as long as you can and document what you change and why, rather than under-publishing and forcing people to fork to access what they really need and you didn’t foresee.</p><p>So one infamous example of the nonsense is the fake “golang-standards” - see <a href=\"https://github.com/golang-standards/project-layout/issues/117\">github.com/golang-standards/project-layout/issues/117</a> and other closed issues for why it’s  a standard. This led folks to come up with a counter point at <a href=\"https://github.com/go-standard/project-layout\">github.com/go-standard/project-layout</a> (which I contributed a few additions/corrections) but also got flak for having the word “standard” in it… so here you go, below is  (based on decades of professional experience in many languages, including 7 years of go at top companies and OSS projects) - Some of the text comes from there:</p><p>Main package in the root is great, it makes for the shortest and cleanest install/run:</p><div><div><pre><code>go github.com/you/project@latest\n</code></pre></div></div><p>Which is typically the priority if you do have a CLI or server to ship. Pure libraries obviously have no main at the root.</p><p>If you do have both, you could move the main out of the way in a child directory (people like  but the  part is actually not needed) or move the library into a directory that will make importing and using it readable. Consider also you may have more than 1 library package to publish in which case  and  makes total sense and keep the top level for the main binary.</p><p>For many small to medium-sized projects, these are the only packages you need.</p><p>Just in case you do not know already, as a refresher,  is not a convention, it’s a feature of the go tool chain: code in or below such directory is importable only by code in the directory tree rooted at the parent of .</p><p>But you don’t need that, unless you’re shipping code to  of third party users and have a lot of code that can’t just be lower case not exported, yet used in many exported packages, you don’t need to hide your code… it’s not so precious or such a huge commitment.</p><p>Any package you put into a pkg directory can be moved to the root.\n is a very outdated convention from before  (and you saw what I think about internal/).</p><p>Some people think that having packages at the top, “clutters”, the directory. First what does get cluttered if you add unnecessary directory layers in every single import in dozen of files and possibly hundreds of dependencies… think about them! Second, feel free to move the various docs, ancillary files, etc to some subdirectory. Lastly what is ‘clutter’ really, navigation through the code probably comes through your “godoc” (the excellent <a href=\"https://pkg.go.dev/\">pkg.go.dev</a>, or your self hosted equivalent for private repositories).</p><p>Btw don’t get me started with repos that have dozens of packages and files and where to see what is going on without an IDE, you have to go: main.go -&gt; some other file -&gt; some init file -&gt; some start function -&gt; some other files… while all this could be in 1 or 2 places, easier to follow and find.</p><p>Those functions, types, and methods which you think belong in a separate  (or , or , or ) package simply don’t. Try to put them where they belong, probably near where they are used, or in their own meaningfully named package (e.g applog for your application logging utils).</p><p>But Laurent, I’m more comfortable with…</p><p>Let me guess, you have more experience writing Java, Python, Ruby, JavaScript, TypeScript, or C# than you do writing C, C++, or Perl. Please consider that package structuring is more an art than hard rules.</p><p>You can have more than 1 file in a package/directory in go. You don’t need to make a new package each time to separate code/types/… And the more packages the more chances to create a loop or having to later move code around. This being said, moving code around is good and an easy way to grow your code base - later, when needed.</p><p>Also please don’t make many files with only a few lines in them either, it makes it painful to look at your code.</p><p>There are lots of example of overly complicated repos. I’d give my own repos but they also evolved organically and aren’t actually that good/or simple, but here we go anyway:</p><p>Library + CLIs: that one is somewhat oddly set up as it has 2 libraries, one at the root where it started and a newer one, so not exactly best practices <a href=\"https://github.com/fortio/terminal\">github.com/fortio/terminal</a></p><p>This post is partially in response to what I see is over complication in many small projects, which isn’t to say it’s always right or applicable either, but if it gets folks to pause and consider, even to disagree. I think it’s mission accomplished.</p><p>Ping me on gopher slack (Laurent Demailly) or discord (_dl) if you disagree, have comments etc… or open an <a href=\"https://github.com/ldemailly/laurentsv/issues\">issue</a>\nor comment directly below if you’re on facebook.</p>","contentLength":6476,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/golang/comments/1k3cejk/say_no_to_overly_complicated_package_structures/"}],"tags":["dev","reddit","go"]}