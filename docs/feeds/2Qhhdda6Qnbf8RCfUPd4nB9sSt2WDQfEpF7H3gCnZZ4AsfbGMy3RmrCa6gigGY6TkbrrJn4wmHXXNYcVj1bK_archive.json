{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"How do popular Rust UI libraries compare? Iced vs Slint vs Egui","url":"https://www.reddit.com/r/rust/comments/1iavpit/how_do_popular_rust_ui_libraries_compare_iced_vs/","date":1737939640,"author":"/u/nikitarevenco","guid":509,"unread":true,"content":"<div><p>For creating a desktop application, I've come across 3 libraries which I'm thinking of using:</p><p>Which one would you use and why? If you have another library in mind I would love to hear it. </p></div>   submitted by   <a href=\"https://www.reddit.com/user/nikitarevenco\"> /u/nikitarevenco </a>","contentLength":223,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Learning Rust is like running a marathon — you need cardio!","url":"https://www.reddit.com/r/rust/comments/1iaqh5i/learning_rust_is_like_running_a_marathon_you_need/","date":1737925763,"author":"/u/orionwambert","guid":510,"unread":true,"content":"<p>I’ve started learning Rust, and I have to admit, it’s a serious challenge! After years of coding in more \"conventional\" languages (started with Java 7, then moved to JS/TS, Python, Dart…), I thought I was ready for anything. But Rust? It’s a whole different ball game! </p><p>Between memory management, the heap, the stack, borrowing, ownership, and all these concepts that feel out of the ordinary, I’m feeling a bit overwhelmed. This is my second attempt to dive into it seriously, and I have to say, it’s not as \"friendly\" as what I’m used to.</p><p>Do any seasoned Rustaceans have tips to help me keep my head above water? Any resources, tricks, or even personal experiences to help me tame this beast?</p><p>I’m determined to crack the Rust code, but a little boost would be much appreciated! </p>","contentLength":793,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[Media] Introducing: yeehaw! A TUI Framework with Batteries Included","url":"https://www.reddit.com/r/rust/comments/1ialadw/media_introducing_yeehaw_a_tui_framework_with/","date":1737914311,"author":"/u/bogz314","guid":513,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust’s worst feature* (spoiler: it’s BorrowedBuf, I hate it with passion)","url":"https://mina86.com/2025/rusts-worst-feature/","date":1737893558,"author":"/u/mina86ng","guid":511,"unread":true,"content":"<p><small>* available in Rust nightly.</small></p><p>There are several aspects of Rust that I’m&nbsp;not particularly fond of but the one that takes the cake is <a href=\"//doc.rust-lang.org/core/io/struct.BorrowedBuf.html\"></a> which I despise with passion. It’s a&nbsp;nightly feature which puts in question my extreme emotions about it. On the other hand it means there’s time to stop it from getting stabilised and figure out something better.</p><p>In this article I’ll describe the problem the feature addresses, the issues I&nbsp;have with the solution and describe some alternatives. As it turns out, things aren’t as easy as they seem on the first look.</p><p>Consider the  routine below which copies data between two I/O streams. On each iteration of the loop, it zero-initialises the buffer which wastes time considering that  will override the data. The compiler doesn’t know that and has no choice but to fill the array with zeros each time. Even an obvious optimisation of moving the buffer declaration outside of the loop isn’t available to the compiler.</p><pre>fn slow_copy(\n  mut rd: impl std::io::Read,\n  mut wr: impl std::io::Write,\n) -&gt; std::io::Result&lt;()&gt; {\n  loop {\n    let mut buf = [0; 4096];\n    let read = rd.read(&amp;mut buf)?;\n    if read == 0 {\n      break Ok(());\n    }\n    wr.write_all(&amp;buf[..read])?;\n  }\n}</pre><p>An attempt at a&nbsp;solution is to use  which makes it possible to declare a&nbsp;region of uninitialised memory. Some explicit pointer casting is necessary, but otherwise code using it is straightforward.</p><pre>use core::mem::MaybeUninit;\n\npub fn unsound_copy(\n    mut rd: impl std::io::Read\n    mut wr: impl std::io::Write,\n) -&gt; std::io::Result&lt;()&gt; {\n  loop {\n    let mut buf = [MaybeUninit::&lt;u8&gt;::uninit(); 4096];\n    // \n    // <i>For demonstration purposes only.</i>\n    let buf = unsafe {\n      &amp;mut *(&amp;mut buf as *mut [_] as *mut [u8])\n    };\n    let read = rd.read(buf)?;\n    if read == 0 {\n      break Ok(());\n    }\n    wr.write_all(&amp;buf[..read])?;\n  }\n}</pre><p>While replacing the array of zeros by an array of uninitialised values may work in specific circumstances, the code is unsound. Change to the compiler, its options, modification of unrelated parts of the code or using the function for a&nbsp;different  trait implementation may break the program in unpredictable ways.</p><p>The solution in nightly Rust is the  struct. It’s a&nbsp;bytes slice which remembers how much of it has been initialised. It doesn’t own the memory and operates on a&nbsp;borrowed buffer (hence the name). It can point at an array on the stack or a&nbsp;slice living on the heap (such as ’s spare capacity). A&nbsp;naïve use of the feature is the following:</p><pre>#![feature(core_io_borrowed_buf, read_buf)]\n\nuse core::io::BorrowedBuf;\nuse core::mem::MaybeUninit;\n\nfn almost_good_copy(\n    mut rd: impl std::io::Read,\n    mut wr: impl std::io::Write,\n) -&gt; std::io::Result&lt;()&gt; {\n  loop {\n    let mut buf = [MaybeUninit::uninit(); 4096];\n    let mut buf = BorrowedBuf::from(&amp;mut buf[..]);\n    rd.read_buf(buf.unfilled())?;\n    if buf.len() == 0 {\n      break Ok(());\n    }\n    wr.write_all(buf.filled())?;\n  }\n}</pre><h2>Issues with the </h2><p>While  appears to work as expected,  isn’t without its share of problems. I&nbsp;describe them below.</p><p>The  does not seamlessly integrate with existing Rust code. In fact quite the opposite. APIs need to support it explicitly. For example, many third-party  implementations do not provide  method. In its absence, the default version initialises the memory and calls  negating any potential benefits of .</p><p>Similarly, functions which take output slice as an argument — such as <a href=\"//docs.rs/rand/0.8.5/rand/trait.RngCore.html\">’s </a> — could benefit from being able to write to uninitialised memory. However, to offer that benefit, they need to be changed to support . A&nbsp;motivated programmer can try adding necessary support to actively maintained packages, like , but what if one is stuck at an older version of the crate or deals with apparently abandoned crates like  or . To support those cases, forking would be necessary leading the programmer towards deeper circles of dependency hell.</p><p>Then again, should functions such as  integrate with  in the first place instead of taking an  argument? The issue with the latter is that there’s no safe way to convert  into .<a href=\"https://mina86.com/2025/rusts-worst-feature/#f1\"></a> As such, users who so far happily used such functions with regular initialised buffers would need convoluted incantation to make their previously straightforward code to compile. Meanwhile, creating  is somewhat convenient and can be done from initialised and uninitialised buffers alike.</p><p>In addition to , the  crate offers <a href=\"//docs.rs/rand/latest/rand/trait.Rng.html#method.fill\">a&nbsp; method</a> which fills a&nbsp;generic slice of integers with random data. It could easily work with  except that the struct works on  slices only. As a&nbsp;result, a&nbsp;crate which deals with different types cannot consistently use .</p><p>I&nbsp;don’t know the reasons why  is not generic. It’s possible that its design focused on addressing the the  trait use case only. Complications around dealing with  types could have been a&nbsp;contributing factor. However, even then the type could be generic on  types.</p><p> being optional brings another problem. Without full understanding of the behaviour and interactions of the  type, it’s easy to misuse it such as in . One can be excused from assuming that the function eliminates unnecessary initialisation. It declares an uninitialised region, wraps it in  and reads data into it. Even inspection of the assembly output <a href=\"//rust.godbolt.org/z/dvaPqz4co\">shows lack of the  call</a>.</p><p>Alas, while  avoids memory initialisation when reading data from a&nbsp;, it wastes time zeroing the buffer when, for example, decompressing data with help of <a href=\"//crates.io/crates/flate2\"> crate</a> (which does not offer custom  method) effectively becoming a&nbsp;.</p><p>Unless the underlying type is known, the programmer must assume that  may resort to filling the memory. The proper use of  is to construct it only once so that it can remember that the memory has been initialised.</p><pre>#![feature(core_io_borrowed_buf, read_buf)]\n\nuse core::io::BorrowedBuf;\nuse core::mem::MaybeUninit;\n\nfn copy(\n  mut rd: impl std::io::Read,\n  mut wr: impl std::io::Write,\n) -&gt; std::io::Result&lt;()&gt; {\n  let mut buf = [MaybeUninit::uninit(); 4096];\n  let mut buf = BorrowedBuf::from(&amp;mut buf[..]);\n  loop {\n    buf.clear();\n    rd.read_buf(buf.unfilled())?;\n    if buf.len() == 0 {\n      break Ok(());\n    }\n    wr.write_all(buf.filled())?;\n  }\n}</pre><p>With ’s complexity it’s not hard to imagine why people might use it in inefficient way. The struct is harder to understand than the unsound casting in . This may lead people to use the more straightforward option even if it’s not correct. An analogy to a&nbsp; with its contents and spare capacity partially helps — a&nbsp; has analogous filled and unfilled parts — but is an oversimplified view. A&nbsp; is also split into initialised and uninitialised parts. The documentation visualises it as follows:</p><table><tbody></tbody></table><p>There are reasons for this madness. Consider loop in the  function above. If  only knew how much of it was filled, each call to  would lose the information about memory being initialised. In the default implementation of  it would need to unnecessarily zero the whole buffer. Separately storing information about how much of the buffer has been filled and initialised, let the type avoid double-initialisation of memory.</p><p>As an aside, I find modelling  as divided into filled and spare capacity with spare capacity further divided into initialised and uninitialised as more intuitive. Leaning into the analogy of  is in my opinion more natural and it helps by reinforcing terminology used in existing parts of the language rather than introducing new models.</p><table><tbody></tbody></table><p>Having looked at issues with , let’s consider what people actually want.<a href=\"https://mina86.com/2025/rusts-worst-feature/#f2\"></a> The easiest mental model is that uninitialised memory stores arbitrary data, unknown unless accessed. To achieve such semantics, the uninitialised memory would need to be . A&nbsp;frozen region becomes safe to read and can be accessed through regular Rust references. With freezing operation available, the buffer definition in the copying routine could be turned into something like:</p><pre>  let mut buf = [MaybeUninit::uninit(); 4096];\n  // SAFETY: u8 has no invalid bit patterns.\n  let buf = unsafe {\n    MaybeUninit::slice_freeze_mut(&amp;mut buf)\n  };</pre><pre>  let buf = MaybeUninit::frozen();\n  // SAFETY: u8 has no invalid bit patterns.\n  let mut buf: [u8; 4096] = unsafe { buf.assume_init() };</pre><p>Unsafe blocks are required to account for invalid bit patterns. With a&nbsp;trait like <a href=\"//docs.rs/bytemuck/latest/bytemuck/trait.AnyBitPattern.html\"></a>, a&nbsp;safe versions could exist. Either of those alternatives would require no new methods on the  trait and would work without any modifications on methods such as ’s .</p><h2>Why can’t we have what we want?</h2><p>Reading uninitialised memory is hardly an issue when analysing things on hardware level. So long as a&nbsp;memory address is mapped with proper permissions, accessing data from it will always produce some value. There’s no undefined behaviour there.<a href=\"https://mina86.com/2025/rusts-worst-feature/#f3\"></a> In fact, in typical Linux environment all newly allocated anonymous pages are zero-initialised.<a href=\"https://mina86.com/2025/rusts-worst-feature/#f4\"></a></p><figure><pre>tautology:\n  cmp  BYTE PTR [rdi], 0\n  je   tautology_ok\n  cmp  BYTE PTR [rdi], 0\n  jne  tautology_ok\n  mov  al, 0\n  ret\ntautology_ok:\n  mov  al, 1\n  ret</pre><figcaption>An x86 assembly function which checks whether value in memory is zero or non-zero. This seemingly tautological test can fail when operating on a&nbsp;memory page marked with  and the kernel changes the mapping in between the two memory reads.</figcaption></figure><p>Unfortunately, even when looking from the point of view of machine code, this analysis isn’t complete…</p><h3>Giving advice about use of memory</h3><p> flag of the <a href=\"//man7.org/linux/man-pages/man2/madvise.2.html\"></a> system call allows user space to advise the kernel that (until next write) it no longer cares about contents of specified anonymous pages. This optimisation enables the kernel to discard those pages without swapping them to disk. While the advice is in effect, the user space  access the memory, but has no guarantee whether it’ll read the old values or zeros. Even code written directly in assembly language, like the  function on the right can result in unexpected behaviour.</p><p>This isn’t a&nbsp;theoretical concern either. jemalloc, a&nbsp;somewhat popular memory allocator, uses  when memory is freed. As a&nbsp;result, new allocations returned from the allocator may point to region of memory where the  advice is in effect. Nicholas Ormrod, in his <a href=\"//youtu.be/kPR8h4-qZdk?t=1150\">talk about C++  at Facebook</a>, describes how interaction between jemalloc,  and reading uninitialised memory resulted in outages.</p><p>To prevent this issue, the proposed  function would need to write into each page of the slice to make sure the kernel notices that the program cares about contents of the page again. This could be a simple loop stepping 4 KiB at a time and look something like the following:</p><pre>pub unsafe fn slice_freeze_mut&lt;T&gt;(\n  slice: &amp;mut [MaybeUninit&lt;T&gt;]\n) -&gt; &amp;mut [T] {\n  const PAGE_SIZE: usize = 4096;\n  let ptr = slice.as_mut_ptr() as *mut _;\n  let len = slice.len() * size_of::&lt;T&gt;();\n  // SAFETY: It’s always safe to split MU object into MU bytes.\n  let bytes: &amp;mut [MaybeUninit&lt;u8&gt;] = unsafe {\n    core::slice::from_raw_parts(ptr, len);\n  };\n  for el in bytes.iter_mut().step_by(PAGE_SIZE) {\n    let p = el.as_mut_ptr();\n    // SAFETY: Unsafe without language semantics change\n    // since we’re reading uninitialised byte.\n    unsafe { p.write_volatile(p.read()) };\n  }\n  // SAFETY: Caller promises that T has no invalid bit patterns,\n  // but this is still unsafe without language semantics change\n  // since we haven’t initialised all the bytes.\n  unsafe { &amp;mut *(slice as *mut _ as *mut [T]) }\n}</pre><p>Unfortunately, this would hardly be the no-operation that people expect from writing into uninitialised memory. It would be an improvement over a full initialisation and would address some issues with  but would do that at the cost of unavoidable page touching.</p><p>It may seem that the second form — the <code>MaybeUninit::frozen().assume_init()</code> variant — which creates frozen buffer directly on stack could be easier to optimise. The compiler controls the stack and unless it issues , no stack pages will be marked . Unfortunately it’s not clear that always hold true. For example, with async programming the stack lives God-knows-where and there may be other corner cases that would need to be considered.</p><p>I&nbsp;started this article with a&nbsp;promise of some alternatives to  and yet, as I&nbsp;conclude it, no working alternative is presented. Indeed, this is perhaps what frustrates me the most about the . On the face of it, writing data into uninitialised memory is a&nbsp;feature with an obvious solution, but it doesn’t take long before all the obvious solutions clash with Rust’s safety requirements.</p><p>So what’s a&nbsp;lowly programmer to do? Donald Knuth is often quoted as stating that ‘premature optimisation is the root of all evil’. True to that adage, in most cases it’s safe to pay the price of the memory initialisation. I/O operations usually take orders of magnitude more time so the time saved not initialising the memory is often negligible.</p><p>But there is more to Knuth’s quote:</p><blockquote><p>We  forget about small efficiencies, say about 97% of the time: premature optimisation is the root of all evil.</p><p>Yet we should not pass up our opportunities in that critical 3%. A&nbsp;good programmer will not be lulled into complacency by such reasoning, he will be wise to look carefully at the critical code; but only after that code has been identified.<a href=\"https://mina86.com/2025/rusts-worst-feature/#f5\"></a></p></blockquote><p>For the remaining 3%, the options now are somewhat bleak and depend on the particular code base. They may require switching to nightly compiler, patching third-party crates, going straight to doing unsafe syscalls (e.g. <a href=\"//man7.org/linux/man-pages/man2/read.2.html\"></a>) or isolating critical code paths and writing them in C.</p><p>And while we deal with the lack of ideal solution for writing to uninitialised memory, maybe someone will figure out some alternative fast and ergonomic approach.</p><p><a href=\"https://mina86.com/2025/rusts-worst-feature/#b1\">1</a> The reference conversion itself is safe since all possible values of type  are valid values of type  and both those types have the same layout. However, the latter allows writing arbitrary data into the object which may result in invalid representation of  (see <a href=\"//play.rust-lang.org/?version=stable&amp;mode=debug&amp;edition=2021&amp;gist=72ca09295e9b98dfdd85a3af573aa0b9\">playground demonstration</a>). With interior mutability, even converting shared references may lead to issues.</p><p><a href=\"https://mina86.com/2025/rusts-worst-feature/#b2\">2</a> I&nbsp;am aware that I&nbsp;presumptuously speak for everyone. However, I&nbsp;do believe that alternatives presented here, if they existed, would be favoured by everyone and that includes contributors to the  struct. As I&nbsp;discuss later, the type is the way it is not because that’s what anyone finds appealing but due to other constraints.</p><p><a href=\"https://mina86.com/2025/rusts-worst-feature/#b3\">3</a> Semantics that reading uninitialised memory has arbitrary but consistent value can be useful in practice. Briggs and Torczon describe in <a href=\"//doi.org/10.1145/176454.176484\">An efficient representation for sparse sets</a> an algorithm which is built on such semantics.</p><p><a href=\"https://mina86.com/2025/rusts-worst-feature/#b3\">4</a> The atypical environment is µClinux which runs on platforms without memory management unit (MMU). <a href=\"//www.kernel.org/doc/Documentation/admin-guide/mm/nommu-mmap.rst\">It supports  option</a> which skips zeroing of the memory region. However, even with that flag, allocated pages maintain consistent state.</p><p><a href=\"https://mina86.com/2025/rusts-worst-feature/#b5\">5</a> Donald E. Knuth. 1974. Structured Programming with  Statements. ACM Computing Surveys. Vol. 6, Issue 4 (Dec. 1974), 261–301. <a href=\"//doi.org/10.1145/356635.356640\">doi:10.1145/356635.356640</a>.</p>","contentLength":14955,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1iad0lk/rusts_worst_feature_spoiler_its_borrowedbuf_i/"},{"title":"Release of ureq 3.0.0","url":"https://www.reddit.com/r/rust/comments/1iab9x8/release_of_ureq_300/","date":1737887633,"author":"/u/LovelyKarl","guid":512,"unread":true,"content":"<p><a href=\"https://crates.io/crates/ureq\">ureq 3.0.0</a> is released replacing the 2.x branch (which is still maintained).</p><p>3.x is a ground up rewrite with underpinnings of Sans-IO and retains . The library keeps most of the functionality of 2.x, but pivots to use the common <a href=\"https://crates.io/crates/http\"></a> crate as basis for the API.</p><p>The goals for ureq remain largely the same: A simple, sync, HTTP/1.1 client with a minimum number of dependencies.</p><p><a href=\"https://docs.rs/ureq/3.0.0/ureq/unversioned/transport/index.html\"></a> and <a href=\"https://docs.rs/ureq/3.0.0/ureq/unversioned/resolver/index.html\"></a> are now pluggable, meaning it's possible to use alternative socket implementations, TLS or name resolvers separate to the main project.</p><p>Happy to answer any questions.</p>","contentLength":541,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Prototyping in Rust","url":"https://corrode.dev/blog/prototyping/","date":1737885919,"author":"/u/EightLines_03","guid":508,"unread":true,"content":"<p>Programming is an iterative process - as much as we would like to come up with the perfect solution from the start, it rarely works that way.</p><p>Good programs often start as quick prototypes.\nThe bad ones stay prototypes, but the best ones evolve into production code.</p><p>Whether you’re writing games, CLI tools, or designing library APIs, prototyping helps tremendously in finding the best approach before committing to a design.\nIt helps reveal the patterns behind more idiomatic code.</p><p>For all its explicitness, Rust is surprisingly ergonomic when iterating on ideas. Contrary to popular belief, it is a joy for building prototypes.</p><p>You don’t need to be a Rust expert to be productive - in fact, many of the techniques we’ll discuss specifically help you  Rust’s more advanced features.\nIf you focus on simple patterns and make use of Rust’s excellent tooling, even less experienced Rust developers can quickly bring their ideas to life.</p><div><ul><li>How to prototype rapidly in Rust while keeping its safety guarantees</li><li>Practical techniques to maintain a quick feedback loop</li><li>Patterns that help you evolve prototypes into production code</li></ul></div><p>The common narrative goes like this:</p><blockquote><p>When you start writing a program, you don’t know what you want and you change your mind pretty often.\nRust pushes back when you change your mind because the type system is very strict.\nOn top of that, getting your idea to compile takes longer than in other languages, so the feedback loop is slower.</p></blockquote><p>I’ve found that developers not yet too familiar with Rust often share this preconception.\nThese developers stumble over the strict type system and the borrow checker while trying to sketch out a solution.\nThey believe that with Rust you’re either at 0% or 100% done (everything works and has no undefined behavior) and there’s nothing in between.</p><p>Here are some typical misbeliefs:</p><ol><li>“Memory safety and prototyping just don’t go together.”</li><li>“Ownership and borrowing take the fun out of prototyping.”</li><li>“You have to get all the details right from the beginning.”</li><li>“Rust always requires you to handle errors.”</li></ol><p><strong>It turns out you can avoid all of these pitfalls and still get a lot of value from prototyping in Rust.</strong></p><p>If you’re happy with a scripting language like Python, why bother with Rust?</p><p>That’s a fair question!\nAfter all, Python is known for its quick feedback loop and dynamic type system, and you can always rewrite the code in Rust later.</p><p>Yes, Python is a great choice for prototyping.\nBut I’ve been a Python developer for long enough to know that I’ll very quickly grow out of the “prototype” phase\n-– which is when the language falls apart for me.</p><p>One thing I found particularly challenging in Python was hardening my prototype into a robust, production-ready codebase.\nI’ve found that the really hard bugs in Python are often type-related: deep down in your call chain, the program crashes because you just passed the wrong type to a function.\nBecause of that, I find myself wanting to switch to something more robust as soon as my prototype starts to take shape.</p><p>The problem is that switching languages is a  undertaking – especially mid-project.\nMaybe you’ll have to maintain two codebases simultaneously for a while.\nOn top of that, Rust follows different idioms than Python, so you might have to rethink the software architecture.\nAnd to add insult to injury, you have to change build systems, testing frameworks, and deployment pipelines as well.</p><p>Wouldn’t it be nice if you could use a single language for prototyping and production?</p><p>Using a single language across your entire project lifecycle is great for productivity.\nRust scales from proof-of-concept to production deployment and that eliminates costly context switches and rewrites.\nRust’s strong type system catches design flaws early, but we will see how it also provides pragmatic escape hatches if needed.\nThis means prototypes can naturally evolve into production code;\neven the first version is often production-ready.</p><p>But don’t take my word for it. Here’s what Discord had to say about migrating from Go to Rust:</p><blockquote><p>Remarkably, we had only put very basic thought into optimization as the Rust version was written. Even with just basic optimization, Rust was able to outperform the hyper hand-tuned Go version. This is a huge testament to how easy it is to write efficient programs with Rust compared to the deep dive we had to do with Go.\n– From <a href=\"https://discord.com/blog/why-discord-is-switching-from-go-to-rust\">Why Discord is switching from Go to Rust</a></p></blockquote><p>If you start with Rust, you get a lot of benefits out of the box:\na robust codebase, a strong type system, and built-in <a href=\"https://doc.rust-lang.org/clippy/\">linting</a>.</p><p>All without having to change languages mid-project!\nIt saves you the context switch between languages once you’re done with the prototype.</p><img src=\"https://corrode.dev/blog/prototyping/flow.svg\" alt=\"flow\"><p>Python has a few good traits that we can learn from:</p><ul><li>changing your mind is easy</li><li>it’s simple to use (if you ignore the edge cases)</li><li>it’s easy to experiment and refactor</li><li>you can do something useful in just a few lines</li></ul><p>The goal is to get as close to that experience in Rust as possible while staying true to Rust’s core principles.\nLet’s make changes quick and painless and rapidly iterate on our design without painting ourselves into a corner.\n(And yes, there will still be a compilation step, but hopefully, a quick one.)</p><p>Even while prototyping, the type system is not going away.\nThere are ways to make this a blessing rather than a curse.</p><p>Use simple types like , ,  in the beginning.\nWe can always make things more complex later if we have to – the reverse is much harder.</p><p>Here’s a quick reference for common prototype-to-production type transitions:</p><table><thead><tr></tr></thead><tbody><tr><td>When you need to avoid allocations or store string data with a clear lifetime</td></tr><tr><td>When the owned vector becomes too expensive to clone or you can’t afford the heap</td></tr><tr><td>When  becomes a bottleneck or you don’t want to deal with heap allocations</td></tr><tr><td>When the reference counting overhead becomes too expensive or you need mutability</td></tr><tr><td>When you can guarantee exclusive access and don’t need thread safety</td></tr></tbody></table><p>These owned types sidestep most ownership and lifetime issues, but they do it by allocating memory on the heap - just like Python or JavaScript would.</p><p>You can always refactor when you actually need the performance or tighter resource usage, but chances are you won’t.</p><p>Rust is a statically, strongly typed language.\nIt would be a deal-breaker to write out all the types all the time if it weren’t for Rust’s type inference.</p><p>You can often omit (“elide”) the types and let the compiler figure it out from the context.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>This is a great way to get started quickly and defer the decision about types to later.\nThe system scales well with more complex types, so you can use this technique even in larger projects.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Here’s a more complex example which shows just how powerful Rust’s type inference can be:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>It’s not easy to visualize the structure of  in your head, but Rust can figure it out.</p><p>You probably already know about the <a href=\"https://play.rust-lang.org\">Rust Playground</a>.\nThe playground doesn’t support auto-complete, but it’s still great when you’re on the go or you’d like to share your code with others.</p><p>I find it quite useful for quickly jotting down a bunch of functions or types to test out a design idea.</p><p>It’s okay to use  in the early stages of your project.\nAn explicit  is like a stop sign that tells you “here’s something you need to fix later.”\nYou can easily grep for  and replace it with proper error handling later when you polish your code.\nThis way, you get the best of both worlds: quick iteration cycles and a clear path to robust error handling.\nThere’s also a <a href=\"https://rust-lang.github.io/rust-clippy/master/index.html#unwrap_used\">clippy lint</a> that points out all the s in your code.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>See all those unwraps?\nTo more experienced Rustaceans, they stand out like a sore thumb – and that’s a good thing!</p><p>Compare that to languages like JavaScript which can throw exceptions your way at any time.\nIt’s much harder to ensure that you handle all the edge-cases correctly.\nAt the very least, it costs time. Time you could spend on more important things.</p><p>While prototyping with Rust, you can safely ignore error handling and focus on\nthe happy path without losing track of improvement areas.</p><p>I like to add <a href=\"https://github.com/dtolnay/anyhow\"></a> pretty early during the prototyping phase,\nto get more fine-grained control over my error handling.\nThis way, I can use  and  to quickly add more context to my errors without losing momentum.\nLater on, I can revisit each error case and see if I can handle it more gracefully.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>The great thing about  is that it’s a solid choice for error handling in production code as well,\nso you don’t have to rewrite your error handling logic later on.</p><p>There is great IDE support for Rust.</p><p>IDEs can help you with code completion and refactoring, which keep you in the flow and help you write code faster.\nAutocompletion is so much better with Rust than with dynamic languages because the type system gives the IDE a lot more information to work with.</p><p>As a corollary to the previous section, be sure to use enable inlay hints (or inline type hints) in your editor.\nThis way, you can quickly see the inferred types right inside your IDE and make sure the types match your expectations.\nThere’s support for this in most Rust IDEs, including <a href=\"https://www.jetbrains.com/help/rust/viewing-reference-information.html#inlay-hints\">RustRover</a> and <a href=\"https://code.visualstudio.com/docs/typescript/typescript-editing#_inlay-hints\">Visual Studio Code</a>.</p><p>Rust is not a scripting language; there is a compile step!</p><p>However, for small projects, the compile times are negligible.\nUnfortunately, you have to manually run  every time you make a change\nor use <a href=\"https://rust-analyzer.github.io/\">rust-analyzer</a> in your editor to get instant feedback.</p><p>To fill the gap, you can use external tools like <a href=\"https://github.com/Canop/bacon\"></a> which automatically recompiles and runs your code whenever you make a change.\nThis way, you can get  the same experience as with a REPL in, say, Python or Ruby.</p><pre data-lang=\"sh\"><code data-lang=\"sh\"></code></pre><p>And just like that, you can get some pretty compilation output alongside your code editor.</p><p>Oh, and in case you were wondering,  was another popular tool for\nthis purpose, but it’s since been <a href=\"https://github.com/watchexec/cargo-watch#maintenance\">deprecated</a>.</p><p>Did you know that cargo can also run scripts?</p><p>For example, put this into a file called :</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Now you can make the file executable with  and run it with  which it will compile and execute your code!\nThis allows you to quickly test out ideas without having to create a new project.\nThere is support for dependencies as well.</p><p>At the moment,  is a nightly feature, but it will be released soon on stable Rust.\nYou can read more about it in the <a href=\"https://rust-lang.github.io/rfcs/3424-cargo-script.html\">RFC</a>.</p><p>You have to try really really hard to write slow code in Rust.\nUse that to your advantage: during the prototype phase, try to keep the code as simple as possible.</p><p>Especially experienced developers coming from C or C++ are tempted to optimize too early.</p><p>Rust makes code perform well by default - you get memory safety at virtually zero runtime cost. When developers try to optimize too early, they often run up against the borrow checker by using complex lifetime annotations and intricate reference patterns in pursuit of better performance.\nThis leads to harder-to-maintain code that may not actually run faster.</p><p>Resist the urge to optimize too early!\nYou will thank yourself later. </p><p>I find that printing values is pretty handy while prototyping.\nIt’s one less context switch to make compared to starting a debugger.</p><p>Most people use  for that, but <a href=\"https://doc.rust-lang.org/std/macro.dbg.html\"></a> has a few advantages:</p><ul><li>It prints the file name and line number where the macro is called. This helps you quickly find the source of the output.</li><li>It outputs the expression as well as its value.</li><li>It’s less syntax-heavy than ; e.g.  vs. .</li></ul><p>Where  really shines is in recursive functions or when you want to see the intermediate values during an iteration:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>The output is nice and tidy:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Quite frankly, the type system is one of the main reasons I love Rust.\nIt feels great to express my ideas in types and see them come to life.\nI would encourage you to heavily lean into the type system during the prototyping phase.</p><p>In the beginning, you won’t have a good idea of the types in your system.\nThat’s fine!\nStart with  and quickly sketch out solutions and gradually add constraints to model the business requirements.\nDon’t stop until you find a version that feels just right.\nYou know you’ve found a good abstraction when your types “click” with the rest of the code. \nTry to build up a vocabulary of concepts and own types which describe your system.</p><p>Wrestling with Rust’s type system might feel slower at first compared to more dynamic languages, but it often leads to fewer iterations overall.\nThink of it this way: in a language like Python, each iteration might be quicker since you can skip type definitions, but you’ll likely need more iterations as you discover edge cases and invariants that weren’t immediately obvious.\nIn Rust, the type system forces you to think through these relationships up front. Although each iteration takes longer, you typically need fewer of them to arrive at a robust solution.</p><p>This is exactly what we’ll see in the following example.</p><p>Say you’re modeling course enrollments in a student system. You might start with something simple:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>But then requirements come in: some courses are very popular.\nMore students want to enroll than there are spots available,\nso the school decides to add a waitlist.</p><p>Easy, let’s just add another boolean flag!</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>The problem is that both boolean flags could be set to !\nThis design allows invalid states where a student could be both enrolled and waitlisted.</p><p>Think for a second how we could leverage Rust’s type system to make this impossible…</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Now we have a clear distinction between an active enrollment and a waitlisted enrollment.\nWhat’s better is that we encapsulate the details of each state in the enum variants.\nWe can never have someone on the waitlist without a position in said list.</p><p>Just think about how much more complicated this would be in a dynamic language\nor a language that doesn’t support tagged unions like Rust does.</p><p>In summary, iterating on your data model is the crucial part of any prototyping phase.\nThe result of this phase is not the code, but a <em>deeper understanding of the problem domain itself</em>.\nYou can harvest this knowledge to build a more robust and maintainable solution.</p><p>It turns out you can model a surprisingly large system in just a few lines of code.</p><p>So, never be afraid to play around with types and refactor your code as you go.</p><p>One of the cornerstones of prototyping is that you don’t have to have all the answers right away.\nIn Rust, I find myself reaching for the <a href=\"https://doc.rust-lang.org/std/macro.todo.html\"></a> macro to\nexpress that idea.</p><p>I routinely just scaffold out the functions or a module and then fill in the blanks later.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>We did not do much here, but we have a clear idea of what the program should do.\nNow we can go and iterate on the design.\nFor example, should  take a reference to the data?\nShould we create a struct to hold the data and the processing logic?\nHow about using an iterator instead of a vector?\nShould we introduce a trait to support algorithms for processing the data?</p><p>These are all helpful questions that we can answer without having to worry about the details of the implementation.\nAnd yet our code is typesafe and compiles, and it is ready for refactoring.</p><p>On a related note, you can use the <a href=\"https://doc.rust-lang.org/std/macro.unreachable.html\"></a> macro to mark branches of your code that should never be reached.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>This is a great way to document your assumptions about the code.\nThe result is the same as if you had used , but it’s more explicit about the fact that this branch should never be reached:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Note that we added a message to the  macro to make it clear what the assumption is.</p><p>Another way to document your assumptions is to use the <a href=\"https://doc.rust-lang.org/std/macro.assert.html\"></a> macro.\nThis is especially useful for invariants that should hold true at runtime.</p><p>For example, the above code could be rewritten like this:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>During prototyping, this can be helpful to catch logic bugs early on without having to write a lot of tests\nand you can safely carry them over to your production code.</p><p>Consider using\n<a href=\"https://doc.rust-lang.org/std/macro.debug_assert.html\"></a> for\nexpensive invariant checks that should only run in test/debug builds.</p><p>Chances are, you won’t know which parts of your application should be generic in the beginning.\nTherefore it’s better to be conservative and use concrete types instead of generics until necessary.</p><p>So instead of writing this:</p><p>If you need the same function for a different type, feel free to just copy and paste the function and change the type.\nThis way, you avoid the trap of settling on the wrong kind of abstraction too early.\nMaybe the two functions only differ by type signature for now, but they might serve a completely different purpose.\nIf the function is not generic from the start, it’s easier to remove the duplication later.</p><p>Only introduce generics when you see a clear pattern emerge in multiple places.\nI personally avoid generics up until the very last moment. I want to feel the “pain” of duplication logic before I abstract it away.\nIn 50% of the cases, I find that the problem is not missing generics, but that there’s a better algorithm or data structure that solves the problem more elegantly.</p><p>Also avoid “fancy” generic type signatures:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Yes, this allows you to pass in a  or a , but at the cost of readability.</p><p>Just use an owned type for your first implementation:</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Chances are, you won’t need the flexibility after all.</p><p>In summary, generics are powerful, but they can make the code harder to read and write.\nAvoid them until you have a clear idea of what you’re doing.</p><p>One major blocker for rapid prototyping is Rust’s ownership system.\nIf the compiler constantly reminds you of borrows and lifetimes it can ruin your flow.\nFor example, it’s cumbersome to deal with references when you’re just trying to get something to work.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>This code doesn’t compile because the references are not valid outside of the function.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>A simple way around that is to <a href=\"https://corrode.dev/blog/lifetimes\">avoid lifetimes altogether</a>.\nThey are not necessary in the beginning.\nUse owned types like  and .\nJust  wherever you need to pass data around.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>If you have a type that you need to move between threads (i.e. it needs to be ), you can use an  to get around the borrow checker.\nIf you’re worried about performance, remember that other languages like Python or Java do this implicitly behind your back.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>If you feel like you have to use  too often, there might be a design issue.\nFor example, you might be able to avoid sharing state between threads.</p><p> is your best friend while prototyping.</p><p>Stuff your code in there – no need for modules or complex organization yet. This makes it easy to experiment and move things around.</p><h4><a href=\"https://corrode.dev/blog/prototyping/#first-draft-everything-in-main-rs\" aria-label=\"Anchor link for: first-draft-everything-in-main-rs\">First draft: everything in main.rs</a></h4><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>Once you have a better feel for your code’s structure, Rust’s  keyword becomes a handy tool for sketching out potential organization. You can nest modules right in your main file.</p><pre data-lang=\"rust\"><code data-lang=\"rust\"></code></pre><p>This inline module structure lets you quickly test different organizational patterns.\nYou can easily move code between scopes with cut and paste, and experiment with different APIs and naming conventions.\nOnce a particular structure feels right, you can move modules into their own files.</p><p>The key is to keep things simple until it calls for more complexity.\nStart flat, then add structure incrementally as your understanding of the problem grows.</p><p>Allow yourself to ignore some of the best practices for production code for a while.</p><p>It’s possible, but you need to switch off your inner critic who always wants to write perfect code from the beginning.\nRust enables you to comfortably defer perfection.\nYou can make the rough edges obvious so that you can sort them out later.\nDon’t let perfect be the enemy of good.</p><p>One of the biggest mistakes I observe is an engineer’s perfectionist instinct to jump on minor details which don’t have a broad enough impact to warrant the effort.\nIt’s better to have a working prototype with a few rough edges than a perfect implementation of a small part of the system.</p><p>Remember: you are exploring!\nUse a coarse brush to paint the landscape first.\nTry to get into a flow state where you can quickly iterate.\nDon’t get distracted by the details too early.\nDuring this phase, it’s also fine to throw away a lot failed attempts.</p><p>There’s some overlap between prototyping and “<a href=\"https://www.youtube.com/watch?v=33FG6O3qejM\">easy Rust</a>.”</p><p>The beauty of prototyping in Rust is that your “rough drafts” have the same memory safety and performance as polished code.\nEven when I liberally use , stick everything in , and reach for owned types everywhere, the resulting code\nis on-par with a Python prototype in reliability, but outperforms it easily.\nThis makes it perfect for experimenting with real-world workloads, even before investing time in proper error handling.</p><p>Let’s see how Rust stacks up against Python for prototyping:</p><table><tbody><tr><td>Initial Development Speed</td><td>✓ Very quick to write initial code✓ No compilation step<p>✓ Dynamic typing speeds up prototyping</p>✓ File watchers available</td><td>⚠️ Slightly slower initial development✓ Type inference helps provide quick feedback</td></tr><tr><td>✓ Batteries included✓ Rich ecosystem</td><td>❌ Smaller standard library✓ Growing ecosystem of high-quality crates</td></tr><tr><td>❌ Need extensive testing to catch type errors❌ Bad performance might require extra work or rewrite in another language</td><td>✓ Minimal changes needed beyond error handling✓ Already has good performance<p>✓ Memory safety guaranteed</p></td></tr><tr><td>❌ Type errors surface during runtime❌ Refactoring is risky</td><td>✓ Compiler catches most issues✓ Safe refactoring with type system</td></tr><tr><td>❌ Hard to maintain large codebases❌ Type issues compound</td><td>✓ Compiler guides improvements✓ Types help manage complexity</td></tr></tbody></table><p>Quite frankly, Rust makes for an excellent prototyping language if you embrace its strengths.\nYes, the type system will make you think harder about your design up front - but that’s actually a good thing!\nEach iteration might take a bit longer than in Python or JavaScript, but you’ll typically need fewer iterations from prototype to production.</p><p>I’ve found that my prototypes in other languages often hit a wall where I need to switch to something more robust.\nWith Rust, I can start simple and gradually turn that proof-of-concept into production code, all while staying in the same language and ecosystem.</p><p>If you have any more tips or tricks for prototyping in Rust, <a href=\"https://corrode.dev/about\">get in touch</a> and I’ll add them to the list!</p>","contentLength":21977,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1iaase8/prototyping_in_rust/"}],"tags":["dev"]}