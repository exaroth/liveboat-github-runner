{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"I built Puhu, a pillow drop-in replacement in Rust","url":"https://www.reddit.com/r/rust/comments/1mxx8nu/i_built_puhu_a_pillow_dropin_replacement_in_rust/","date":1755942513,"author":"/u/creworker","guid":610,"unread":true,"content":"<p>Hey All, I‚Äôm a python developer and recently learning rust. I decided to build a drop-in replacement for pillow. Pillow is a 20+ old python package for image processing, and it‚Äôs well optimized. why did I start doing that? because why not üòÖ I wanted to learn rust and how to build python packages with rust backend. I did some benchmarks and actually it‚Äôs working pretty good, it‚Äôs faster than pillow in some functions. </p><p>My aim is use same api naming and methods so it will be easy to migrate from pillow to puhu. I‚Äôve implemented basic methods right now. continue working on other ones.</p><p>I appreciate any feedback, support or suggestions. </p>","contentLength":650,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"GPUI Hello World Tutorial - From Core Concepts to Hello World | 0xshadow's Blog","url":"https://blog.0xshadow.dev/posts/learning-gpui/gpui-hello-world-tutorial/","date":1755922295,"author":"/u/lazyhawk20","guid":612,"unread":true,"content":"<p>In this post, we are going to learn about GPUI - an open source UI framework developed by the Zed Industries team to build interfaces by utilizing our computer‚Äôs GPU. We are going to learn the basics of GPUI by building a hello world app.</p><ul><li>Basic HTML, CSS and JS knowledge</li></ul><p>GPUI is a <strong>hybrid immediate and retained mode, GPU-accelerated</strong> UI framework for Rust created by the makers of Zed editor. Before we dive into code, let me explain what these terms mean in simple language.</p><p> means GPUI uses our computer‚Äôs graphics card to render to interface unlike traditional CPU-based rendering. This makes it extremely fast.</p><p><strong>Hybrid immediate and retained mode</strong> refers to how GPUI manages the user interface:</p><ul><li> means the UI is redrawn from scratch every frame.</li><li> means the framework remembers the UI structure and only updates what changes, which is more efficient.</li><li> mean GPUI uses both approaches.</li></ul><p>Before jumping into coding, lets understand why the Zed team created GPUI? Why the existing solutions aren‚Äôt good enough for them?</p><p>When Zed team decided to build their own code editor, they realized that existing UI frameworks couldn‚Äôt deliver the performance they need. Hence, they decided to build their own UI framework.\nThe problem with traditional desktop UI frameworks is that they primarily use CPU for rendering. The CPU processes instructions sequentially. This becomes a bottleneck when you have a complex interface with many elements. Every button, text field, menu and visual element must be processed in sequence.</p><p>To fix this issue, they decided to use GPU of the computer, which can process thousands of operations in parallel. Your graphics card contains hundreads and thousands or cores that can work simultaneously. This parallel processing has been used in gaming for decades, but most desktop apps don‚Äôt take advantage of it.</p><p>Now that we know why GPUI exists, lets now see how it actually works. After understanding its core concepts, we can start building our app as we will already have the understanding of its essential concepts.</p><h2>The Application Lifecycle and AppContext</h2><p>When we run a GPUI app, the framework needs to take care of a lot of things that are happening simultaneously. Our app might have multiple windows open, user might be clicking buttons, typing text or resizing windows.</p><p>The  object is kind of the coordinator of all this activity. When we run , we are telling GPUI to ‚Äústart managing the app and keep running until the user closes the app‚Äù.</p><p>The (often shortened to  in code) is what we will use to communicate with the  object. Every time we want to create a window, handle an event or update the display, we need to do it through the .</p><h2>Views and The Render Trait</h2><p>In GPUI, everything we see on screen is organized into . A view is a Rust struct that represents a logical piece of our application‚Äôs interface. Think of a view as a self-contained component that manages both its own data and knows how to present that data visually.</p><p>Here‚Äôs what makes GPUI fundamentally different from desktop frameworks like Electron, Tauri, or traditional native frameworks: GPUI uses a declarative rendering approach rather than an imperative one. In imperative frameworks, we create interface objects once and then manually update their properties when things change. We might write code like <code>button.setText(\"New Label\")</code> or <code>window.setBackgroundColor(red)</code> to modify existing interface elements.</p><p>GPUI works differently. It doesn‚Äôt store permanent interface objects that we modify. Instead, GPUI asks our views to completely recreate their visual description every single time the screen needs to be redrawn. This happens through the  trait, which every displayable struct must implement.</p><p>The  trait has exactly one method: . This method takes the current state of our view and returns a fresh description of what should appear on screen. GPUI calls this method whenever it needs to redraw our view, which could be 60 times per second or more. Our job is to look at our view‚Äôs current data and describe what the interface should look like based on that data.</p><p>This approach might seem inefficient at first glance, but it‚Äôs actually what enables GPUI‚Äôs exceptional performance. Since GPUI gets a complete description of our interface every frame, it can compare the new description with the previous one and update only the parts that actually changed. This is similar to how React‚Äôs virtual DOM works, but optimized for GPU rendering instead of web browsers.</p><p>When our  method runs, it creates and returns elements. Elements are temporary objects that describe visual components. They specify things like ‚Äúthere should be a rectangle here with this color and size‚Äù or ‚Äúthere should be text here with this font and content.‚Äù Elements are not the actual visual components themselves, but rather instructions for creating those components.</p><p>GPUI provides built-in element types that cover most interface needs. The  element creates a container that can hold other elements, similar to HTML div tags but designed for desktop applications. The  element creates an interactive button that can respond to clicks. The  element displays styled text content. Each element type has methods we can chain together to configure its appearance and behavior.</p><p>The power of GPUI‚Äôs element system comes from composition. We build complex interfaces by nesting simple elements inside other elements. A  can contain multiple child elements, and each of those children can have their own children, creating a hierarchical tree structure. This tree represents the logical structure of our interface.</p><p>When we call methods like , , or  on elements, we‚Äôre not modifying existing objects. Instead, we‚Äôre creating new element descriptions that include those properties. GPUI uses a builder pattern where each method call returns a new element with the additional configuration applied.</p><p>Now, that we understood a little bit of theory, let‚Äôs start building our first simple hello world app in GPUI.</p><h2>Installing Rust Nightly for Our Project</h2><p>To use GPUI we need to have the nightly version of Rust because it is using some experimental features. To install the nightly tool, run the following command:</p><p>This will download and install the latest nightly version of Rust.</p><p>Let‚Äôs start by creating a new rust project using cargo. Open the terminal and go to the directory where you want the project to be created. Now, run the following command:</p><p>After running this command, you can see that you have a standard rust project that prints Hello World in console but we want to create a GPUI app and print the Hello World text in that app.</p><p>Now, we need to enable the nightly version of Rust specifically for this project and not for all Rust projects. To do this, create a file called  in our project root directory.</p><pre tabindex=\"0\" data-language=\"toml\"><code></code></pre><p>This tells Cargo to automatically use nightly Rust whenever we work in this project directory, while keeping our global Rust installation on stable.</p><p>It‚Äôs time to configure our  file to work with the nightly edition and GPUI.</p><h2>Configuring Cargo for 2024 Edition and GPUI</h2><p>Let‚Äôs update our  file.</p><pre tabindex=\"0\" data-language=\"toml\"><code></code></pre><p>Here, we changed the  from  to  and added the GPUI dependency.</p><h2>Writing Our Hello World Code</h2><p>I‚Äôm putting the entire  code here and after that I‚Äôll explain everything one by one.</p><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>Ok, it seems a lot of code for Hello World let‚Äôs unpack everything one by one.</p><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>This import statement gets everything that we need from GPUI. Let‚Äôs understand what we are importing from GPUI:</p><ul><li> - The context type we receive in our main application closure for setting up windows and global app state</li><li> - The main application object that manages our entire GPUI app lifecycle</li><li> - A type that represents the position and size of windows on screen</li><li> - The context object we receive in our render method, giving us access to GPUI‚Äôs systems for this specific view</li><li> - GPUI‚Äôs optimized string type that allows efficient sharing of text data without unnecessary copying</li><li> - Represents a window and provides access to window-specific properties and methods</li><li><strong><code>WindowBounds, WindowOptions</code></strong> - Configuration types for specifying how our window should be created and positioned</li><li> - The function that creates div elements, our main building block for layouts</li><li> - Brings in commonly used traits like  and utility functions</li><li> - Helper functions for creating measurements (pixels), colors, and size specifications</li></ul><h2>Defining Our View with State</h2><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>Our view struct contains the actual text data. The  field stores the text that we want to show or display in the app.</p><p>Now, you might be wondering why use  instead of ?\nThe reason is GPUI optimizes for sharing the text between different parts of the app. The  can be cloned very efficiently without copying the actual text data and multiple parts of our app can reference the same text without memory overhead.</p><h2>Implementing the Render Trait</h2><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>Now, let‚Äôs understand the signature of the  method:</p><ul><li> - Mutable access to our view, allowing us to modify the view‚Äôs state during rendering if needed. Even though we don‚Äôt modify anything in this example, GPUI requires this flexibility.</li><li> - Access to the window this view is being rendered in. We could use this to query window properties like current size, position, or screen DPI. The underscore indicates we‚Äôre not using it in this simple example.</li><li> - The context object that provides access to GPUI‚Äôs systems. Through this context, we could handle user input, set up timers, or create child views. The  parameter means this context is specifically typed for our  view.</li></ul><h3>Building Our Element Tree</h3><p>Now let‚Äôs understand each method call in our element construction:</p><p>This creates our root  element - the foundation container for everything else in our view. This is similar to how we use div for containers in HTML.</p><p>This enables flexbox layout on our div. Flexbox provides powerful, automatic layout capabilities that adjust to different content sizes and window dimensions. This is why I asked you to have basic knowledge on CSS. If you don‚Äôt know flexbox concept then please quickly read about it and then continue reading this tutorial.</p><p>This sets the flex direction to column, meaning any child elements would stack vertically rather than horizontally. Even though we only have one child, this establishes the layout direction.</p><p>This sets the background color to a dark blue-gray. The  function takes a hexadecimal color value and converts it to GPUI‚Äôs internal color representation.</p><p>This sets both width and height to exactly 500 pixels. The  function creates a pixel-based measurement. This gives us a fixed-size container regardless of window size.</p><p>This centers content along the main axis. Since we used , the main axis runs vertically, so this centers our content vertically within the 500-pixel height.</p><p>This centers content along the cross axis. With column direction, the cross axis runs horizontally, so this centers our content horizontally within the 500-pixel width.</p><p>This sets the text size to extra large. GPUI provides a typography scale with predefined sizes for consistent text styling across our application.</p><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>This sets the text color to light gray, providing good contrast against our dark background.</p><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>This adds our text content as a child element. We use  to create a dynamic string that includes our view‚Äôs  field. The  accesses the SharedString from our view‚Äôs state.</p><h2>Application Startup and Configuration</h2><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><ul><li> - Creates and initializes a new GPUI application, setting up the rendering engine, event system, and platform integration.</li><li><strong><code>.run(|cx: &amp;mut App| { ... })</code></strong> - Starts the application main loop and executes our setup closure. The  parameter gives us an  context for configuring our application‚Äôs initial state.</li></ul><h3>Understanding Closures in Rust</h3><p>The  syntax is a  in Rust, which is similar to anonymous functions or lambda functions in other languages. Let‚Äôs break this down:</p><p>The  symbols define a closure. Think of closures as functions that we define inline without giving them a name.</p><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>The closure is like defining and using the function all in one place.\n</p><p>GPUI‚Äôs  method needs to:</p><ol><li>Initialize all the graphics systems</li><li>Set up the main application loop</li><li>Let us configure our initial windows and views</li><li>Start processing events and rendering\nThe  method says: ‚ÄúI‚Äôll handle all the complex setup, but when I‚Äôm ready, I‚Äôll call your closure so you can tell me what windows and views you want.‚Äù</li></ol><ul><li> is just a variable name (short for ‚Äúcontext‚Äù)</li><li> means ‚Äúa mutable reference to an App object‚Äù</li><li>The  object gives us access to GPUI‚Äôs application-level features like creating windows</li></ul><p>Think of  as a control panel that GPUI hands us, saying ‚Äúhere, use this to set up your application.‚Äù</p><h2>Window Creation and Positioning</h2><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>This calculates where our window should appear:</p><ul><li> creates window bounds that center the window on screen</li><li> means use the primary monitor (we could specify a particular monitor)</li><li> creates a 500x500 pixel size specification</li><li> provides information about the current screen configuration</li></ul><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>Creates a window with specific options:</p><ul><li> configures window properties</li><li><code>window_bounds: Some(WindowBounds::Windowed(bounds))</code> sets the window to normal windowed mode with our calculated position and size</li><li> uses default values for other options like window title, decorations, etc.</li></ul><h2>View Creation and Initialization</h2><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>We actually have  nested in our code:</p><ol><li> - Sets up our application</li><li> - Defines what goes in the window</li><li> - Creates our view instance</li></ol><p>Each closure handles a different level of setup:</p><ol><li> - ‚ÄúWhat windows should exist?‚Äù</li><li> - ‚ÄúWhat should go in this specific window?‚Äù</li><li> - ‚ÄúHow should this view be initialized?‚Äù</li></ol><p>The window creation closure does two things:</p><ul><li>Takes a window handle (ignored with ) and a window-specific context</li><li>Uses  to create and register our view with GPUI</li><li>The inner closure creates our initial  instance with ‚ÄúGPUI World‚Äù as the text</li><li> converts the string literal into a </li></ul><p>You‚Äôll notice some closures use  as a parameter name:</p><pre tabindex=\"0\" data-language=\"rust\"><code></code></pre><p>The  means ‚ÄúI receive a parameter here, but I don‚Äôt need to use it.‚Äù It‚Äôs Rust‚Äôs way of saying ‚Äúignore this parameter‚Äù without getting compiler warnings.</p><p>When we run this application:</p><ol><li> initializes all GPUI systems</li><li> starts the main application loop and calls our setup closure</li><li>We calculate window bounds for a centered 500x500 window</li><li>We create a window with those specifications</li><li>We create a  view instance with initial text</li><li>GPUI calls our view‚Äôs  method to get the element description</li><li>Our  method returns a 500x500 div with centered text</li><li>GPUI renders this using the GPU and displays our window</li><li>The application loop continues, ready for user interaction or updates</li></ol><h2>Building and Running Our Application</h2><p>Now let‚Äôs see our hello world app in action. In your terminal, make sure you‚Äôre in the project directory and run:</p><p>The first time you run this command, it will take several minutes to complete. Cargo needs to download the Zed repository, compile GPUI and all its dependencies, and then compile our application. We‚Äôll see a lot of output as Cargo builds everything.</p><p>Don‚Äôt worry if this seems slow - this lengthy compilation only happens the first time. Subsequent runs will be much faster because Cargo caches the compiled dependencies.</p><p>When the compilation finishes and our application starts, we should see a 500x500 pixel window appear with our ‚ÄúHello, GPUI World!‚Äù message centered on a dark background. The text should be large and clearly visible in light gray against the dark blue-gray background. Something like this:</p><p><img alt=\"gpui-hello-world-output.png\" loading=\"lazy\" decoding=\"async\" fetchpriority=\"auto\" sizes=\"(min-width: 1136px) 1136px, 100vw\" data-astro-image=\"constrained\" width=\"1136\" height=\"1192\" src=\"https://blog.0xshadow.dev/_astro/gpui-hello-world-output.DDY6YTk-_Z1rCgEn.webp\" srcset=\"/_astro/gpui-hello-world-output.DDY6YTk-_Z2px3fw.webp 640w, /_astro/gpui-hello-world-output.DDY6YTk-_Z1zDmCA.webp 750w, /_astro/gpui-hello-world-output.DDY6YTk-_Z2gO83h.webp 828w, /_astro/gpui-hello-world-output.DDY6YTk-_Z2a6JUr.webp 1080w, /_astro/gpui-hello-world-output.DDY6YTk-_Z1rCgEn.webp 1136w\">\nTry interacting with the window - we can move it around, resize it, minimize it, and close it. Even though we haven‚Äôt written any code to handle these interactions, GPUI provides them automatically because they‚Äôre standard window operations.</p><p>This concludes learning the basics of GPUI and displaying hello world in the screen. I hope you‚Äôve learned something from this post and in the next post we are going to learn about handling user inputs, managing state changes, making our app respond to user actions and understanding event handling in GPUI. Learning these things before implementing the todo app would help us cover a lot of concepts in an isolated way making them simpler to understand. See you soon.</p>","contentLength":16104,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1mxro1j/gpui_hello_world_tutorial_from_core_concepts_to/"},{"title":"[Media] Accelerating Erasure Coding to 50GB/s with Rust 1.89.0 and AVX-512 on AMD EPYC","url":"https://www.reddit.com/r/rust/comments/1mxe8t4/media_accelerating_erasure_coding_to_50gbs_with/","date":1755886981,"author":"/u/itzmeanjan","guid":613,"unread":true,"content":"<div><p>Thanks to Rust 1.89.0 stabilizing both  and  target features, now we have faster erasure-coding and recoding with Random Linear Network Coding, on x86_64.</p><p>Here's a side-by-side comparison of the peak median throughput between </p><ul><li>x86_64 with  (12th Gen Intel(R) Core(TM) i7-1260P)</li><li>x86_64 with  (AWS EC2  with Intel(R) Xeon(R) Platinum 8488C)</li><li>x86_64 with  (AWS EC2  with AMD EPYC 9R14)</li><li>aarch64 with  (AWS EC2  with Graviton4 CPU)</li></ul><table><thead><tr></tr></thead><tbody><tr></tr><tr></tr><tr></tr></tbody></table></div>   submitted by   <a href=\"https://www.reddit.com/user/itzmeanjan\"> /u/itzmeanjan </a>","contentLength":453,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust For Foundational Software","url":"https://corrode.dev/blog/foundational-software/","date":1755876982,"author":"/u/don_searchcraft","guid":611,"unread":true,"content":"<p>Ten years of stable Rust; writing this feels surreal.</p><p>It‚Äôs only been  that we all celebrated the 1.0 release of this incredible language.</p><p>I was at Rust Week where Niko Matsakis gave his talk ‚ÄúOur Vision for Rust‚Äù in which he made a profound and insightful statement:</p><blockquote><p>Rust is a language for building .</p></blockquote><p>I highly recommend you read his blog post titled <a rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://smallcultfollowing.com/babysteps/blog/2025/03/10/rust-2025-intro/\">‚ÄúRust in 2025: Targeting foundational software‚Äù</a>, which is a great summary on the topic.\nI wanted to expand on the idea and share what this means to corrode (and perhaps to a wider extent to Rust in the industry).</p><p>First off, do we really need another term?\nAfter all, many people still think of Rust as a systems programming language first and foremost, so why can‚Äôt we just stick to ‚Äúsystems programming‚Äù?</p><p>I believe the framing is all wrong.\nFrom the outside, ‚Äúsystems programming‚Äù might establish that it is about ‚Äúbuilding systems,‚Äù but the term is loaded with historical baggage that feels limiting and prohibitive.\nIt creates an artificial distinction between systems programming and ‚Äúother types of programming.‚Äù</p><p>The mindset ‚ÄúWe are not a systems programming company so we don‚Äôt need Rust‚Äù is common, but limiting.</p><p>If I may be candid for a moment, I believe well-known systems-programming domains have a tendency to be toxic.\nEven the best developers in the world have had that experience.</p><blockquote><p>The first contribution that I had to the Linux kernel was some fix for the ext3 file system. It was a very emotional moment for me. I sent a patch to the Linux Kernel and then I saw an email response from Al Viro - one of those developers I‚Äôd only heard about and dreamed of meeting someday.\nHe responded, <strong>‚ÄòI‚Äôve never seen code this bad in my life. You managed to introduce three new bugs in two new lines of code. People like you should never be allowed to get close to a keyboard again.‚Äô</strong>\nThat was my introduction to Linux.</p></blockquote><p>Glauber went on to work at Red Hat, Parallels, ScyllaDB, and Datadog on schedulers, databases, and performance optimizations, but just imagine how many capable developers got discouraged by similar early feedback or never even tried to contribute to the Linux kernel in the first place.</p><p>The whole idea of Rust is to enable  to build reliable and efficient software.\nTo me, it‚Äôs about breaking down the barriers to entry and making larger parts of the software stack accessible to more people.\nYou can sit with us.</p><blockquote><p>‚ÄúI think ‚Äòinfrastructure‚Äô is a more useful way of thinking about Rust‚Äôs niche than arguing over the exact boundary that defines ‚Äòsystems programming‚Äô.‚Äù</p><p>‚ÄúThis is the essence of the systems Rust is best for writing: not flashy, not attention-grabbing, often entirely unnoticed. Just the robust and reliable necessities that enable us to get our work done, to attend to other things, confident that the system will keep humming along unattended.‚Äù</p></blockquote><p>In conversations with potential customers, one key aspect that comes up with Rust a lot is this perception that Rust is merely a systems programming language.\nThey see the benefit of reliable software, but often face headwinds from people dismissing Rust as ‚Äúyet another systems level language that is slightly safer.‚Äù</p><p>People keep asking me how Rust could help them.\nAfter all, Rust is just a ‚Äúsystems programming language.‚Äù\nI used to reply along the lines of Rust‚Äôs mantra: ‚Äúempowering everyone to build reliable and efficient software‚Äù ‚Äì and while I love this mission, it didn‚Äôt always ‚Äúclick‚Äù with people.</p><p>My clients use Rust for a much broader range of software, not just low-level systems programming.\nThey use Rust for writing software that .</p><p>Then I used to tell my own story:\nI did some C++ in the past, but I wouldn‚Äôt call myself a systems programmer.\nAnd yet, I help a lot of clients with really interesting and complex pieces of software.\nI ship code that is used by many people and companies like Google, Microsoft, AWS, and NVIDIA.\nRust is a great enabler, a superpower, a <a rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://web.archive.org/web/20230603070738/https://thefeedbackloop.xyz/safety-is-rusts-fireflower/\">fireflower</a>.</p><p>I found that my clients often don‚Äôt use Rust as a C++ replacement.\nMany clients don‚Äôt even have any C++ in production in the first place.\nThey also don‚Äôt need to work on the hardware-software interface or spend their time in low-level code.</p><p>What they all have in common, however, is that the services they build with Rust are <strong>foundational to their core business</strong>.\nRust is used for building platforms: systems which enable building other systems on top.</p><p>These services need to be robust and reliable and serve as platforms for other code that might or might not be written in Rust.\nThis is, in my opinion, the core value proposition of Rust: to build things that form the bedrock of critical infrastructure and must operate reliably for years.</p><p>Rust is a day-2-language, i.e. it only starts to shine on day 2. All of the problems that you have during the lifecycle of your application surface early in development.\nOnce a service hits production, maintaining it is boring.\nThere is very little on-call work.</p><p>The focus should be on what Rust enables: a way to express very complicated ideas on a type-system level, which will help build complex abstractions through simple core mechanics: ownership, borrowing, lifetimes, and its trait system.</p><p>This mindset takes away the focus from Rust as a C++ replacement and also explains why so many teams which use languages like Python, TypeScript, and Kotlin are attracted by Rust.</p><p>What is less often talked about is that Rust is a language that enables people to move across domain boundaries: from embedded to cloud, from data science to developer tooling.\nFew other languages are so versatile and none offer the same level of correctness guarantees.</p><p>If you know Rust, you can program simple things in all of these domains.</p><p>But don‚Äôt we just replace ‚ÄúSystems Programming‚Äù with ‚ÄúFoundational Software‚Äù?\nDoes using the term ‚ÄúFoundational Software‚Äù simply create a new limiting category?</p><p>Crucially, foundational software is different from low-level software and systems software.\nFor my clients, it‚Äôs all foundational.\nFor example, building a data plane is foundational.\nWriting a media-processing pipeline is foundational.</p><p>Rust serves as a catalyst: companies start using it for critical software but then, as they get more comfortable with the language, expand into using it in other areas of their business:</p><blockquote><p>I‚Äôve seen it play out as we built Aurora DSQL - we chose Rust for the new dataplane components, and started off developing other components with other tools. The control plane in Kotlin, operations tools in Typescript, etc. Standard ‚Äúright tool for the job‚Äù stuff. But, as the team has become more and more familiar and comfortable with Rust, it‚Äôs become the way everything is built. A lot of this is because we‚Äôve seen the benefits of Rust, but at least some is because the team just enjoys writing Rust.</p></blockquote><p>That fully aligns with my experience: I find that teams become ambitious after a while.\nThey reach for loftier goals because they .\nThe fact they don‚Äôt have to deal with security issues anymore enables better affordances.\nFrom my conversations with other Rustaceans, we all made the same observation: suddenly we can build more ambitious projects that we never dared tackling before.</p><p>It feels to me as if this direction is more promising: starting with the foundational tech and growing into application-level/business-level code if needed/helpful.\nThat‚Äôs better than the other way around, which often feels unnecessarily clunky.\nOnce the foundations are in Rust, other systems can be built on top of it.</p><p>Just because we focus on foundational software doesn‚Äôt mean we can‚Äôt do other things.\nBut the focus is to make sure that Rust stays true to its roots.</p><h2><a href=\"https://corrode.dev/blog/foundational-software/#systems-you-plan-to-maintain-for-years\" aria-label=\"Anchor link for: systems-you-plan-to-maintain-for-years\">Systems You Plan To Maintain For Years</a></h2><p>So, what  foundational software?</p><p>It‚Äôs software that organizations deem critical for their success.\nIt might be:</p><ul><li>a satellite control system</li><li>an SDK for multiple languages</li><li>a real time notification service</li></ul><p>All of these things power organizations and  or at least do so .\nMy clients and the companies I interviewed on our <a href=\"https://corrode.dev/podcast\">podcast</a> all have one thing in common:\nThey work on Rust projects that are not on the sideline, but front and center, and they shape the future of their infrastructure.\nRust is useful in situations where the <a rel=\"noopener noreferrer\" target=\"_blank\" href=\"https://dreamsongs.com/Files/worse-is-worse.pdf\">‚Äúworse is better‚Äù philosophy falls apart</a>; it‚Äôs a language for building the ‚Äúright thing‚Äù:</p><blockquote><p>With the right thing, designers are equally concerned with simplicity, correctness, consistency, and completeness.</p></blockquote><p>I think many companies will choose Rust to build their future platforms on.\nAs such, it competes with C++ as much as it does with Kotlin or Python.</p><p>I believe that we should shift the focus away from memory safety (which these languages also have) and instead focus on the explicitness, expressiveness, and ecosystem of Rust that is highly competitive with these languages.\nIt is a language for teams which want to build things  and are at odds with the ‚Äúmove fast and break things‚Äù philosophy of the past.\nRust is future-looking.\nBackwards-compatibility is enforced by the compiler and many people work on the robustness aspect of the language.</p><p>Dropbox was one of the first production users of Rust.\nThey built their storage layer on top of it.\nAt no point did they think about using Rust as a C++ replacement.\nInstead, they saw the potential of Rust as a language for building scalable and reliable systems.\nMany more companies followed:\nAmazon, Google, Microsoft, Meta, Discord, Cloudflare, and many more.\nThese organizations build platforms.\nRust is a tool for professional programmers, developed by world experts over more than a decade of hard work.</p><blockquote><p>‚ÄúAt this point, we now know the answer: yes, Rust is used a lot. It‚Äôs used for real, critical projects to do actual work by some of the largest companies in our industry. We did good.‚Äù</p><p>‚Äú[Rust is] not a great hobby language but it is a fantastic professional language, precisely because of the ease of refactors and speed of development that comes with the type system and borrow checker.‚Äù</p></blockquote><p>To build a truly industrial-strength ecosystem, we need to remember the professional software lifecycle, which is hopefully decades long.\nStability plays a big role in that.\nThe fact that Rust has stable editions and a language specification is a big part of that.</p><p>But Rust is not just a compiler and its standard library.\nThe tooling and wider ecosystem are equally important.\nTo build foundational software, you need guarantees that vulnerabilities get fixed and that the ecosystem evolves and adapts to the customer‚Äôs needs.\nThe ecosystem is still mostly driven by volunteers who work on important parts of the ecosystem in their free time.\nThere is more to be said about supply-chain security and sustainability in the ecosystem.</p><p>Building foundational systems is rooted in the profound belief that the efforts will pay off in the long run because organizations and society will benefit from them for decades.\nWe are building systems that will be used by people who may not even know they are using them, but who will depend on them every day.\nCritical infrastructure.</p><p>And Rust allows us to do so with great ergonomics.\nRust inherits pragmatism from C++ and purism from Haskell.</p><p>Rust enables us to build sustainable software that stays within its means and is concerned about low resource usage.\nSystems where precision and correctness matter.\nSolutions that work across language boundaries and up and down the stack.</p><p>Rust is a language for decades and my mission is to be a part of this shift.</p>","contentLength":11547,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1mx9tdr/rust_for_foundational_software/"},{"title":"Does Rust complexity ever bother you?","url":"https://www.reddit.com/r/rust/comments/1mx8izf/does_rust_complexity_ever_bother_you/","date":1755874050,"author":"/u/GolangLinuxGuru1979","guid":615,"unread":true,"content":"<p>I'm a Go developer and I've always had a curiosity about Rust. I've tried to play around and start some personal project in it a few times. And it's mostly been ok. Like I tried to use <a href=\"http://hyper.rs\">hyper.rs</a> a few times, but the boilerplate takes a lot to understand in many of the examples. I've tried to use tokio, but the library is massive, and it gets difficult to understand which modules to important and now important. On top of that it drastically change the async functons</p><p>I'm saying all that to say Rust is very complicated. And while I do think there is a fantastic langauge under all that complexity, it prohibitively complex. I do get it that memory safety in domains like RTOS systems or in government spaces is crucial. But it feels like Rust thought leaders are trying to get the language adopted in other domains. Which I think is a bit of an issue because you're not competing with other languages where its much easier to be productive in.</p><p>Here is my main gripe with the adoption. Lots of influencers in the Rust space just seem to overlook its complexity as if its no big deal. Or you have others who embrace it because Rust \"has to be complex\". But I feel in the enterprise (where adoption matters most), no engineering manager is really going to adopt a language this complex.</p><p>Now I understand languages like C# and Java can be complex as well. But Java at one time was looked at as a far simpler version of C++, and was an \"Easy language\". It would grow in complexity as the language grew and the same with C#. And then there is also tooling to kind of easy you into the more complex parts of these languages.</p><p>I would love to see Rust adopted more, I would. But I feel advociates aren't leaning into its domain where its an open and shut case for (mission critical systems requiring strict safety standards). And is instead also trying to compete in spaces where Go, Javascript, Java already have a strong foothold.</p><p>Again this is not to critcize Rust. I like the language. But I feel too many people in the Rust community talk around its complexity.</p>","contentLength":2054,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Cargo inspired C/C++ build tool, written in rust","url":"https://github.com/EmVance1/VanGo","date":1755872267,"author":"/u/MNGay","guid":614,"unread":true,"content":"<p>Using rust for the past 3 years or so got me thinking, why can't it always be this easy? Following this, I've spent the last 10 months (on-off due to studies) developing a tool for personal use, and I'd love to see what people think about it. Introducing VanGo, if you'll excuse the pun.</p>","contentLength":287,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1mx7rnc/cargo_inspired_cc_build_tool_written_in_rust/"}],"tags":["dev","reddit","rust"]}