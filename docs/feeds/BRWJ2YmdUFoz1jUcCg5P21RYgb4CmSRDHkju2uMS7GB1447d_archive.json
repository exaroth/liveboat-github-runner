{"id":"BRWJ2YmdUFoz1jUcCg5P21RYgb4CmSRDHkju2uMS7GB1447d","title":"Mouse Vs Python","displayTitle":"Dev - Python Blog","url":"https://blog.pythonlibrary.org/feed","feedLink":"https://www.blog.pythonlibrary.org/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"Textual – Switching Screens in Your Terminal","url":"https://www.blog.pythonlibrary.org/2025/01/14/textual-switching-screens-in-your-terminal/","date":1736888959,"author":"Mike","guid":283,"unread":true,"content":"<p>The&nbsp;&nbsp;is a container for your widgets. These screens occupy the dimensions of your terminal by default. While you can have many different screens in a single application, only one screen may be active at a time.</p><p>When you create your&nbsp; class, Textual will create a screen object implicitly. Yes, Textual requires you to have at least one screen or your application won’t work. If you do not create a new screen or switch to a different one, the default screen is where your widgets will get mounted or composed to.</p><p>Screens are a great way to organize your application. Many applications have settings pages, help pages, and more. These are just a few examples of how you can use screens.</p><p>Now that you know what a screen is, you’re ready to learn how to create new ones!</p><p>When you create an application, you create a&nbsp;&nbsp;implicitly. But how do you create your own&nbsp;? Fortunately, Textual has made that easy. All you need to do is import the&nbsp;&nbsp;class from&nbsp;&nbsp;and extend it as needed.</p><p>You can style screens the same way you do other widgets, except for the dimensions as screens are always the same size as your terminal window.</p><p>To see how this all works, you will create an application with two screens:</p><ul><li>You second screen, which will be green</li></ul><p>You will be able to switch between the screens using a button. Each screen has its own button and its own event or message handler.</p><p>Open up your favorite Python IDE and create a new file called&nbsp;&nbsp;with the following contents:</p><pre data-enlighter-language=\"python\"># two_screens.py\n\nfrom textual import on\nfrom textual.app import App, ComposeResult\nfrom textual.screen import Screen\nfrom textual.widgets import Button\n\nclass GreenScreen(Screen):\n\n    def compose(self) -&gt; ComposeResult:\n        self.styles.background = \"green\"\n        yield Button(\"Main Screen\", id=\"main\")\n\n    @on(Button.Pressed, \"#main\")\n    def on_main(self) -&gt; None:\n        self.dismiss()\n\n\nclass MainAop(App):\n\n    def compose(self) -&gt; ComposeResult:\n        yield Button(\"Switch\", id=\"switch\")\n\n    @on(Button.Pressed, \"#switch\")\n    def on_switch(self) -&gt; None:\n        self.push_screen(GreenScreen())\n\n\nif __name__ == \"__main__\":\n    app = MainAop()\n    app.run()</pre><p>You use Textual’s handy&nbsp;&nbsp;decorator to match against the button’s&nbsp;. That keeps the message from bubbling around to other event handlers, which is what could happen if you had used&nbsp;, for example.</p><p>When you run your application, you will see something like this:</p><p>Try clicking the buttons and switching between the screens.</p><p>Of course, you don’t need to use button’s at all, if you don’t want to. You could use keyboard shortcuts instead. Why not give that a try?</p><p>Go back to your Python IDE and create a new file called&nbsp;&nbsp;with this code in it:</p><pre data-enlighter-language=\"python\"># two_screens_keys_only.py\n\nfrom textual.app import App, ComposeResult\nfrom textual.screen import Screen\nfrom textual.widgets import Label\n\n\nclass GreenScreen(Screen):\n    BINDINGS = [(\"escape\", \"app.pop_screen\", \"Dismiss the screen\")]\n\n    def compose(self) -&gt; ComposeResult:\n        self.styles.background = \"green\"\n        yield Label(\"Second Screen\")\n\n\nclass MainAop(App):\n    SCREENS = {\"green\": GreenScreen}\n    BINDINGS = [(\"n\", \"push_screen('green')\", \"Green Screen\")]\n\n    def compose(self) -&gt; ComposeResult:\n        yield Label(\"Main screen\")\n\n\nif __name__ == \"__main__\":\n    app = MainAop()\n    app.run()</pre><p>Using keyboard shortcuts makes your code a little less verbose. However, since you aren’t using a&nbsp;&nbsp;widget, the shortcuts are not shown on-screen to the user. When you are on the main screen, you must press the letter “n” on your keyboard to switch to the&nbsp;. Then when you want to switch back, you press “Esc” or escape.</p><p>Here’s what the screen looks like on the&nbsp;:</p><p>Now try using the keys mentioned to swap between the two screens. Feel free to change the keyboard bindings to keys of your own choosing.</p><p>Textual can do much more with Screens than what is covered in this brief tutorial. However, you can use this information as a great starting point for learning how to add one more additional screens to your GUI in your terminal.</p><p>Play around with these examples and then run over to the Textual documentation to learn about some of the other widgets you can add to bring your application to life.</p><p>If you’d like to learn more about Textual, check out my book: <strong>Creating TUI Applications with Textual and Python</strong>, which you can find on the following websites:</p>","contentLength":4365,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"An Intro to pre-commit","url":"https://www.blog.pythonlibrary.org/2024/12/23/an-intro-to-pre-commit/","date":1734959382,"author":"Mike","guid":282,"unread":true,"content":"<p>You can use many great tools to help you in your software development journey. One such tool is <a href=\"http://A framework for managing and maintaining multi-language pre-commit hooks\">pre-commit</a>, a&nbsp;framework for managing and maintaining multi-language&nbsp; hooks. You use pre-commit to run one or more tools before allowing you to commit your code locally. For example, you might run the Flake8 linter or the <a href=\"https://www.blog.pythonlibrary.org/2023/10/25/the-ruff-formatter-pythons-fastest-formatter/\">Ruff formatter</a> on your Python code in GitHub Actions or some other CI. But rather than waiting for CI to run, you want to run those checks locally and automatically.</p><p>That is where pre-commit comes in. You tell pre-c0mmit what to run, and it will run right before it allows you to commit your code.If any of those checks fail, you must fix your code before committing it.</p><p>pre-commit is a Python package, so you can install it using pip. Here’s the command you’ll need to run in your terminal:</p><p>Once pre-commit is installed, you can confirm that it works by running the following:</p><p>The next step is to navigate to one of your local GitHub code bases in your terminal. Once inside one of your repos, you will need to run this command:</p><p>This command installs pre-commit in your  folder so that pre-commit runs whenever you commit. But how does pre-commit know what to run?</p><p>You have to define what  runs using a special YAML file. You’ll learn how in the next section!</p><h2>Adding a pre-commit Configuration</h2><p>You need to add a file named  (note the leading period) into the root of your repo. If you want to generate a simple config file, you can run this command:</p><p>Here’s an example config for running Black on your code:</p><pre data-enlighter-language=\"yaml\">repos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v2.3.0\n    hooks:\n    -   id: check-yaml\n    -   id: end-of-file-fixer\n    -   id: trailing-whitespace\n-   repo: https://github.com/psf/black\n    rev: 22.10.0\n    hooks:\n    -   id: black</pre><p>Personally, I like to run the Ruff formatter and linter as well as a couple of defaults, so I use this config a lot:</p><pre data-enlighter-language=\"yaml\">repos:\n-   repo: https://github.com/pre-commit/pre-commit-hooks\n    rev: v3.2.0\n    hooks:\n    -   id: trailing-whitespace\n    -   id: end-of-file-fixer\n    -   id: check-added-large-files\n\n- repo: https://github.com/astral-sh/ruff-pre-commit\n  # Ruff version.\n  rev: v0.1.7\n  hooks:\n    # Run the linter.\n    - id: ruff\n    # Run the formatter.\n    - id: ruff-format\n</pre><p>When you add a new rule to pre-commit, you should run that rule against all the files in your repo so you don’t have any surprises later on. To do that, you need to run this command:</p><pre data-enlighter-language=\"generic\">pre-commit run --all-files</pre><p>Once you have run all your new rules against all your code files, you can start working on your next feature or bug fix. Then, when you run,&nbsp;  the pre-commit hooks will run, and you’ll see if your code is good enough to pass.</p><p>There are TONs of hooks you can add to pre-commit. A lot of them are mentioned on the <a href=\"https://pre-commit.com/\">pre-commit website</a>. You can add Mypy, pytest, and much, much more to your pre-commit hooks. Just don’t get too crazy, or they may take too long to run, and you’ll go nuts waiting for it.</p><p>Overall, running so many of your CI hooks locally is great because your machine is usually faster than waiting on a queue in CI. Give it a try and see what think!</p>","contentLength":3145,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}]}