{"id":"BRWJ2YmdUFoz1jUcCg5P21RYgb4CmSRDHkju2uMS7GB1447d","title":"Mouse Vs Python","displayTitle":"Dev - Python Blog","url":"https://blog.pythonlibrary.org/feed","feedLink":"https://www.blog.pythonlibrary.org/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"Python 101: Reading TOML with Python","url":"https://www.blog.pythonlibrary.org/2025/08/07/python-101-reading-toml-with-python/","date":1754570647,"author":"Mike","guid":291,"unread":true,"content":"<p>The <a href=\"https://github.com/toml-lang/toml/wiki\">TOML</a> (Tom’s Obvious Minimal Language) <a href=\"https://toml.io/en/\">format</a> came out in 2013, so it’s been around for more than a decade. Python added support for TOML in Python 3.11 with its  module in the standard library. However, unlike some of Python’s other standard libraries, such as or its XML-related libraries, the  library is only for reading, not writing. To create TOML documents in Python, you will need a third-party TOML package, such as <a href=\"https://pypi.org/project/tomlkit/\">tomlkit</a> or <a href=\"https://pypi.org/project/toml/\">toml</a>.</p><p>Many Python developers use TOML as their configuration format of choice. In fact, you will find that most popular Python packages use a file called  for configuration. You can even use that file as a replacement for&nbsp; Mypy, Flake8, and other tools can also be configured using  You can learn more about that file and how it is formatted in the <a href=\"https://packaging.python.org/en/latest/guides/writing-pyproject-toml/\">Python packaging guide</a>.</p><p>In this tutorial, you will focus only on what Python itself provides for TOML support.</p><p>Python’s  is based on the <a href=\"https://github.com/hukkin/tomli\">tomli</a> package. You can read all about the implementation details and why TOML support was added to Python in <a href=\"https://peps.python.org/pep-0680/\">PEP 680</a>.</p><p>The nice thing about having TOML support built-in to Python is that you do not need to install anything other than Python itself. However, if you need to be able to create or edit a TOML document, then you will need a third-party package as  is read-only.</p><p>To really understand what happens when you use the  module, you need a TOML file. You can pick your favorite Python package and grab a TOML file from it. For the purposes of this tutorial, you can use the <a href=\"https://github.com/driscollis/squall/blob/main/pyproject.toml\">Squall</a> package’s TOML file. Squall is a TUI for viewing and editing SQLite databases.</p><p>Here’s what the TOML looks like:</p><pre data-enlighter-language=\"generic\">[project]\nname = \"squall_sql\"\ndynamic = [\n    \"version\",\n]\ndescription = \"Squall - SQLite Editor\"\nreadme = \"README.md\"\nrequires-python = \"&gt;=3.11\"\nauthors = [\n    { name = \"Mike Driscoll\", email = \"mike@nlah.org\" },\n]\nmaintainers = [\n    { name = \"Mike Driscoll\", email = \"mike@nlah.org\" },\n]\nclassifiers = [\n    \"License :: OSI Approved :: MIT License\",\n    \"Environment :: Console\",\n    \"Development Status :: 4 - Beta\",\n    \"Intended Audience :: Developers\",\n    \"Intended Audience :: End Users/Desktop\",\n    \"Intended Audience :: Other Audience\",\n    \"Programming Language :: Python :: 3\",\n    \"Programming Language :: Python :: 3.11\",\n    \"Programming Language :: Python :: 3.12\",\n    \"Programming Language :: Python :: 3.13\",\n    \"Operating System :: MacOS\",\n    \"Operating System :: Microsoft :: Windows :: Windows 10\",\n    \"Operating System :: Microsoft :: Windows :: Windows 11\",\n    \"Operating System :: POSIX :: Linux\",\n    \"Topic :: Software Development :: Libraries :: Python Modules\",\n    \"Typing :: Typed\",\n]\nkeywords = [\n    \"tui\",\n    \"sql\",\n    \"sqlite\",\n    \"terminal\",\n]\ndependencies = [\n    \"rich&gt;=13.9.4\",\n    \"SQLAlchemy&gt;=2.0.38\",\n    \"textual&gt;=2.1.1\",\n]\npackages = [\n    \"src/squall\",\n]\n\n[project.license]\nfile = \"LICENSE\"\n\n[project.urls]\nHomepage = \"https://github.com/driscollis/squall\"\nDocumentation = \"https://github.com/driscollis/squall/blob/main/README.md\"\nRepository = \"https://github.com/driscollis/squall\"\nIssues = \"https://github.com/driscollis/squall/issues\"\nDiscussions = \"https://github.com/driscollis/squall/discussions\"\nWiki = \"https://github.com/driscollis/squall/wiki\"\n\n[project.scripts]\nsquall = \"squall.squall:main\"\n\n[build-system]\nrequires = [\n    \"hatchling\",\n    \"wheel\",\n]\nbuild-backend = \"hatchling.build\"\n\n[dependency-groups]\ndev = [\n    \"build&gt;=1.2.1\",\n    \"ruff&gt;=0.9.3\",\n    \"pyinstrument&gt;=5.0.1\",\n    \"textual-dev&gt;=1.7.0\",\n]\n\n[tool.hatch.version]\npath = \"src/squall/__init__.py\"\n\n[tool.hatch.build.targets.wheel]\npackages = [\n    \"src/squall\",\n]\ninclude = [\n    \"py.typed\",\n    \"**/*.py\",\n    \"**/*.html\",\n    \"**/*.gif\",\n    \"**/*.jpg\",\n    \"**/*.png\",\n    \"**/*.md\",\n    \"**/*.tcss\",\n]\n\n[tool.hatch.build.targets.sdist]\ninclude = [\n    \"src/squall\",\n    \"LICENSE\",\n    \"README.md\",\n    \"pyproject.toml\",\n]\nexclude = [\n    \"*.pyc\",\n    \"__pycache__\",\n    \"*.so\",\n    \"*.dylib\",\n]\n\n[tool.pytest.ini_options]\npythonpath = [\n  \"src\"\n]</pre><p>The next step is to write some Python code to attempt to read in the TOML file above. Open up your favorite Python IDE and create a file. You can call it something like if you want.</p><p>Then enter the following code into it:</p><pre data-enlighter-language=\"python\">import tomllib\n\nfrom pathlib import Path\nfrom pprint import pprint\n\n\npyproject = Path(\"pyproject.toml\")\n\nwith pyproject.open(\"rb\") as config:\n    data = tomllib.load(config)\n\npprint(data)</pre><p>Here you open the TOML file from Squall and load it using the  module. You use Python’s module to print it out. The nice thing about the module is that it returns a dictionary.</p><p>Of course, the dictionary doesn’t print nicely without using pretty print, which is why you use the module here.</p><p>The following is the output you will get if you run this code:</p><pre data-enlighter-language=\"python\">{'build-system': {'build-backend': 'hatchling.build',\n                  'requires': ['hatchling', 'wheel']},\n 'dependency-groups': {'dev': ['build&gt;=1.2.1',\n                               'ruff&gt;=0.9.3',\n                               'pyinstrument&gt;=5.0.1',\n                               'textual-dev&gt;=1.7.0']},\n 'project': {'authors': [{'email': 'mike@pythonlibrary.org',\n                          'name': 'Mike Driscoll'}],\n             'classifiers': ['License :: OSI Approved :: MIT License',\n                             'Environment :: Console',\n                             'Development Status :: 4 - Beta',\n                             'Intended Audience :: Developers',\n                             'Intended Audience :: End Users/Desktop',\n                             'Intended Audience :: Other Audience',\n                             'Programming Language :: Python :: 3',\n                             'Programming Language :: Python :: 3.11',\n                             'Programming Language :: Python :: 3.12',\n                             'Programming Language :: Python :: 3.13',\n                             'Operating System :: MacOS',\n                             'Operating System :: Microsoft :: Windows :: '\n                             'Windows 10',\n                             'Operating System :: Microsoft :: Windows :: '\n                             'Windows 11',\n                             'Operating System :: POSIX :: Linux',\n                             'Topic :: Software Development :: Libraries :: '\n                             'Python Modules',\n                             'Typing :: Typed'],\n             'dependencies': ['rich&gt;=13.9.4',\n                              'SQLAlchemy&gt;=2.0.38',\n                              'textual&gt;=2.1.1'],\n             'description': 'Squall - SQLite Editor',\n             'dynamic': ['version'],\n             'keywords': ['tui', 'sql', 'sqlite', 'terminal'],\n             'license': {'file': 'LICENSE'},\n             'maintainers': [{'email': 'mike@pythonlibrary.org',\n                              'name': 'Mike Driscoll'}],\n             'name': 'squall_sql',\n             'packages': ['src/squall'],\n             'readme': 'README.md',\n             'requires-python': '&gt;=3.11',\n             'scripts': {'squall': 'squall.squall:main'},\n             'urls': {'Discussions': 'https://github.com/driscollis/squall/discussions',\n                      'Documentation': 'https://github.com/driscollis/squall/blob/main/README.md',\n                      'Homepage': 'https://github.com/driscollis/squall',\n                      'Issues': 'https://github.com/driscollis/squall/issues',\n                      'Repository': 'https://github.com/driscollis/squall',\n                      'Wiki': 'https://github.com/driscollis/squall/wiki'}},\n 'tool': {'hatch': {'build': {'targets': {'sdist': {'exclude': ['*.pyc',\n                                                                '__pycache__',\n                                                                '*.so',\n                                                                '*.dylib'],\n                                                    'include': ['src/squall',\n                                                                'LICENSE',\n                                                                'README.md',\n                                                                'pyproject.toml']},\n                                          'wheel': {'include': ['py.typed',\n                                                                '**/*.py',\n                                                                '**/*.html',\n                                                                '**/*.gif',\n                                                                '**/*.jpg',\n                                                                '**/*.png',\n                                                                '**/*.md',\n                                                                '**/*.tcss'],\n                                                    'packages': ['src/squall']}}},\n                    'version': {'path': 'src/squall/__init__.py'}},\n          'pytest': {'ini_options': {'pythonpath': ['src']}}}}</pre><p>Awesome! You can now read a TOML file with Python and you get a nicely formatted dictionary!</p><p>The TOML format is great and well established, especially in the Python world. If you ever plan to create a package of your own, you will probably need to create a TOML file. If you work in dev/ops or as a system administrator, you may need to configure tools for CI/CD in the pyproject.toml file for Mypy, Flake8, Ruff, or some other tool.</p><p>Knowing how to read, write and edit a TOML file is a good tool to have in your kit. Check out Python’s  module for reading or if you need more power, check out <a href=\"https://pypi.org/project/tomlkit/\">tomlkit</a> or <a href=\"https://pypi.org/project/toml/\">toml</a>.</p>","contentLength":9628,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Creating a Simple XML Editor in Your Terminal with Python and Textual","url":"https://www.blog.pythonlibrary.org/2025/07/30/tui-xml-editor/","date":1753878654,"author":"Mike","guid":290,"unread":true,"content":"<p>Several years ago, I created an XML editor with the wxPython GUI toolkit called <a href=\"https://github.com/driscollis/BoomslangXML\">Boomslang</a>. I recently thought it would be fun to port that code to Textual so I could have an XML viewer and editor in my terminal as well.</p><p>In this article, you will learn how that experiment went and see the results. Here is a quick outline of what you will cover:</p><ul><li>Get the packages you will need</li><li>Creating the edit XML screen</li><li>Adding an XML preview screen</li><li>Creating file browser and warning screens</li><li>Creating the file save screen</li></ul><p>You will need <a href=\"https://github.com/Textualize/textual\">Textual</a> to be able to run the application detailed in this tutorial. You will also need <a href=\"https://lxml.de/\">lxml</a>, which is a super fast XML parsing package. You can install Textual using pip or uv. You can probably use uv with lxml as well, but pip definitely works.</p><p>Here’s an example using pip to install both packages:</p><pre data-enlighter-language=\"generic\">python -m pip install textual lxml</pre><p>Once pip has finished installing Textual and the lxml package and all its dependencies, you will be ready to continue!</p><p>The first step in creating the user interface is figuring out what it should look like. Here is the original Boomslang user interface that was created using wxPython:</p><p>You want to create something similar to this UI, but in your terminal. Open up your favorite Python IDE and create a new file called  and then enter the following code into it:</p><pre data-enlighter-language=\"python\">from pathlib import Path\n\nfrom .edit_xml_screen import EditXMLScreen\nfrom .file_browser_screen import FileBrowser\n\nfrom textual import on\nfrom textual.app import App, ComposeResult\nfrom textual.containers import Horizontal, Vertical\nfrom textual.widgets import Button, Header, Footer, OptionList\n\n\nclass BoomslangXML(App):\n    BINDINGS = [\n        (\"ctrl+o\", \"open\", \"Open XML File\"),\n    ]\n    CSS_PATH = \"main.tcss\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.title = \"Boomslang XML\"\n        self.recent_files_path = Path(__file__).absolute().parent / \"recent_files.txt\"\n        self.app_selected_file: Path | None = None\n        self.current_recent_file: Path | None = None\n\n    def compose(self) -&gt; ComposeResult:\n        self.recent_files = OptionList(\"\", id=\"recent_files\")\n        self.recent_files.border_title = \"Recent Files\"\n        yield Header()\n        yield self.recent_files\n        yield Vertical(\n            Horizontal(\n                Button(\"Open XML File\", id=\"open_xml_file\", variant=\"primary\"),\n                Button(\"Open Recent\", id=\"open_recent_file\", variant=\"warning\"),\n                id=\"button_row\",\n            )\n        )\n        yield Footer()\n\n    def on_mount(self) -&gt; None:\n        self.update_recent_files_ui()\n\n    def action_open(self) -&gt; None:\n        self.push_screen(FileBrowser())\n\n    def on_file_browser_selected(self, message: FileBrowser.Selected) -&gt; None:\n        path = message.path\n        if path.suffix.lower() == \".xml\":\n            self.update_recent_files_on_disk(path)\n            self.push_screen(EditXMLScreen(path))\n        else:\n            self.notify(\"Please choose an XML File!\", severity=\"error\", title=\"Error\")\n\n    @on(Button.Pressed, \"#open_xml_file\")\n    def on_open_xml_file(self) -&gt; None:\n        self.push_screen(FileBrowser())\n\n    @on(Button.Pressed, \"#open_recent_file\")\n    def on_open_recent_file(self) -&gt; None:\n        if self.current_recent_file is not None and self.current_recent_file.exists():\n            self.push_screen(EditXMLScreen(self.current_recent_file))\n\n    @on(OptionList.OptionSelected, \"#recent_files\")\n    def on_recent_files_selected(self, event: OptionList.OptionSelected) -&gt; None:\n        self.current_recent_file = Path(event.option.prompt)\n\n    def update_recent_files_ui(self) -&gt; None:\n        if self.recent_files_path.exists():\n            self.recent_files.clear_options()\n            files = self.recent_files_path.read_text()\n            for file in files.split(\"\\n\"):\n                self.recent_files.add_option(file.strip())\n\n    def update_recent_files_on_disk(self, path: Path) -&gt; None:\n        if path.exists() and self.recent_files_path.exists():\n            recent_files = self.recent_files_path.read_text()\n            if str(path) in recent_files:\n                return\n\n            with open(self.recent_files_path, mode=\"a\") as f:\n                f.write(str(path) + \"\\n\")\n\n            self.update_recent_files_ui()\n        elif not self.recent_files_path.exists():\n            with open(self.recent_files_path, mode=\"a\") as f:\n                f.write(str(path) + \"\\n\")\n\ndef main() -&gt; None:\n    app = BoomslangXML()\n    app.run()\n\nif __name__ == \"__main__\":\n    main()</pre><p>That’s a good chunk of code, but it’s still less than a hundred lines. You will go over it in smaller chunks though. You can start with this first chunk:</p><pre data-enlighter-language=\"python\">from pathlib import Path\n\nfrom .edit_xml_screen import EditXMLScreen\nfrom .file_browser_screen import FileBrowser\n\nfrom textual import on\nfrom textual.app import App, ComposeResult\nfrom textual.containers import Horizontal, Vertical\nfrom textual.widgets import Button, Header, Footer, OptionList\n\n\nclass BoomslangXML(App):\n    BINDINGS = [\n        (\"ctrl+o\", \"open\", \"Open XML File\"),\n    ]\n    CSS_PATH = \"main.tcss\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.title = \"Boomslang XML\"\n        self.recent_files_path = Path(__file__).absolute().parent / \"recent_files.txt\"\n        self.app_selected_file: Path | None = None\n        self.current_recent_file: Path | None = None</pre><p>You need a few imports to make your code work. The first import comes from Python itself and gives your code the ability to work with file paths. The next two are for a couple of small custom files you will create later on. The rest of the imports are from Textual and provide everything you need to make a nice little Textual application.</p><p>Next, you create the  class where you set up a keyboard binding and set which CSS file you will be using for styling your application.</p><p>The  method sets the following:</p><ul><li>The title of the application</li><li>The recent files path, which contains all the files you have recently opened</li><li>The currently selected file or None</li><li>The current recent file (i.e. the one you have open at the moment) or None</li></ul><p>Now you are ready to create the main UI:</p><pre data-enlighter-language=\"python\">def compose(self) -&gt; ComposeResult:\n    self.recent_files = OptionList(\"\", id=\"recent_files\")\n    self.recent_files.border_title = \"Recent Files\"\n    yield Header()\n    yield self.recent_files\n    yield Vertical(\n            Horizontal(\n                Button(\"Open XML File\", id=\"open_xml_file\", variant=\"primary\"),\n                Button(\"Open Recent\", id=\"open_recent_file\", variant=\"warning\"),\n                id=\"button_row\",\n            )\n        )\n    yield Footer()</pre><p>To create your user interface, you need a small number of widgets:</p><ul><li>A header to identify the name of the application</li><li>An OptionList which contains the recently opened files, if any, that the user can reload</li><li>A button to load a new XML file</li><li>A button to load from the selected recent file</li><li>A footer to show the application’s keyboard shortcuts</li></ul><p>Next, you will write a few event handlers:</p><pre data-enlighter-language=\"python\">def on_mount(self) -&gt; None:\n    self.update_recent_files_ui()\n\ndef action_open(self) -&gt; None:\n    self.push_screen(FileBrowser())\n\ndef on_file_browser_selected(self, message: FileBrowser.Selected) -&gt; None:\n    path = message.path\n    if path.suffix.lower() == \".xml\":\n        self.update_recent_files_on_disk(path)\n        self.push_screen(EditXMLScreen(path))\n    else:\n        self.notify(\"Please choose an XML File!\", severity=\"error\", title=\"Error\")\n</pre><p>The code above contains the logic for three event handlers:</p><ul><li>– After the application loads, it will update the OptionList by reading the text file that contains paths to the recent files.</li><li>– A keyboard shortcut action that gets called when the user presses CTRL+O. It will then show a file browser to the user so they can pick an XML file to load.</li><li><code>on_file_browser_selected()</code>– Called when the user picks an XML file from the file browser and closes the file browser. If the file is an XML file, you will reload the screen to allow XML editing. Otherwise, you will notify the user to choose an XML file.</li></ul><p>The next chunk of code is for three more event handlers:</p><pre data-enlighter-language=\"python\">@on(Button.Pressed, \"#open_xml_file\")\ndef on_open_xml_file(self) -&gt; None:\n    self.push_screen(FileBrowser())\n\n@on(Button.Pressed, \"#open_recent_file\")\ndef on_open_recent_file(self) -&gt; None:\n    if self.current_recent_file is not None and self.current_recent_file.exists():\n        self.push_screen(EditXMLScreen(self.current_recent_file))\n\n@on(OptionList.OptionSelected, \"#recent_files\")\ndef on_recent_files_selected(self, event: OptionList.OptionSelected) -&gt; None:\n    self.current_recent_file = Path(event.option.prompt)\n</pre><p>These event handlers use Textual’s handy decorator, which allows you to bind the event to a specific widget or widgets.</p><ul><li>– If the user presses the “Open XML File” button, this method is called and it will show the file browser.</li><li>– If the user presses the “Open Recent” button, this method gets called and will load the selected recent file.</li><li><code>on_recent_files_selected()</code>– When the user selects a recent file in the OptionList widget, this method gets called and sets the variable.</li></ul><p>You only have two more methods to go over. The first is for updating the recent files UI:</p><pre data-enlighter-language=\"python\">def update_recent_files_ui(self) -&gt; None:\n    if self.recent_files_path.exists():\n        self.recent_files.clear_options()\n        files = self.recent_files_path.read_text()\n        for file in files.split(\"\\n\"):\n            self.recent_files.add_option(file.strip())\n</pre><p>Remember, this method gets called by and it will update the OptionList, if the file exists. The first thing this code will do is clear the OptionList in preparation for updating it. Then you will read the text from the file and loop over each path in that file.</p><p>As you loop over the paths, you add them to the OptionList. That’s it! You now have a recent files list that the user can choose from.</p><p>The last method to write is for updating the recent files text file:</p><pre data-enlighter-language=\"python\">def update_recent_files_on_disk(self, path: Path) -&gt; None:\n    if path.exists() and self.recent_files_path.exists():\n        recent_files = self.recent_files_path.read_text()\n        if str(path) in recent_files:\n            return\n\n        with open(self.recent_files_path, mode=\"a\") as f:\n            f.write(str(path) + \"\\n\")\n\n        self.update_recent_files_ui()\n    elif not self.recent_files_path.exists():\n        with open(self.recent_files_path, mode=\"a\") as f:\n            f.write(str(path) + \"\\n\")\n</pre><p>When the user opens a new XML file, you want to add that file to the recent file list on disk so that the next time the user opens your application, you can show the user the recent files. This is a nice way to make loading previous files much easier.</p><p>The code above will verify that the file still exists and that your recent files file also exists. Assuming that they do, you will check to see if the current XML file is already in the recent files file. If it is, you don’t want to add it again, so you return.</p><p>Otherwise, you open the recent files file in append mode, add the new file to disk and update the UI.</p><p>If the recent files file does not exist, you create it here and add the new path.</p><p>Here are the last few lines of code to add:</p><pre data-enlighter-language=\"python\">def main() -&gt; None:\n    app = BoomslangXML()\n    app.run()\n\nif __name__ == \"__main__\":\n    main()</pre><p>Now you’re ready you move on and add some CSS styling to your UI.</p><p>Your XML editor doesn’t require extensive styling. In fact, there is nothing wrong with being minimalistic.</p><p>Open up your favorite IDE or text editor and create a new file named and then add the following code:</p><pre data-enlighter-language=\"css\">BoomslangXML {\n    #button_row {\n        align: center middle;\n    }\n\n    Horizontal{\n        height: auto;\n    }\n\n    OptionList {\n        border: solid green;\n    }\n\n    Button {\n        margin: 1;\n    }\n}</pre><p>Here you center the button row on your screen. You also set the container’s height to auto, which tells Textual to make the container fit its contents. You also add a border to your and a margin to your buttons.</p><p>The XML editor screen is fairly complex, so that’s what you will learn about next.</p><h2>Creating the Edit XML Screen</h2><p>The XML editor screen is more complex than the main screen of your application and contains almost twice as many lines of code. But that’s to be expected when you realize that most of your logic will reside here.</p><p>As before, you will start out by writing the full code and then going over it piece-by-piece. Open up your Python IDE and create a new file named and then enter the following code:</p><pre data-enlighter-language=\"python\">import lxml.etree as ET\nimport tempfile\nfrom pathlib import Path\n\nfrom .add_node_screen import AddNodeScreen\nfrom .preview_xml_screen import PreviewXMLScreen\n\nfrom textual import on\nfrom textual.app import ComposeResult\nfrom textual.containers import Horizontal, Vertical, VerticalScroll\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Footer, Header, Input, Tree\nfrom textual.widgets._tree import TreeNode\n\n\nclass DataInput(Input):\n    \"\"\"\n    Create a variant of the Input widget that stores data\n    \"\"\"\n\n    def __init__(self, xml_obj: ET.Element, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.xml_obj = xml_obj\n\n\nclass EditXMLScreen(ModalScreen):\n    BINDINGS = [\n        (\"ctrl+s\", \"save\", \"Save\"),\n        (\"ctrl+a\", \"add_node\", \"Add Node\"),\n        (\"p\", \"preview\", \"Preview\"),\n        (\"escape\", \"esc\", \"Exit dialog\"),\n    ]\n    CSS_PATH = \"edit_xml_screens.tcss\"\n\n    def __init__(self, xml_path: Path, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.xml_tree = ET.parse(xml_path)\n        self.expanded = {}\n        self.selected_tree_node: None | TreeNode = None\n\n    def compose(self) -&gt; ComposeResult:\n        xml_root = self.xml_tree.getroot()\n        self.expanded[id(xml_root)] = \"\"\n        yield Header()\n        yield Horizontal(\n            Vertical(Tree(\"No Data Loaded\", id=\"xml_tree\"), id=\"left_pane\"),\n            VerticalScroll(id=\"right_pane\"),\n            id=\"main_ui_container\",\n        )\n        yield Footer()\n\n    def on_mount(self) -&gt; None:\n        self.load_tree()\n\n    @on(Tree.NodeExpanded)\n    def on_tree_node_expanded(self, event: Tree.NodeExpanded) -&gt; None:\n        \"\"\"\n        When a tree node is expanded, parse the newly shown leaves and make\n        them expandable, if necessary.\n        \"\"\"\n        xml_obj = event.node.data\n        if id(xml_obj) not in self.expanded and xml_obj is not None:\n            for top_level_item in xml_obj.getchildren():\n                child = event.node.add_leaf(top_level_item.tag, data=top_level_item)\n                if top_level_item.getchildren():\n                    child.allow_expand = True\n                else:\n                    child.allow_expand = False\n            self.expanded[id(xml_obj)] = \"\"\n\n    @on(Tree.NodeSelected)\n    def on_tree_node_selected(self, event: Tree.NodeSelected) -&gt; None:\n        \"\"\"\n        When a node in the tree control is selected, update the right pane to show\n        the data in the XML, if any\n        \"\"\"\n        xml_obj = event.node.data\n        right_pane = self.query_one(\"#right_pane\", VerticalScroll)\n        right_pane.remove_children()\n        self.selected_tree_node = event.node\n\n        if xml_obj is not None:\n            for child in xml_obj.getchildren():\n                if child.getchildren():\n                    continue\n                text = child.text if child.text else \"\"\n                data_input = DataInput(child, text)\n                data_input.border_title = child.tag\n                container = Horizontal(data_input)\n                right_pane.mount(container)\n            else:\n                # XML object has no children, so just show the tag and text\n                if getattr(xml_obj, \"tag\") and getattr(xml_obj, \"text\"):\n                    if xml_obj.getchildren() == []:\n                        data_input = DataInput(xml_obj, xml_obj.text)\n                        data_input.border_title = xml_obj.tag\n                        container = Horizontal(data_input)\n                        right_pane.mount(container)\n\n    @on(Input.Changed)\n    def on_input_changed(self, event: Input.Changed) -&gt; None:\n        \"\"\"\n        When an XML element changes, update the XML object\n        \"\"\"\n        xml_obj = event.input.xml_obj\n        # self.notify(f\"{xml_obj.text} is changed to new value: {event.input.value}\")\n        xml_obj.text = event.input.value\n\n    def action_esc(self) -&gt; None:\n        \"\"\"\n        Close the dialog when the user presses ESC\n        \"\"\"\n        self.dismiss()\n\n    def action_add_node(self) -&gt; None:\n        \"\"\"\n        Add another node to the XML tree and the UI\n        \"\"\"\n\n        # Show dialog and use callback to update XML and UI\n        def add_node(result: tuple[str, str] | None) -&gt; None:\n            if result is not None:\n                node_name, node_value = result\n                self.update_xml_tree(node_name, node_value)\n\n        self.app.push_screen(AddNodeScreen(), add_node)\n\n    def action_preview(self) -&gt; None:\n        temp_directory = Path(tempfile.gettempdir())\n        xml_path = temp_directory / \"temp.xml\"\n        self.xml_tree.write(xml_path)\n        self.app.push_screen(PreviewXMLScreen(xml_path))\n\n    def action_save(self) -&gt; None:\n        self.xml_tree.write(r\"C:\\Temp\\books.xml\")\n        self.notify(\"Saved!\")\n\n    def load_tree(self) -&gt; None:\n        \"\"\"\n        Load the XML tree UI with data parsed from the XML file\n        \"\"\"\n        tree = self.query_one(\"#xml_tree\", Tree)\n        xml_root = self.xml_tree.getroot()\n        self.expanded[id(xml_root)] = \"\"\n\n        tree.reset(xml_root.tag)\n        tree.root.expand()\n\n        # If the root has children, add them\n        if xml_root.getchildren():\n            for top_level_item in xml_root.getchildren():\n                child = tree.root.add(top_level_item.tag, data=top_level_item)\n                if top_level_item.getchildren():\n                    child.allow_expand = True\n                else:\n                    child.allow_expand = False\n\n    def update_tree_nodes(self, node_name: str, node: ET.SubElement) -&gt; None:\n        \"\"\"\n        When adding a new node, update the UI Tree element to reflect the new element added\n        \"\"\"\n        child = self.selected_tree_node.add(node_name, data=node)\n        child.allow_expand = False\n\n    def update_xml_tree(self, node_name: str, node_value: str) -&gt; None:\n        \"\"\"\n        When adding a new node, update the XML object with the new element\n        \"\"\"\n        element = ET.SubElement(self.selected_tree_node.data, node_name)\n        element.text = node_value\n        self.update_tree_nodes(node_name, element)</pre><p>Phew! That seems like a lot of code if you are new to coding, but a hundred and seventy lines of code or so really isn’t very much. Most applications take thousands of lines of code.</p><p>Just the same, breaking the code down into smaller chunks will aid in your understanding of what’s going on.</p><p>With that in mind, here’s the first chunk:</p><pre data-enlighter-language=\"python\">import lxml.etree as ET\nimport tempfile\nfrom pathlib import Path\n\nfrom .add_node_screen import AddNodeScreen\nfrom .preview_xml_screen import PreviewXMLScreen\n\nfrom textual import on\nfrom textual.app import ComposeResult\nfrom textual.containers import Horizontal, Vertical, VerticalScroll\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Footer, Header, Input, Tree\nfrom textual.widgets._tree import TreeNode</pre><p>You have move imports here than you did in the main UI file. Here’s a brief overview:</p><ul><li>You import lxml to make parsing and editing XML easy.</li><li>You use Python’s module to create a temporary file for viewing the XML.</li><li>The module is used the same way as before.</li><li>You have a couple of custom Textual screens that you will need to code up and import.</li><li>The last six lines are all Textual imports for making this editor screen work.</li></ul><p>The next step is to subclass the widget in such a way that it will store XML element data:</p><pre data-enlighter-language=\"python\">class DataInput(Input):\n    \"\"\"\n    Create a variant of the Input widget that stores data\n    \"\"\"\n\n    def __init__(self, xml_obj: ET.Element, *args, **kwargs) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.xml_obj = xml_obj</pre><p>Here you pass in an XML object and store it off in an instance variable. You will need this to make editing and displaying the XML easy.</p><p>The second class you create is the :</p><pre data-enlighter-language=\"python\">class EditXMLScreen(ModalScreen):\n    BINDINGS = [\n        (\"ctrl+s\", \"save\", \"Save\"),\n        (\"ctrl+a\", \"add_node\", \"Add Node\"),\n        (\"p\", \"preview\", \"Preview\"),\n        (\"escape\", \"esc\", \"Exit dialog\"),\n    ]\n    CSS_PATH = \"edit_xml_screens.tcss\"\n\n    def __init__(self, xml_path: Path, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.xml_tree = ET.parse(xml_path)\n        self.expanded = {}\n        self.selected_tree_node: None | TreeNode = None</pre><p>The is a new screen that holds your XML editor. Here you add four keyboard bindings, a CSS file path and the method.</p><p>Your initialization method is used to create an lxml Element Tree instance. You also create an empty dictionary of expanded tree widgets and the selected tree node instance variable, which is set to .</p><p>Now you’re ready to create your user interface:</p><pre data-enlighter-language=\"python\">def compose(self) -&gt; ComposeResult:\n    xml_root = self.xml_tree.getroot()\n    self.expanded[id(xml_root)] = \"\"\n    yield Header()\n    yield Horizontal(\n        Vertical(Tree(\"No Data Loaded\", id=\"xml_tree\"), id=\"left_pane\"),\n        VerticalScroll(id=\"right_pane\"),\n        id=\"main_ui_container\",\n    )\n    yield Footer()\n\ndef on_mount(self) -&gt; None:\n    self.load_tree()\n</pre><p>Fortunately, the user interface needed for editing XML is fairly straightforward:</p><ul><li>You create a new header to add a new title to the screen.</li><li>You use a horizontally-oriented container to hold your widgets.\n<ul><li>Inside of the container, you have a tree control that holds the DOM of the XML on the left.</li><li>On the right, you have a vertical scrolling container.</li><li>Finally, you have a footer</li></ul></li></ul><p>You also set up the first item in your “expanded” dictionary, which is the root node from the XML.</p><p>Now you can write your first event handler for this class:</p><pre data-enlighter-language=\"python\">@on(Tree.NodeExpanded)\ndef on_tree_node_expanded(self, event: Tree.NodeExpanded) -&gt; None:\n    \"\"\"\n    When a tree node is expanded, parse the newly shown leaves and make\n    them expandable, if necessary.\n    \"\"\"\n    xml_obj = event.node.data\n    if id(xml_obj) not in self.expanded and xml_obj is not None:\n        for top_level_item in xml_obj.getchildren():\n            child = event.node.add_leaf(top_level_item.tag, data=top_level_item)\n            if top_level_item.getchildren():\n                child.allow_expand = True\n            else:\n                child.allow_expand = False\n        self.expanded[id(xml_obj)] = \"\"\n</pre><p>When the user expands a node in the tree control, the method will get called. You will extract the node’s data, if it has any. Assuming that there is data, you will then loop over any child nodes that are present.</p><p>For each child node, you will add a new leaf to the tree control. You check to see if the child has children too and set the flag accordingly. At the end of the code, you add then XML object to your dictionary.</p><p>The next method you need to write is an event handler for when a tree node is selected:</p><pre data-enlighter-language=\"python\">@on(Tree.NodeSelected)\ndef on_tree_node_selected(self, event: Tree.NodeSelected) -&gt; None:\n    \"\"\"\n    When a node in the tree control is selected, update the right pane to show\n    the data in the XML, if any\n    \"\"\"\n    xml_obj = event.node.data\n    right_pane = self.query_one(\"#right_pane\", VerticalScroll)\n    right_pane.remove_children()\n    self.selected_tree_node = event.node\n\n    if xml_obj is not None:\n        for child in xml_obj.getchildren():\n            if child.getchildren():\n                continue\n            text = child.text if child.text else \"\"\n            data_input = DataInput(child, text)\n            data_input.border_title = child.tag\n            container = Horizontal(data_input)\n            right_pane.mount(container)\n        else:\n            # XML object has no children, so just show the tag and text\n            if getattr(xml_obj, \"tag\") and getattr(xml_obj, \"text\"):\n                if xml_obj.getchildren() == []:\n                    data_input = DataInput(xml_obj, xml_obj.text)\n                    data_input.border_title = xml_obj.tag\n                    container = Horizontal(data_input)\n                    right_pane.mount(container)\n</pre><p>Wben the user selects a node in your tree, you need to update the righthand pane with the node’s contents. To do that, you once again extract the node’s data, if it has any. If it does have data, you loop over its children and update the right hand pane’s UI. This entails grabbing the XML node’s tags and values and adding a series of horizontal widgets to the scrollable container that makes up the right pane of your UI.</p><p>If the XML object has no children, you can simply show the top level node’s tag and value, if it has any.</p><p>The next two methods you will write are as follows:</p><pre data-enlighter-language=\"python\">@on(Input.Changed)\ndef on_input_changed(self, event: Input.Changed) -&gt; None:\n    \"\"\"\n    When an XML element changes, update the XML object\n    \"\"\"\n    xml_obj = event.input.xml_obj\n    xml_obj.text = event.input.value\n\ndef on_save_file_dialog_dismissed(self, xml_path: str) -&gt; None:\n    \"\"\"\n    Save the file to the selected location\n    \"\"\"\n    if not Path(xml_path).exists():\n        self.xml_tree.write(xml_path)\n        self.notify(f\"Saved to: {xml_path}\")\n\n</pre><p>The  method deals with widgets which are your special widgets. Whenever they are edited, you want to grab the XML object from the event and update the XML tag’s value accordingly. That way, the XML will always be up-to-date if the user decides they want to save it.</p><p>You can also add an auto-save feature which would also use the latest XML object when it is saving, if you wanted to.</p><p>The second method here, <code>on_save_file_dialog_dismissed()</code>, is called when the user dismisses the save dialog that is opened when the user presses&nbsp;. Here you check to see if the file already exists. If not, you create it. You could spend some time adding another dialog here that warns that a file exists and gives the option to the user whether or not to overwrite it.</p><p>Anyway, your next step is to write the keyboard shortcut action methods. There are four keyboard shortcuts that you need to create actions for.</p><pre data-enlighter-language=\"python\">def action_esc(self) -&gt; None:\n    \"\"\"\n    Close the dialog when the user presses ESC\n    \"\"\"\n    self.dismiss()\n\ndef action_add_node(self) -&gt; None:\n    \"\"\"\n    Add another node to the XML tree and the UI\n    \"\"\"\n\n    # Show dialog and use callback to update XML and UI\n    def add_node(result: tuple[str, str] | None) -&gt; None:\n        if result is not None:\n            node_name, node_value = result\n            self.update_xml_tree(node_name, node_value)\n\n    self.app.push_screen(AddNodeScreen(), add_node)\n\ndef action_preview(self) -&gt; None:\n    temp_directory = Path(tempfile.gettempdir())\n    xml_path = temp_directory / \"temp.xml\"\n    self.xml_tree.write(xml_path)\n    self.app.push_screen(PreviewXMLScreen(xml_path))\n\ndef action_save(self) -&gt; None:\n    self.app.push_screen(SaveFileDialog(), self.on_save_file_dialog_dismissed)\n</pre><p>The four keyboard shortcut event handlers are:</p><ul><li>– Called when the user pressed the “Esc” key. Exits the dialog.</li><li>– Called when the user presses . Opens the . If the user adds new data, the callback is called, which will then call to update the UI with the new information.</li><li>– Called when the user presses the “p” key. Creates a temporary file with the current contents of the XML object. Then opens a new screen that allows the user to view the XML as a kind of preview.</li><li>– Called when the user presses&nbsp;.</li></ul><p>The next method you will need to write is called :</p><pre data-enlighter-language=\"python\">def load_tree(self) -&gt; None:\n    \"\"\"\n    Load the XML tree UI with data parsed from the XML file\n    \"\"\"\n    tree = self.query_one(\"#xml_tree\", Tree)\n    xml_root = self.xml_tree.getroot()\n    self.expanded[id(xml_root)] = \"\"\n\n    tree.reset(xml_root.tag)\n    tree.root.expand()\n\n    # If the root has children, add them\n    if xml_root.getchildren():\n        for top_level_item in xml_root.getchildren():\n            child = tree.root.add(top_level_item.tag, data=top_level_item)\n            if top_level_item.getchildren():\n                child.allow_expand = True\n            else:\n                child.allow_expand = False\n</pre><p>The method above will grab the widget and the XML’s root element and then load the tree widget with the data. You check if the XML root object has any children (which most do) and then loop over the children, adding them to the tree widget.</p><p>You only have two more methods to write. Here they are:</p><pre data-enlighter-language=\"python\">def update_tree_nodes(self, node_name: str, node: ET.SubElement) -&gt; None:\n    \"\"\"\n    When adding a new node, update the UI Tree element to reflect the new element added\n    \"\"\"\n    child = self.selected_tree_node.add(node_name, data=node)\n    child.allow_expand = False\n\ndef update_xml_tree(self, node_name: str, node_value: str) -&gt; None:\n    \"\"\"\n    When adding a new node, update the XML object with the new element\n    \"\"\"\n    element = ET.SubElement(self.selected_tree_node.data, node_name)\n    element.text = node_value\n    self.update_tree_nodes(node_name, element)</pre><p>These two methods are short and sweet:</p><ul><li> – When the user adds a new node, you call this method which will update the node in the tree widget as needed.</li><li> – When a node is added, update the XML object and then call the UI updater method above.</li></ul><p>The last piece of code you need to write is the CSS for this screen. Open up a text editor and create a new file called  and then add the following code:</p><pre data-enlighter-language=\"css\">EditXMLScreen {\n    Input {\n        border: solid gold;\n        margin: 1;\n        height: auto;\n    }\n    Button {\n        align: center middle;\n    }\n    Horizontal {\n        margin: 1;\n        height: auto;\n    }\n}</pre><p>This CSS is similar to the other CSS file. In this case, you set the  widget’s height to auto. You also set the margin and border for that widget. For the buttons, you tell Textual to center all of them. Finally, you also set the margin and height of the horizontal container, just like you did in the other CSS file.</p><p>Now you are ready to learn about the add node screen!</p><p>When the user wants to add a new node to the XML, you will show an “add node screen”. This screen allows the user to enter a node (i.e., tag) name and value. The screen will then pass that new data to the callback which will update the XML object and the user interface. You have already seen that code in the previous section.</p><p>To get started, open up a new file named and enter the following code:</p><pre data-enlighter-language=\"python\">from textual import on\nfrom textual.app import ComposeResult\nfrom textual.containers import Horizontal, Vertical\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Button, Header, Footer, Input\n\n\nclass AddNodeScreen(ModalScreen):\n    BINDINGS = [\n        (\"escape\", \"esc\", \"Exit dialog\"),\n    ]\n    CSS_PATH = \"add_node_screen.tcss\"\n\n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.title = \"Add New Node\"\n\n    def compose(self) -&gt; ComposeResult:\n        self.node_name = Input(id=\"node_name\")\n        self.node_name.border_title = \"Node Name\"\n        self.node_value = Input(id=\"node_value\")\n        self.node_value.border_title = \"Node Value\"\n\n        yield Vertical(\n            Header(),\n            self.node_name,\n            self.node_value,\n            Horizontal(\n                Button(\"Save Node\", variant=\"primary\", id=\"save_node\"),\n                Button(\"Cancel\", variant=\"warning\", id=\"cancel_node\"),\n            ),\n            Footer(),\n            id=\"add_node_screen_ui\",\n        )\n\n    @on(Button.Pressed, \"#save_node\")\n    def on_save(self) -&gt; None:\n        self.dismiss((self.node_name.value, self.node_value.value))\n\n    @on(Button.Pressed, \"#cancel_node\")\n    def on_cancel(self) -&gt; None:\n        self.dismiss()\n\n    def action_esc(self) -&gt; None:\n        \"\"\"\n        Close the dialog when the user presses ESC\n        \"\"\"\n        self.dismiss()</pre><p>Following is an overview of each method of the code above:</p><ul><li>– Sets the title of the screen.</li><li>– Creates the user interface, which is made up of two widgets, a “Save” button, and a “Cancel” button.</li><li>-Called when the user presses the “Save” button. This will save the data entered by the user into the two inputs, if any.</li><li>– Called when the user presses the “Cancel” button. If pressed, the screen exits without saving.</li><li>– Called when the user presses the “Esc” key. If pressed, the screen exits without saving.</li></ul><p>That code is concise and straightforward.</p><p>Next, open up a text editor or use your IDE to create a file named which will contain the following CSS:</p><pre data-enlighter-language=\"css\">AddNodeScreen {\n    align: center middle;\n    background: $primary 30%;\n\n    #add_node_screen_ui {\n            width: 80%;\n            height: 40%;\n            border: thick $background 70%;\n            content-align: center middle;\n            margin: 2;\n        }\n\n    Input {\n        border: solid gold;\n        margin: 1;\n        height: auto;\n    }\n\n    Button {\n        margin: 1;\n    }\n\n    Horizontal{\n        height: auto;\n        align: center middle;\n    }\n}</pre><p>Your CSS functions as a way to quickly style individual widgets or groups of widgets. Here you set it up to make the screen a bit smaller than the screen underneath it (80% x 40%) so it looks like a dialog.</p><p>You set the border, height, and margin on your inputs. You add a margin around your buttons to keep them slightly apart. Finally, you add a height and alignment to the container.</p><p>You can try tweaking all of this to see how it changes the look and feel of the screen. It’s a fun way to explore, and you can do this with any of the screens you create.</p><p>The next screen to create is the XML preview screen.</p><h2>Adding an XML Preview Screen</h2><p>The XML Preview screen allows the user to check that the XML looks correct before they save it. Textual makes creating a preview screen short and sweet.</p><p>Open up your Python IDE and create a new file named and then enter the following code into it:</p><pre data-enlighter-language=\"python\">from textual import on\nfrom textual.app import ComposeResult\nfrom textual.containers import Center, Vertical\nfrom textual.screen import ModalScreen\nfrom textual.widgets import Button, Header, TextArea\n\n\nclass PreviewXMLScreen(ModalScreen):\n    CSS_PATH = \"preview_xml_screen.tcss\"\n\n    def __init__(self, xml_file_path: str, *args: tuple, **kwargs: dict) -&gt; None:\n        super().__init__(*args, **kwargs)\n        self.xml_file_path = xml_file_path\n        self.title = \"Preview XML\"\n\n    def compose(self) -&gt; ComposeResult:\n        with open(self.xml_file_path) as xml_file:\n            xml = xml_file.read()\n        text_area = TextArea(xml)\n        text_area.language = \"xml\"\n        yield Header()\n        yield Vertical(\n            text_area,\n            Center(Button(\"Exit Preview\", id=\"exit_preview\", variant=\"primary\")),\n            id=\"exit_preview_ui\",\n        )\n\n    @on(Button.Pressed, \"#exit_preview\")\n    def on_exit_preview(self, event: Button.Pressed) -&gt; None:\n        self.dismiss()</pre><p>There’s not a lot here, so you will go over the highlights like you did in the previous section:</p><ul><li>– Initializes a couple of instance variables:\n<ul><li>– Which is a temporary file path</li><li>– The title of the screen</li></ul></li><li>– The UI is created here. You open the XML file and read it in. Then you load the XML into a widget. Finally, you tell Textual to use a header, the text area widget and an exit button for your interface.</li><li>– Called when the user presses the “Exit Preview” button. As the name implies, this exits the screen.</li></ul><p>The last step is to apply a little CSS. Create a new file named and add the following snippet to it:</p><pre data-enlighter-language=\"css\">PreviewXMLScreen {\n    Button {\n        margin: 1;\n    }\n}</pre><p>All this CSS does is add a margin to the button, which makes the UI look a little nicer.</p><p>There are three more screens yet to write. The first couple of screens you will create are the file browser and warning screens.</p><h2>Creating the File Browser and Warning Screens</h2><p>The file browser is what the user will use to find an XML file that they want to open. It is also nice to have a screen you can use for warnings, so you will create that as well.</p><p>For now, you will call this file but you are welcome to separate these two screens into different files. The first half of the file will contain the imports and the class.</p><pre data-enlighter-language=\"python\">from pathlib import Path\n\nfrom textual import on\nfrom textual.app import ComposeResult\nfrom textual.containers import Center, Grid, Vertical\nfrom textual.message import Message\nfrom textual.screen import Screen\nfrom textual.widgets import Button, DirectoryTree, Footer, Label, Header\n\n\nclass WarningScreen(Screen):\n    \"\"\"\n    Creates a pop-up Screen that displays a warning message to the user\n    \"\"\"\n\n    def __init__(self, warning_message: str) -&gt; None:\n        super().__init__()\n        self.warning_message = warning_message\n\n    def compose(self) -&gt; ComposeResult:\n        \"\"\"\n        Create the UI in the Warning Screen\n        \"\"\"\n        yield Grid(\n            Label(self.warning_message, id=\"warning_msg\"),\n            Button(\"OK\", variant=\"primary\", id=\"ok_warning\"),\n            id=\"warning_dialog\",\n        )\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"\n        Event handler for when the OK button - dismisses the screen\n        \"\"\"\n       self.dismiss()\n       event.stop()\n\n</pre><p>The warning screen is made up of two widgets: a label that contains the warning message and an “OK” button. You also add a method to respond to the buton being pressed. You dismiss the screen here and stop the event from propagating up to the parent.</p><p>The next class you need to add to this file is the class:</p><pre data-enlighter-language=\"python\">class FileBrowser(Screen):\n    BINDINGS = [\n        (\"escape\", \"esc\", \"Exit dialog\"),\n    ]\n\n    CSS_PATH = \"file_browser_screen.tcss\"\n\n    class Selected(Message):\n        \"\"\"\n        File selected message\n        \"\"\"\n\n        def __init__(self, path: Path) -&gt; None:\n            self.path = path\n            super().__init__()\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.selected_file = Path(\"\")\n        self.title = \"Load XML Files\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Vertical(\n            Header(),\n            DirectoryTree(\"/\"),\n            Center(\n                Button(\"Load File\", variant=\"primary\", id=\"load_file\"),\n            ),\n            id=\"file_browser_dialog\",\n        )\n\n    @on(DirectoryTree.FileSelected)\n    def on_file_selected(self, event: DirectoryTree.FileSelected) -&gt; None:\n        \"\"\"\n        Called when the FileSelected Message is emitted from the DirectoryTree\n        \"\"\"\n        self.selected_file = event.path\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"\n        Event handler for when the load file button is pressed\n        \"\"\"\n        event.stop()\n\n        if self.selected_file.suffix.lower() != \".xml\" and self.selected_file.is_file():\n            self.app.push_screen(WarningScreen(\"ERROR: You must choose a XML file!\"))\n            return\n\n        self.post_message(self.Selected(self.selected_file))\n        self.dismiss()\n\n    def action_esc(self) -&gt; None:\n        \"\"\"\n        Close the dialog when the user presses ESC\n        \"\"\"\n        self.dismiss()</pre><p>The class is more complicated because it does a lot more than the warning screen does. Here’s a listing of the methods:</p><ul><li>– Initializes the currently selected file to an empty path and sets the title for the screen.</li><li>– Creates the UI. This UI has a header, a for browsing files and a button for loading the currently selected file.</li><li>– When the user selected a file in the directory tree, you grab the path and set the instance variable.</li><li>– When the user presses the “Load File” button, you check if the selected file is the correct file type. If not, you should a warning screen. If the file is an XML file, then you post a custom message and close the screen.</li><li>– Called when the user presses the key. Closes the screen.</li></ul><p>The last item to write is your CSS file. As you might expect, you should name it . Then put the following CSS inside of the file:</p><pre data-enlighter-language=\"css\">FileBrowser {\n    #file_browser_dialog {\n            width: 80%;\n            height: 50%;\n            border: thick $background 70%;\n            content-align: center middle;\n            margin: 2;\n            border: solid green;\n        }\n    Button {\n        margin: 1;\n        content-align: center middle;\n    }\n}</pre><p>The CSS code here should look pretty familiar to you. All you are doing is making the screen look like a dialog and then adding a margin and centering the button.</p><p>The last step is to create the file save screen.</p><h2>Creating the File Save Screen</h2><p>The file save screen is similar to the file browser screen with the main difference being that you are supplying a new file name that you want to use to save your XML file to.</p><p>Open your Python IDE and create a new file called and then enter the following code:</p><pre data-enlighter-language=\"python\">from pathlib import Path\n\nfrom textual import on\nfrom textual.app import ComposeResult\nfrom textual.containers import Vertical\nfrom textual.screen import Screen\nfrom textual.widgets import Button, DirectoryTree, Footer, Header, Input, Label\n\n\nclass SaveFileDialog(Screen):\n    CSS_PATH = \"save_file_dialog.tcss\"\n\n    def __init__(self) -&gt; None:\n        super().__init__()\n        self.title = \"Save File\"\n        self.root = \"/\"\n\n    def compose(self) -&gt; ComposeResult:\n        yield Vertical(\n            Header(),\n            Label(f\"Folder name: {self.root}\", id=\"folder\"),\n            DirectoryTree(\"/\"),\n            Input(placeholder=\"filename.txt\", id=\"filename\"),\n            Button(\"Save File\", variant=\"primary\", id=\"save_file\"),\n            id=\"save_dialog\",\n        )\n\n    def on_mount(self) -&gt; None:\n        \"\"\"\n        Focus the input widget so the user can name the file\n        \"\"\"\n        self.query_one(\"#filename\").focus()\n\n    def on_button_pressed(self, event: Button.Pressed) -&gt; None:\n        \"\"\"\n        Event handler for when the load file button is pressed\n        \"\"\"\n        event.stop()\n        filename = self.query_one(\"#filename\").value\n        full_path = Path(self.root) / filename\n        self.dismiss(f\"{full_path}\")\n\n    @on(DirectoryTree.DirectorySelected)\n    def on_directory_selection(self, event: DirectoryTree.DirectorySelected) -&gt; None:\n        \"\"\"\n        Called when the DirectorySelected message is emitted from the DirectoryTree\n        \"\"\"\n        self.root = event.path\n        self.query_one(\"#folder\").update(f\"Folder name: {event.path}\")</pre><p>The save file dialog code is currently less than fifty lines of code. Here is a breakdown of that code:</p><ul><li>– Sets the title of the screen and the default root folder.</li><li>– Creates the user interface, which consists of a header, a label (the root), the directory tree widget, an input for specifying the file name, and a “Save File” button.</li><li>– Called automatically by Textual after the method. Sets the input widget as the focus.</li><li>– Called when the user presses the “Save File” button. Grabs the filename and then create the full path using the root + filename. Finally, you send that full path back to the callback function via .</li><li>– Called when the user selects a directory. Updates the variable to the selected path as well as updates the label so the user knows which path is selected.</li></ul><p>The last item you need to write is the CSS file for this dialog. You will need to name the file and then add this code:</p><pre data-enlighter-language=\"css\">SaveFileDialog {\n    #save_dialog {\n            width: 80%;\n            height: 50%;\n            border: thick $background 70%;\n            content-align: center middle;\n            margin: 2;\n            border: solid green;\n        }\n    Button {\n        margin: 1;\n        content-align: center middle;\n    }\n}</pre><p>The CSS code above is almost identical to the CSS you used for the file browser code.</p><p>When you run the TUI, you should see something like the following demo GIF:</p><p>You have now created a basic XML editor and viewer using Python and Textual. There are lots of little improvements that you can add to this code. However, those updates are up to you to make.</p><p>Have fun working with Textual and create something new or contribute to a neat Textual project yourself!</p>","contentLength":44208,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","python"]}