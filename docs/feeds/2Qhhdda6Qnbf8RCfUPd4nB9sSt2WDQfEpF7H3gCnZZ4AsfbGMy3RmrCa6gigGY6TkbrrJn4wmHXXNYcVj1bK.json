{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"I've Updated My Minecraft Rust Reverse proxy !","url":"https://www.reddit.com/r/rust/comments/1k3whs6/ive_updated_my_minecraft_rust_reverse_proxy/","date":1745183071,"author":"/u/Shadoxter","guid":585,"unread":true,"content":"<p>A while back I shared my Minecraft reverse proxy <a href=\"https://github.com/shadowner/infrarust\">Infrarust</a>, which I built while learning Rust. What started as a simple domain-based Minecraft routing tool has grown significantly over the past few months, and I'd love to share what's new!</p><p>Infrarust is a Minecraft proxy written in Rust that exposes a single Minecraft server port and handles routing to different backend servers. But now it's more!</p><p>ðŸš€ Server Manager (v1.3.0)</p><ul><li><strong>On-demand server provisioning</strong>: Servers automatically start when players try to connect</li><li>: Idle servers shut down after configurable periods</li><li>: Support for Pterodactyl Panel API and local process management</li><li>: Proxy protocol is supported for both receiving it and sending it to a server !</li></ul><ul><li>Ban by IP, username, or UUID with custom durations</li><li>Persistent storage with automatic expiration</li><li>Detailed management via CLI commands</li></ul><ul><li>Real-time server and player management with commands like , , </li><li>Rich formatting with colors and tab completion</li></ul><ul><li>Automatic discovery of Minecraft servers in Docker containers</li><li>Dynamic reconfiguration when containers start/stop</li></ul><ul><li>Reorganized into specialized crates for better maintainability</li><li>Trait-based API design for flexibility</li><li>Standardized logging with the  ecosystem</li></ul><p>ðŸ“Š Telemetry support (v1.1.0)</p><ul><li>Custom Grafana dashboard to supervise the running proxy</li></ul><p>This project has been an incredible learning journey. When I first posted, macros scared me! Now I'm implementing trait-based abstractions and async providers. The Rust community resources have been invaluable in helping me learn more about this incredible language !</p><p>Check out the <a href=\"https://github.com/shadowner/infrarust\">GitHub repo</a> or visit the <a href=\"https://infrarust.dev/\">documentation</a> to get started (Not updated as of the latest version 1.3.0 was release not long ago).</p><p>I'd love to hear your feedback, especially on the code architecture and best practices. How does my approach to the provider system and async code look to a more experienced Rust developers (in crates/infrarust_server_manager)?</p><p>I'm still on a big refactor for my 2.0 release that doesn't have a release date at all. </p><p>Anyway, thanks for your time! ðŸ¦€</p>","contentLength":2036,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I made a thing","url":"https://www.reddit.com/r/rust/comments/1k3q6nh/i_made_a_thing/","date":1745165904,"author":"/u/Same_Breakfast_695","guid":588,"unread":true,"content":"<p>So the last couple of weeks I have been trying to reimplement Homebrew with rust, including some added concurrency and stuffs for better performance. Damn I might be in over my head. Brew is way more complex than I initially thought.</p><p>Anyway, bottle installs and casks should work for the most part (still some fringe mach-o patching issues and to be honest, I can't test every single bottle and cask)</p><p>Build from source is not yet implemented but I got most of the code ready.</p><p>If anyone wants to try it out, I'd be grateful for every bug report. I'll never find them on my own.</p>","contentLength":573,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Why Rust compiler (1.77.0 to 1.85.0) reserves 2x extra stack for large enum?","url":"https://www.reddit.com/r/rust/comments/1k3ouyq/why_rust_compiler_1770_to_1850_reserves_2x_extra/","date":1745162328,"author":"/u/Helpful_Garbage_7242","guid":590,"unread":true,"content":"<p>Almost a year ago I found an interesting case with Rust compiler version &lt;= 1.74.0 reserving stack larger than needed to model Result type with boxed error, the details are available here - <a href=\"https://baarse.substack.com/p/rust-enum-boxed-error-and-stack-size\">Rust: enum, boxed error and stack size mystery</a>. I could not find the root cause that time, only that updating to Rust &gt;= 1.75.0 fixes the issue.</p><p>Today I tried the code again on Rust 1.85.0, <a href=\"https://godbolt.org/z/6d1hxjnMv\">https://godbolt.org/z/6d1hxjnMv</a>, and to my surprise, the method  now reserves  bytes (4096 + 4096 + 24), but it feels that around 4096 bytes should be enough.</p><pre><code>example::fib2: push r15 push r14 push r12 push rbx sub rsp,0x1000 ; reserve 4096 bytes on stack mov QWORD PTR [rsp],0x0 sub rsp,0x1000 ; reserve 4096 bytes on stack mov QWORD PTR [rsp],0x0 sub rsp,0x18 ; reserve 24 bytes on stack mov r14d,esi mov rbx,rdi ... add rsp,0x2018 pop rbx pop r12 pop r14 pop r15 ret </code></pre><p>I checked all the versions from 1.85.0 to 1.77.0, and all of them reserve  bytes. However, the version 1.76.0 reserves  bytes, <a href=\"https://godbolt.org/z/o9reM4dW8\">https://godbolt.org/z/o9reM4dW8</a></p><pre><code> use std::hint::black_box; use thiserror::Error; #[derive(Error, Debug)] #[error(transparent)] pub struct Error(Box&lt;ErrorKind&gt;); #[derive(Error, Debug)] pub enum ErrorKind { #[error(\"IllegalFibonacciInputError: {0}\")] IllegalFibonacciInputError(String), #[error(\"VeryLargeError:\")] VeryLargeError([i32; 1024]) } pub fn fib0(n: u32) -&gt; u64 { match n { 0 =&gt; panic!(\"zero is not a right argument to fibonacci_reccursive()!\"), 1 | 2 =&gt; 1, 3 =&gt; 2, _ =&gt; fib0(n - 1) + fib0(n - 2), } } pub fn fib1(n: u32) -&gt; Result&lt;u64, Error&gt; { match n { 0 =&gt; Err(Error(Box::new(ErrorKind::IllegalFibonacciInputError(\"zero is not a right argument to Fibonacci!\".to_string())))), 1 | 2 =&gt; Ok(1), 3 =&gt; Ok(2), _ =&gt; Ok(fib1(n - 1).unwrap() + fib1(n - 2).unwrap()), } } pub fn fib2(n: u32) -&gt; Result&lt;u64, ErrorKind&gt; { match n { 0 =&gt; Err(ErrorKind::IllegalFibonacciInputError(\"zero is not a right argument to Fibonacci!\".to_string())), 1 | 2 =&gt; Ok(1), 3 =&gt; Ok(2), _ =&gt; Ok(fib2(n - 1).unwrap() + fib2(n - 2).unwrap()), } } fn main() { use std::mem::size_of; println!(\"Size of Result&lt;i32, Error&gt;: {}\", size_of::&lt;Result&lt;i32, Error&gt;&gt;()); println!(\"Size of Result&lt;i32, ErrorKind&gt;: {}\", size_of::&lt;Result&lt;i32, ErrorKind&gt;&gt;()); let r0 = fib0(black_box(20)); let r1 = fib1(black_box(20)).unwrap(); let r2 = fib2(black_box(20)).unwrap(); println!(\"r0: {}\", r0); println!(\"r1: {}\", r1); println!(\"r2: {}\", r2); } </code></pre><p>Is this an expected behavior? Do you know what is going on?</p>","contentLength":2437,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[Media] Corust - A collaborative Rust Playground","url":"https://www.reddit.com/r/rust/comments/1k3au5e/media_corust_a_collaborative_rust_playground/","date":1745110318,"author":"/u/_byl","guid":589,"unread":true,"content":"<p>Corust is an open source collaborative code editor for Rust with support for code execution.</p><p>While Rust Playground has been the go to way for me to test code snippets, when pair programming, I've found collaborative features useful for prototyping/reviewing code, so I thought it would be useful (and interesting!) to implement a collaborative playground for Rust. Much inspiration taken from Shepmaster (kirby) and the Rust Playground in code execution design, and collaborative editors like Rustpad.</p><p>Like the Rust Playground, Corust supports execution on stable/nightly/beta channels and cargo test/build/run in debug/release, and many top crates (~250 crates from lib.rs/std.atom, thanks to Kornel for quickly adding this!). Unlike the Playground, Corust does not yet support sharing gists, or extra tooling like viewing assembly, clippy, or rustfmt.</p><p>Stack is an Axum server, Next JS UI, CodeMirror editor, and docker for containerized execution. Collaboration uses operational transform (OT) for conflict resolution and the OT client is compiled to WebAssembly on the front end.</p><p>Added some Rust related easter eggs too. Hope Rustaceans find it useful!</p>","contentLength":1151,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Hexagonal Architecture Questions","url":"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust","date":1745109155,"author":"/u/roughly-understood","guid":587,"unread":true,"content":"<h3>Getting started with hexagonal architecture</h3><p>Our transition to hexagonal architecture begins here. We'll move from a tightly coupled, untestable nightmare to a happy place where production doesn't fall over at 3am.</p><p>We're going to transform the Very Bad Application gradually, zooming out a little at a time until you see the whole hexagon. Then I'll answer \"why hexagons?\". Promise.</p><p>I've omitted details like module names and folder structure for simplicity. Don't worry, though. Before this guide is over, you'll have a complete application template you can reuse across all your projects.</p><h3>The repository pattern in Rust</h3><p>The worst part of the Very Bad Application is undoubtedly having an HTTP handler making direct queries to an SQL database. This is a plus-sized violation of the Single Responsibility Principle.</p><p>Code that understands the HTTP request-response cycle shouldn't also understand SQL. Code that needs a database doesn't need to know how that database is implemented. These could not be more different concerns.</p><p>Hard-coding your handler to manage SQL transactions will come back to bite you if you switch to Mongo. That Mongo connection will need ripping out if you move to event streaming, to querying a CQRS service, or to making an intern do it by hand.</p><p>All of these are valid data stores. If you overcommit by hard-wiring any one of them into your system, you guarantee future pain when you can least afford it â€“ when you need to scale.</p><p>Repository is the general term for \"some store of data\". Our first step is to move the  handler away from SQL and towards the abstract concept of a repository.</p><p>A handler that says \"give me any store of data\" is much better than a handler that says \"give me this specific store of data, because it's the only one I know how to use\".</p><p>Your mind has undoubtedly turned to traits as Rust's way of defining behaviour as opposed to structure. How very astute of you. Let's define an  trait:</p><pre></pre><p>An  is some store of author data with (currently) one method: .</p><p> takes a reference to the data required to create an author <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-9\"></a>, and returns a  containing either a saved , or a specific error type describing everything that might go wrong while creating an author <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-10\"></a>.  Right now, that's just the existence of duplicate authors, but we'll come back to error handling.</p><p> is what's known as a domain trait. You might also have heard the term \"port\" before â€“ a point of entry to your business logic. A concrete implementation of a port (say, an SQLite ) is called an adapter. Starting to sound familiar?</p><p>For any code that requires access to a store of author data, this port is the source of truth for how every implementation behaves. Callers no longer have to think about SQL or message queues, they just invoke this API, and the underlying adapter does all the hard work.</p><p>,  and  are all examples of .</p><p>Domain models are the canonical representations of data accepted by your business logic. Nothing else will do. Let's see some definitions:</p><pre></pre><p>Now, these aren't very exciting models (they'll get more exciting when we talk about identifying the correct domain boundaries and the special concern of authentication in ). But they demonstrate how the domain defines what data flowing through the system must look like.</p><p>If you don't construct a valid  from the raw parts you've received over the wire (or from that intern), you can't call <code>AuthorRepository::create_author</code>. Sorry, jog on. ðŸ¤·</p><p>This pattern of newtyping should be familiar if you've read . If you haven't, I'll wait for you here.</p><p>Four special properties arise from this:</p><ol><li>Your business domain becomes the single source of truth for what it means to be an author, user, bank transaction or stock trade.</li><li>The flow of dependencies in your application points in only one direction: towards your domain.</li><li>Data structures within your domain are guaranteed to be in a valid state.</li><li>You don't allow third-party implementation details, like SQL transactions or RPC messages to flow through unrelated code.</li></ol><p>And this has immediate practical benefits:</p><ul><li>Easier navigation of the codebase for veterans and new joiners.</li><li>It's trivial to implement new data stores or input sources â€“ you just implement the corresponding domain trait.</li><li>Refactoring is dramatically simplified thanks to the absence of hard-coded implementation details. If an implementation of a domain trait changes, nothing about the domain code or anything downstream from it needs to change.</li><li>Testability skyrockets, because any domain trait, like  can be mocked. We'll see this in action shortly.</li></ul><p>Why do we distinguish <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-12\"></a> from <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-11\"></a>? Surely we could represent both saved and unsaved s as</p><pre></pre><p>Right now, with this exact application, this would be fine. It might be annoying to check whether  is  or  to distinguish whether  is saved or unsaved, but it would work.</p><p>However, we'd be mistaken in assuming that the data required to create an  and the representation of an existing  will never diverge. This is not at all true of real applications.</p><p>I've done a lot of work in onboarding and ID verification for fintechs. The data required to fully represent a customer is extensive. It can take many weeks to collect it and make an account fully operational.</p><p>This is pretty poor as a customer experience, and abandonment would be high if you took an all-or-nothing approach to account creation.</p><p>Instead, an initial outline of a customer's details is usually enough to create a basic profile. You get the customer interacting with the platform as soon as possible, and stagger the collection of the remaining data, fleshing out the model over time.</p><p>In this scenario, you don't want to represent some  and  in the same way.  may contain dozens of optional fields and relations that aren't required to create a record in the database. It would be brittle and inefficient to pass such a needlessly large struct when creating a customer.</p><p>What happens when the domain representation of a customer changes, but the data required to create one remains the same? You'd be forced to change your request handling code too. Or, you'd be forced to do what you should have done from the start â€“&nbsp;decouple these models.</p><p>Hexagonal architecture is about building for change. Although these models may look like duplicative boilerplate to begin with, don't be fooled. Your application will change. Your API  diverge from your domain representation.</p><p>By modeling persistent entities separately from requests to create them, you encode an incredible capacity to scale.</p><h3>Error types and hexagonal architecture</h3><p>Let's zoom in on <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-13\"></a>. It reveals some important properties of domain models and traits.</p><p>&nbsp;doesn't define failure cases such as an input name being invalid. This is the responsibility of the&nbsp;&nbsp;constructor (which in this case delegates to the&nbsp;&nbsp;constructor). Here's more on&nbsp;&nbsp;if you're unclear on this point.</p><p>&nbsp;defines failures that arise from coordinating the action of adapters. There are two categories: violations of business rules, like attempting to create a duplicate author, and unexpected errors that the domain doesn't know how to handle.</p><p>Much as our domain would like to pretend the real world doesn't exist,&nbsp;&nbsp;things can go wrong when calling a database. We could fail to start a transaction, or fail to commit it. The database could literally catch fire in the course of a request.</p><p>The domain doesn't know anything about database implementations. It doesn't know about transactions. It doesn't know about the fire hazards posed by large datacenters and your pyromaniac intern. It's oblivious to retry strategies, cache layers and dead letter queues (we'll talk about these in ).</p><p>But it needs some mechanism to propagate unexpected errors back up the call chain. This is typically achieved with a catch-all variant,&nbsp;, which wraps a general error type.&nbsp;&nbsp;is particularly convenient for this, since it includes a backtrace for any error it wraps.</p><p>As a result (no pun intended),&nbsp;&nbsp;is a complete description of everything that can go wrong when creating an author.</p><p>This is incredible news for callers of domain traits â€“ immensely powerful. Any code calling a port has a complete description of every error scenario it's expected to handle, and the compiler will make sure that it does.</p><p>But enough theorizing! Let's see this in practice.</p><h3>Implementing </h3><p>Here, I move the code required to interact with an SQLite database out of the Very Bad Application's  handler and into an implementation of .</p><p>We start by wrapping an sqlx connection pool in our own  type. Module paths for sqlx types are fully qualified to avoid confusion:</p><pre></pre><p>Wrapping types like  has the benefit of encapsulating a third-party dependencies within code of our own design. Remember the Very Bad Application's leaky  function <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-1\"></a>? Wrapping external libraries and exposing only the functionality your application needs is how we plug the leaks.</p><p>Again, don't worry about module structure for now. Get comfortable with the type definitions, then we'll assemble the pieces.</p><p>This constructor does what you'd expect, with the possible exception of the result it returns. This constructor isn't part of the  trait, so we're not bound by its strict opinions on the types of allowable error.</p><p> is an excellent crate for working with non-specific errors.  is equivalent to , and  says we don't care  error occurred, just that one did.</p><p>At the point where most applications are instantiating databases, the only reasonable thing to do with an error is log it to  or some log aggregation service.  simply wraps any sqlx error it encounters with some extra context <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-15\"></a>.</p><p>Now, the exciting stuff â€“&nbsp;the implementation of :</p><pre></pre><p>Look! Transaction management is now encapsulated within our  implementation of . The HTTP handler no longer has to know about it.</p><p> invokes the  method on , which isn't specified by the  trait, but gives  the freedom to set up and pass around transactions as it requires.</p><p>This is the beauty of abstracting implementation details behind traits. The trait defines what needs to happen, and the implementation decides how. None of the  is visible to code calling a trait method.</p><p>'s implementation of  knows all about SQLite error codes, and transforms any error corresponding to a duplicate author into the domain's preferred representation <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-18\"></a>.</p><p>Of course,&nbsp;, not being part of the domain's Garden of Eden, may encounter an error that the domain can't do much with&nbsp;<a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-19\"></a>.</p><p>This is a&nbsp;<code>500 Internal Server Error</code>&nbsp;in the making, but repositories shouldn't know about HTTP status codes. We need to pass it back up the chain in the form of&nbsp;<code>CreateAuthorError::Unknown</code>, both to inform the end user that something fell over, and to capture for debugging.</p><p>This is a situation that the program â€“ or at least the request handler â€“ can't recover from. Couldn't we&nbsp;? The domain can't do anything useful here, so why not skip the middleman and let the panic recovery middleware handle it?</p><p>Until very recently, I would have said yes â€“&nbsp;if the domain can't do any useful work with an error, panicking will save you from duplicating error handling logic between your request handler and your panic-catching middleware.</p><p>However, thanks to&nbsp;&nbsp;and a horrible realization I had in the shower, I've reversed my position.</p><p>Whether or not you consider the database falling over a recoverable error, there are two incontrovertible reasons not to panic:</p><ol><li>Panicking poisons held mutexes. If your application state is protected by an&nbsp;, panicking while you hold the guard will mean no other thread will ever be able to acquire it again. Your program is dead, and no amount of panic recovery middleware will bring it back.</li><li>Other Rust devs won't expect you to panic. Most likely, you won't be the person woken at 3am to debug your code. Strive to make it as unsurprising as possible. Follow established error handling conventions diligently. Return errors, don't panic.</li></ol><p>What about retry handling? Good question. We'll cover that in .</p><h3>Everything but the kitchen async</h3><p>Have you spotted it? The mismatch between our repository implementation and the trait definition.</p><p>Ok, you caught me. I simplified the definition of . There's actually more to it, because of course we want database calls to be async.</p><p>Writing to a file or calling a database server is precisely the kind of slow, blocking IO that we don't want to stall on.</p><p>We need to make  an async trait. Unfortunately, it's not quite as simple as writing</p><pre></pre><p>Rust understands this, and it will compile, but probably won't do what you expect.</p><p>Although writing  will cause your method's return value to be sugared into <code>Future&lt;Output = Result&lt;Author, CreateAuthorError&gt;&gt;</code>, it  get an automatic  bound.</p><p>As a result, your future can't be sent between threads. For web applications, this is useless.</p><p>Let's spell things out for the compiler!</p><pre></pre><p>Since our  and  are both , a  that wraps them can be too <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-20\"></a>.</p><p>But what good is a repository if its methods return thread-safe s, but the repo itself is bound to a single thread? Let's ensure  is  too.</p><pre></pre><p>Ugh, we're not done. Remember about 4,000 words ago when we wrapped our application state in an  to inject into an HTTP handler? Well, trust me, we did.</p><p> requires its contents to be both  and  to be either  itself!  on the topic if you'd like to know more.</p><pre></pre><p>Your instinct might now be to implement  for  instead of , since  is immutable and therefore . However, sqlx's connection pools are themselves , meaning  is too.</p><p>Naturally, if we're shuffling a repo between threads, Rust wants to be sure it won't be dropped unexpectedly. Let's reassure the compiler that every  will live for the whole program:</p><pre></pre><p>Finally, our web server, axum, requires injected data to be , giving our final trait definition:</p><pre></pre><h3>From the Very Bad Application to the merely Bad Application</h3><p>It's time to start putting these pieces together. Let's reassemble our  HTTP handler to take advantage of the  abstraction.</p><p>First, the definition of , which is the struct that contains the resources that should be available to every HTTP handler. This pattern should be familiar to users of both  and .</p><pre></pre><p> is now generic over . That is,  provides HTTP handlers with access to \"some store of author data\", giving them the ability to create authors without knowledge of the implementation.</p><p>We wrap whatever instance of  we receive in an , because axum is going to share it between as many async tasks as there are requests to our application.</p><p>This isn't our final destination â€“ eventually our HTTP handler won't even know it has to save something (ah, sweet oblivion).</p><p>We're not quite there yet, but this is a vast improvement. Check out the handler!</p><pre></pre><p>Doesn't your nervous system feel calmer to behold it?</p><p>Go on, take some deep breaths. Enjoy the moment.  if you need a reminder.</p><p>Ok, the walkthrough.  has access to an <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-22\"></a>, which it makes good use of. But first, it converts the raw <code>CreateAuthorHttpRequestBody</code> it received from the client into the holy domain representation <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-23\"></a>. Here's how:</p><pre></pre><p>Nothing fancy! Boilerplatey, you might think. This is by design. We have preemptively decoupled the HTTP API our application exposes to the world from the internal domain representation.</p><p>As you scale, you will thank this so-called boilerplate. You will name your firstborn child for it.</p><p>These two things can now change independently. Changing the domain doesn't necessarily force a new web API version. Changing the HTTP request structure does not require any change to the domain. Only the mapping in <code>CreateAuthorHttpRequestBody::into_domain</code> and its corresponding unit tests get updated.</p><p>This is a very special property. Changes to transport concerns or business logic no longer spread through your program like wildfire. Abstraction has been achieved.</p><p>Thanks to the pains we took to define all the errors an  is allowed to return, constructing an HTTP response is dreamy. In the error case, we map seamlessly to a serializable  using <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-24\"></a>:</p><pre></pre><p>If the author was found to be a duplicate, it means the client's request was correctly structured, but that the contents were unprocessable. Hence, we're aiming to respond <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-27\"></a>.</p><p>Important detail alert! Do you see how we're manually building an error message at <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-28\"></a>, even though <code>CreateAuthorError::to_string</code> could have produced this error for us?</p><p>This is another instance of aggressive decoupling of our transport concern (JSON over HTTP) from the domain. Returning full-fat, unpasteurised domain errors to users is an easy way to leak private details of your application. It also results in unexpected changes to HTTP responses when domain implementation details change!</p><p>If we get an error the domain didn't expect â€“&nbsp;<code>CreateAuthorError::Unknown</code>&nbsp;here â€“ that maps straight to&nbsp;<a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-26\"></a>.</p><p>The finer points of how you log the underlying cause will vary according to your needs. Crucially, however, the error itself is not exposed to the end user.</p><p>Finally, our success case <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-25\"></a>. We take a reference to the returned  and transform it into its public API counterpart. It gets sent on its way with status .</p><pre></pre><h3>Testing HTTP handlers with injected repositories</h3><p>Previously, our handler code was impossible to unit test, because we needed a real database instance to call them. Trying to exercise every failure mode of a database call with a real database is pure pain.</p><p>Those days are over. By injecting any type that implements , we open our HTTP handlers to unit testing with mock repositories.</p><pre></pre><p> is defined to hold the  it should return in response <code>AuthorRepository::create_author</code> calls <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-29\"></a><a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-30\"></a>.</p><p>The rather nasty type signature at <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-29\"></a> is due to the fact that  has a  bound, which means  must be .</p><p>Unfortunately for us,&nbsp;&nbsp;isn't&nbsp;, because its&nbsp;&nbsp;variant contains&nbsp;.&nbsp;&nbsp;isn't&nbsp;&nbsp;since it's designed to wrap unknown errors, which may not be&nbsp;&nbsp;themselves.&nbsp;&nbsp;is one common non-&nbsp;error.</p><p>Rather than passing&nbsp;&nbsp;a convenient&nbsp;<code>Result&lt;Author, CreateAuthorError&gt;</code>, we need to give it something cloneable â€“&nbsp;. But, as discussed,&nbsp;'s contents need to be&nbsp;&nbsp;for&nbsp;&nbsp;to be&nbsp;, so we're forced to wrap the&nbsp;&nbsp;in a&nbsp;. (I'm using a&nbsp;&nbsp;here, hence the&nbsp;, but&nbsp;&nbsp;also works with minor changes to the supporting code).</p><p>The mock implementation of  then deals with swapping a dummy value with the real result in order to return it to the test caller.</p><p>Here's the test for the case where the repository call succeeds. I leave the error case to your powerful imagination, but if you crave more Rust testing pearls, I'll have a comprehensive guide to unit testing for you soon!</p><pre></pre><p>At <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-31\"></a>, we construct a  with an arbitrary success . We expect that a  from the repo should produce a <code>Result::Ok(ApiSuccess&lt;CreateAuthorResponseData&gt;)</code> from the handler <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-32\"></a>.</p><p>This situation is simple to set up â€“&nbsp;we just call the  handler with a  object constructed from the  in place of a real one <a href=\"https://www.howtocodeit.com/articles/master-hexagonal-architecture-rust#code-ref-33\"></a>. The assertions are self-explanatory.</p><p>I know, I know â€“ you're itching to see what  looks like with these improvements, but we're about to take a much bigger and more important leap in our understanding of hexagonal architecture.</p><p>In Part III, coming next, I'll introduce you to the beating heart of an application domain: the .</p><p>We'll ratchet up the complexity of our example application to understand how to set domain boundaries. We'll confront the tricky problem of  through the lens of authentication, and explore the interface between hexagonal applications and distributed systems.</p><p>And yes, we'll finally answer, \"why hexagons?\".</p>","contentLength":19131,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1k3ah0b/hexagonal_architecture_questions/"},{"title":"A full data pipeline in Rust to explore how politicians use words","url":"https://www.reddit.com/r/rust/comments/1k37v1v/a_full_data_pipeline_in_rust_to_explore_how/","date":1745101126,"author":"/u/sufjanfan","guid":586,"unread":true,"content":"<p>I've built a little tool that allows you to search through transcripts of the most recent session of the Canadian House of Commons to generate breakdowns of how often members of parliament use your search term by party, gender, province, etc. Check it out <a href=\"https://housewords.chunkerbunker.cc/search\">here</a>!</p><p>It started with a very basic web scraper to download the Hansard transcripts in HTML format - didn't even need selenium. From there I populated a MariaDB database of MPs and other speakers mostly manually, and built a hacky translator to convert the transcripts into speech strings with a time and matchable name attached.</p><p>I hadnt scoped out the project much by that point and was just going to poke through the numbers myself with some SQL, but I had the silly idea to make it accessible through a web app, so I threw together an axum server and a frontend with yew and <a href=\"https://docs.rs/plotters/latest/plotters/\">plotters</a>. I added a few more graphs and features, jazzed up the style a bit, and tried to make the backend not waste too much processing time.</p><p>Eventually I'd like to have the scraper and translator work in a live pipeline to keep this thing updating as the house sits again after our election coming up. A time series selector, or at least a session selector, would be a good add in that case.</p><p>If you're a statistician you're probably horrified at this point, but I'm having fun and I think there's something worthwhile to play around with here even if none of this is rigorous enough to draw hard conclusions. This is a unique space and I'd like to explore it a bit more.</p>","contentLength":1501,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","rust"]}