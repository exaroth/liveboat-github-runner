{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"AstroBurst: astronomical FITS image processor in Rust â€” memmap2 + Rayon + WebGPU, 1.4 GB/s batch throughput","url":"https://www.reddit.com/r/rust/comments/1ri29nu/astroburst_astronomical_fits_image_processor_in/","date":1772383987,"author":"/u/Jazzlike_Wash6755","guid":589,"unread":true,"content":"<p>I've been building AstroBurst, a desktop app for processing astronomical FITS images. Sharing because the Rust ecosystem for scientific computing is underrepresented and I learned a lot. The result: JWST Pillars of Creation (NIRCam F470N/F444W/F335M) composed from raw pipeline data. 6 filters loaded and RGB-composed in 410ms.</p><p>Architecture â€¢ Tauri v2 for desktop (IPC via serde JSON, ~50Î¼s overhead per call) â€¢ memmap2 for zero-copy FITS I/O â€” 168MB files open in 0.18s, no RAM spike â€¢ ndarray + Rayon for parallel pixel operations (STF, stacking, alignment) â€¢ rustfft for FFT power spectrum and phase-correlation alignment â€¢ WebGPU compute shaders (WGSL) for real-time stretch/render on GPU â€¢ React 19 + TypeScript frontend with Canvas 2D fallback</p><p>What worked well memmap2 is perfect for FITS â€” the format is literally a contiguous header + pixel blob padded to 2880-byte blocks. Mmap gives you the array pointer directly, cast to f32/f64/i16 based on BITPIX. No parsing, no allocation.</p><p>Rayon's par_iter for sigma-clipped stacking across 10+ frames was almost free to parallelize. The algorithm is inherently per-pixel independent.</p><p>ndarray for 2D array ops felt natural coming from NumPy. The ecosystem is thinner (no built-in convolution, had to roll my own Gaussian kernel), but the performance is worth it.</p><p>â€¢ Started with anyhow everywhere. Should have used typed errors from the start â€” when you have 35 Tauri commands, the error context matters.</p><p>â€¢ ndarray ecosystem gaps: no built-in 2D convolution, no morphological ops, limited interop with image crates. Ended up writing ~2K lines of \"glue\" that NumPy/SciPy gives you for free. â€¢ FITS parsing by hand with memmap2 was educational but fragile. Would consider wrapping fitsio (cfitsio bindings) for the complex cases (MEF, compressed, tiled). Currently only supports single-HDU. â€¢ Should have added async prefetch from the start â€” loading 50 files sequentially with mmap is fast, but with io_uring/readahead it could pipeline even better.</p><p>The format is actually interesting from a systems perspective â€” designed in 1981 for tape drives, hence the 2880-byte block alignment (36 cards Ã— 80 bytes). Every header card is exactly 80 ASCII characters, keyword = value / comment. It's the one format where memmap truly shines because there's zero structure to decode beyond the header.</p><p>MIT licensed Â· Windows / macOS / Linux</p><p>PRs welcome, especially if anyone wants to tackle MEF (multi-extension FITS) support or cfitsio integration.</p>","contentLength":2508,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Building a large-scale local photo manager in Rust (filesystem indexing + SQLite + Tauri)","url":"https://www.reddit.com/r/rust/comments/1ri0oli/building_a_largescale_local_photo_manager_in_rust/","date":1772380374,"author":"/u/Hot-Butterscotch-396","guid":587,"unread":true,"content":"<p>Iâ€™ve been building an open-source desktop photo manager in Rust, mainly as an experiment in filesystem indexing, thumbnail pipelines, and large-library performance.</p><ul><li>SQLite (metadata index via rusqlite)</li><li>Vue 3 frontend (separate UI layer)</li></ul><p>The core problem Iâ€™m trying to solve:</p><p>Managing 100kâ€“500k local photos across multiple external drives without cloud sync, while keeping indexing and browsing responsive.</p><p>Current challenges Iâ€™m exploring:</p><ul><li>Balancing parallelism vs disk IO contention</li><li>Improving large-folder traversal speed on slow external drives</li><li>Memory usage under heavy thumbnail generation</li><li>Whether async brings real benefit here vs controlled thread pools</li></ul><p>Iâ€™d really appreciate feedback on architecture, concurrency patterns, or SQLite usage from a Rust perspective.</p>","contentLength":770,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I'm building a native desktop API client (like Postman) in Rust with GPUI. Would anyone use it?","url":"https://www.reddit.com/r/rust/comments/1rhzoei/im_building_a_native_desktop_api_client_like/","date":1772377970,"author":"/u/invictus_97K","guid":586,"unread":true,"content":"<p>I've been working on a side project: a native desktop HTTP client for testing APIs, similar to Postman or Insomnia, but built entirely in Rust using GPUI (the GPU-accelerated UI framework behind the Zed editor).</p><p>Postman has become bloated and requires a login. Insomnia had a controversial cloud-sync controversy. Bruno is great but Electron-based. I wanted something that is:</p><ul><li> â€” no Electron, no web tech, just GPU-rendered native UI</li><li> â€” collections stored as plain files on disk, no accounts, no cloud</li><li> â€” small binary, fast startup, low memory footprint</li></ul><ul><li>Organize requests into collections and folders</li><li>Edit URL, method, query params, headers, body, path variables</li><li>Query params sync bidirectionally with the URL bar</li><li>Send requests and inspect responses</li><li>Everything persists locally</li></ul><p><strong>What's missing (still early):</strong></p><ul><li>No environment variables yet</li><li>No auth helpers (Bearer, Basic, etc.)</li><li>No import/export (Postman collections, OpenAPI)</li><li>UI is functional but rough around the edges</li></ul><ul><li>GPUI for the UI (same framework as Zed)</li><li>Clean architecture: domain / application / infrastructure / presentation layers</li><li>Collections stored as TOML files</li></ul><p>I'm posting here to get a feel for whether there's interest in a tool like this before investing more time. Would you use a native Rust API client? What features would be must-haves for you?</p><p>Happy to answer questions or share more details.</p>","contentLength":1346,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Supercharge Rust functions with implicit arguments using CGP v0.7.0","url":"https://contextgeneric.dev/blog/v0.7.0-release/","date":1772370678,"author":"/u/soareschen","guid":590,"unread":true,"content":"<p><a href=\"https://crates.io/crates/cgp\" target=\"_blank\" rel=\"noopener noreferrer\"></a> has been released, bringing a major expansion to the CGP macro toolkit. The centerpiece of this release is a suite of new annotations â€” , , , , , and  â€” that let you write context-generic code in plain function syntax with dramatically less boilerplate than before.</p><p>If you are new here, Context-Generic Programming (CGP) is a modular programming paradigm for Rust that unlocks powerful design patterns for writing code that is generic over a context () type. CGP lets you define functions and implementations that work across many different context types without any manual boilerplate, all through Rust's own trait system and with zero runtime overhead.</p><div><div><p>Before diving into the specifics of this release, it is highly recommended that you read the new <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/\"><strong>Area Calculation Tutorials</strong></a>, which walk through the motivation for CGP and the v0.7.0 features in far greater depth than this post can cover.</p></div></div><h2>The problem: parameter threading and tight coupling<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#the-problem-parameter-threading-and-tight-coupling\" aria-label=\"Direct link to The problem: parameter threading and tight coupling\" title=\"Direct link to The problem: parameter threading and tight coupling\" translate=\"no\">â€‹</a></h2><p>To understand why v0.7.0 matters, it helps to appreciate the two limitations in conventional Rust that motivated it.</p><p>The first is <strong>explicit parameter threading</strong>. When a plain Rust function needs to pass values to another function, every intermediate caller in the chain must accept those values as arguments and forward them explicitly â€” even if they do not use them directly. As call chains grow, function signatures accumulate parameters that exist purely to satisfy the requirements of their callees.</p><p>The second is <strong>tight coupling to a concrete context struct</strong>. Rust developers often address parameter threading by grouping values into a single struct and defining methods on it. This does clean up the call signatures, but it tightly couples an implementation to one specific type. When the struct grows or needs to be extended, everything referencing it is affected, and there is no clean way to have multiple independent contexts share the same method without duplicating code.</p><p>CGP's  macro and  arguments, introduced in v0.7.0, address both of these problems at once.</p><h2>Define CGP functions using the  macro<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#define-cgp-functions-using-the-cgp_fn-macro\" aria-label=\"Direct link to define-cgp-functions-using-the-cgp_fn-macro\" title=\"Direct link to define-cgp-functions-using-the-cgp_fn-macro\" translate=\"no\">â€‹</a></h2><p>The centerpiece of v0.7.0 is the  macro, which lets us write context-generic code in plain function syntax. A function decorated with  accepts a  parameter that refers to a , and may mark any of its arguments with  to indicate that those values should be automatically extracted from the context rather than passed by the caller.</p><p>For example, here is how we define a context-generic function that computes the area of a rectangle:</p><p>Three annotations do the work here.  augments the plain function and turns it into a context-generic capability.  provides a reference to whatever context this function is called on. And  on both  and  tells CGP to fetch those values automatically from  instead of requiring the caller to supply them.</p><p>The function body itself is entirely conventional Rust â€” there are no new concepts to learn beyond the annotations.</p><p>To use this function on a concrete type, we define a minimal context and apply  to enable generic field access on it:</p><p>The  macro generates implementations that allow CGP to access the fields of  generically by field name. With that in place, we can call  as a method:</p><p>That's it. CGP propagates the fields to the function arguments automatically. You do not need to write any implementation for  beyond deriving .</p><h3>Importing other CGP functions with <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#importing-other-cgp-functions-with-uses\" aria-label=\"Direct link to importing-other-cgp-functions-with-uses\" title=\"Direct link to importing-other-cgp-functions-with-uses\" translate=\"no\">â€‹</a></h3><p>One of the most valuable properties of context-generic functions is their ability to compose with each other. The  attribute allows a CGP function to import another CGP function as a dependency, so that it can call it on  without the caller needing to know anything about the imported function's own requirements.</p><p>For example, here is how we define , which calls  internally:</p><p>The  attribute imports the  trait â€” the CamelCase name that  derives from the function name . We only need to declare  as an implicit argument, since  and  are already consumed internally by .</p><p>With  defined, we can introduce a second context that adds a  field:</p><p>Like , only  is needed. Both contexts can now coexist independently:</p><p>Importantly,  is never modified. It continues to support  on its own, and  is available only on contexts that also carry a  field. Two independent contexts can share the same function definitions without either one knowing about the other.</p><h3>Re-exporting imported CGP functions with <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#re-exporting-imported-cgp-functions-with-extend\" aria-label=\"Direct link to re-exporting-imported-cgp-functions-with-extend\" title=\"Direct link to re-exporting-imported-cgp-functions-with-extend\" translate=\"no\">â€‹</a></h3><p>The  attribute is analogous to Rust's  statement for importing module constructs. This means that the imported CGP functions are hidden behind the generated  bounds using .</p><p>The  attribute lets you import and  another CGP function, so that it is available to anyone who imports your function. This works similarly to Rust's  for re-exporting module constructs.</p><p>For example, we can rewrite  to use  instead of :</p><p>This means that any construct that imports  now also has access to . For example:</p><p>The <code>print_scaled_rectangle_area</code> function only needs to import , yet it can call both  and  on .</p><h2>Using  in <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#using-implicit-in-cgp_impl\" aria-label=\"Direct link to using-implicit-in-cgp_impl\" title=\"Direct link to using-implicit-in-cgp_impl\" translate=\"no\">â€‹</a></h2><p>CGP v0.7.0 also brings support for using  arguments inside , which is used to write named provider implementations for CGP components. This is especially useful when implementing traits defined with .</p><p>For example, here is how we define an  component and a named provider for it using implicit arguments:</p><p>Prior to v0.7.0, achieving the same result required defining a separate getter trait with , adding it to the provider's  clause, and calling its getter methods explicitly:</p><p>With , that entire layer of boilerplate disappears. The  and  values are fetched directly from the context, and there is no need to manually maintain a getter trait, a  clause, or individual method calls. Behind the scenes,  in  is semantically equivalent to  and is equally zero cost.</p><p>CGP v0.7.0 also introduces the  attribute for ergonomic import of other providers inside higher-order provider implementations. This is particularly useful when building providers that delegate part of their computation to a pluggable inner provider.</p><p>For example, suppose we want a general  that wraps any inner  provider and applies a scale factor to its result. We can now write this as follows:</p><p>The  attribute declares that  must implement the  provider trait. Before this attribute was available, we had to write the same constraint manually in the  clause with an explicit  parameter:</p><p>The main ergonomic improvement is that  automatically inserts  as the first generic parameter to the provider trait, so you can treat provider traits the same way as consumer traits without needing to understand the underlying difference. The provider can then be composed into any context via :</p><p>This shows that CGP providers are just plain Rust types, and higher-order providers like <code>ScaledAreaCalculator&lt;RectangleAreaCalculator&gt;</code> are simply generic type instantiations. No new runtime concepts are involved.</p><h2>Abstract type import with <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#abstract-type-import-with-use_type\" aria-label=\"Direct link to abstract-type-import-with-use_type\" title=\"Direct link to abstract-type-import-with-use_type\" translate=\"no\">â€‹</a></h2><p>CGP v0.7.0 also introduces the  attribute for ergonomic import of abstract associated types. This lets you write context-generic functions that work with abstract types â€” such as a  type that might be , , or any other numeric type â€” without needing to write  prefixes everywhere.</p><p>For example, here is how we define a version of  that is generic over any scalar type by importing the  associated type from a  trait:</p><p>Without , the same function would require  throughout, which is noisier. Under the hood, <code>#[use_type(HasScalarType::Scalar)]</code> desugars to  and rewrites all references to the bare  identifier back to :</p><p>We can now define context types that use different scalar types. For example, here is a rectangle that uses  instead of :</p><p>And  will work seamlessly with  values:</p><p>The  attribute is also supported in both  and , making it uniformly available across the entire CGP surface:</p><h2>\"Isn't this just Scala implicits?\"<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#isnt-this-just-scala-implicits\" aria-label=\"Direct link to &quot;Isn't this just Scala implicits?&quot;\" title=\"Direct link to &quot;Isn't this just Scala implicits?&quot;\" translate=\"no\">â€‹</a></h2><p>The word \"implicit\" may raise a flag for developers familiar with Scala's implicit parameter system â€” a feature with a well-documented reputation for producing confusing errors, ambiguous resolution, and code that is hard to trace. It's a fair concern, and it deserves a direct answer: CGP's  attribute shares the same surface-level motivation as Scala implicits (reducing boilerplate at call sites), but the underlying mechanisms are categorically different in the ways that matter most.</p><p> In Scala, the compiler searches a broad, layered  that spans local variables, companion objects, and imports â€” meaning an implicit value can materialize from almost anywhere. In CGP,  always resolves to a field on , and nowhere else. There is no ambient environment, no companion object search, and no imports to reason about.</p><p> Scala's type-only resolution means two in-scope values of the same type create an ambiguity that requires explicit disambiguation. CGP resolves by :  looks for a field named specifically  of type . Because Rust structs cannot have two fields with the same name, CGP implicit arguments are unambiguous by construction.</p><p> Every  annotation expands mechanically into a  trait bound and a  call â€” ordinary Rust constructs that any developer can read and verify. There is no hidden resolution phase, no special compiler magic, and no \"implicit hell\" accumulation risk.</p><h2>New area calculation tutorials<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#new-area-calculation-tutorials\" aria-label=\"Direct link to New area calculation tutorials\" title=\"Direct link to New area calculation tutorials\" translate=\"no\">â€‹</a></h2><p>To accompany this release, two new <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/\"><strong>area calculation tutorials</strong></a> have been published that build up the full CGP feature set from first principles.</p><p>The <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/context-generic-functions\"><strong>Context-Generic Functions</strong></a> tutorial starts from plain Rust and introduces , , and . It walks through the full desugaring of  into Rust traits and blanket implementations, explains the -based zero-cost field access model, and compares CGP's implicit arguments to Scala's implicit parameters for readers coming from other ecosystems.</p><p>The <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/static-dispatch\"></a> tutorial introduces a second shape â€” the circle â€” to motivate a unified  interface. It demonstrates Rust's coherence restrictions as a concrete problem, then resolves them using  and named providers defined with . Finally, it covers  for configurable static dispatch and  for composing higher-order providers.</p><p>Both tutorials are designed to be read sequentially and assume no prior knowledge of CGP beyond basic Rust familiarity.</p><p>CGP v0.7.0 ships with preliminary support for <a href=\"https://agentskills.io/home\" target=\"_blank\" rel=\"noopener noreferrer\">agent skills</a> for LLMs. The <a href=\"https://contextgeneric.dev/docs/ai-assisted-development/skills/\"></a> document is specifically written to teach LLMs about CGP in a compact way.</p><p>If you would like to try out CGP with the assistance of an LLM, we recommend including the CGP skill in your prompts so that you can ask it to clarify any CGP concept.</p><p>v0.7.0 includes several minor breaking changes. The vast majority of existing CGP code is unaffected; the sections below describe what to look for and how to migrate.</p><h3>Removal of <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#removal-of-cgp_context\" aria-label=\"Direct link to removal-of-cgp_context\" title=\"Direct link to removal-of-cgp_context\" translate=\"no\">â€‹</a></h3><p>The  macro has been removed, following its deprecation in v0.6.0. It is now idiomatic to define context types directly without any additional CGP macro applied to them.</p><p>Affected code can follow the migration guide in the <a href=\"https://contextgeneric.dev/blog/v0-6-0-release\">v0.6.0 post</a> to use the context type for delegation directly, instead of through a  delegation table.</p><h3>Change of consumer trait blanket implementation<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#change-of-consumer-trait-blanket-implementation\" aria-label=\"Direct link to Change of consumer trait blanket implementation\" title=\"Direct link to Change of consumer trait blanket implementation\" translate=\"no\">â€‹</a></h3><p>The blanket implementation of consumer traits generated by  has been simplified. For example, given:</p><p>The generated blanket implementation is now:</p><p>That is, a  type implements the consumer trait if it also implements the provider trait with itself as the context type.</p><p>Prior to this, the blanket implementation involved an additional table lookup similar to the provider trait:</p><p>Since the provider trait's blanket implementation already performs the  lookup, the consumer trait no longer needs to repeat it. This also introduces the nice property that a provider trait implementation can satisfy the consumer trait directly, which may be useful in niche cases where a context acts as its own provider.</p><div><div><p>A consequence of this change is that when both the consumer trait and provider trait are in scope, there may be ambiguity when calling static methods on the context. Because a context that implements a consumer trait through  is also its own provider, Rust cannot determine which trait implementation to use without an explicit  receiver. Calls through  are unaffected.</p></div></div><p>With the removal of , it is now idiomatic to always build the delegate lookup table directly on the context type. The  and <code>delegate_and_check_components!</code> macros have been updated accordingly.</p><h4>Implicit check trait name<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#implicit-check-trait-name\" aria-label=\"Direct link to Implicit check trait name\" title=\"Direct link to Implicit check trait name\" translate=\"no\">â€‹</a></h4><p>The check trait name can now be omitted:</p><p>By default, the macros generate a check trait named . The name can be overridden with a  attribute:</p><p>The following old syntax is :</p><p>The reason for the change is that it is simpler to parse an optional attribute at the start of a macro invocation than an optional name before a  keyword. The  syntax is both easier to implement and more consistent with how other CGP macros accept optional configuration.</p><p>The <code>delegate_and_check_components!</code> macro now supports  for CGP components that carry generic parameters. For example, given:</p><p>You can now both delegate and check a specific instantiation in one block:</p><p>To skip checking a particular component, use :</p><p>This is useful when you prefer to perform more complex checks using a dedicated  block.</p><h3>Use  instead of  for owned getter field values<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#use-copy-instead-of-clone-for-owned-getter-field-values\" aria-label=\"Direct link to use-copy-instead-of-clone-for-owned-getter-field-values\" title=\"Direct link to use-copy-instead-of-clone-for-owned-getter-field-values\" translate=\"no\">â€‹</a></h3><p>Rust programmers prefer explicit  calls when passing owned values to function parameters. To align with this principle,  now requires  instead of  when the returned getter values are owned. For example:</p><p>The abstract type  must now implement  for the getter trait to work. The same requirement applies to  arguments:</p><p>The  requirement prevents potential surprises when an expensive value is implicitly cloned into an owned implicit argument.</p><h3>Removal of  type alias from <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#removal-of-typeof-type-alias-from-cgp_type\" aria-label=\"Direct link to removal-of-typeof-type-alias-from-cgp_type\" title=\"Direct link to removal-of-typeof-type-alias-from-cgp_type\" translate=\"no\">â€‹</a></h3><p>The  macro no longer generates a type alias in the  form. For example, given:</p><p>The macro would previously generate:</p><p>This alias was originally provided to assist with abstract types in nested contexts. The new  attribute offers significantly better ergonomics for those same use cases, so the aliases are no longer expected to be used.</p><h3>Rename  to <a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#rename-providetype-to-typeprovider\" aria-label=\"Direct link to rename-providetype-to-typeprovider\" title=\"Direct link to rename-providetype-to-typeprovider\" translate=\"no\">â€‹</a></h3><p>The  CGP trait is used internally by  to generate helper type providers. Its provider trait was previously named  with a component named :</p><p>v0.7.0 renames the provider to  and the component to :</p><p>This brings the naming in line with the convention established by . For example, given:</p><p>The generated provider name is  and the component name is <code>ScalarTypeProviderComponent</code>.</p><h2>Getting started with v0.7.0<a href=\"https://contextgeneric.dev/blog/v0.7.0-release/#getting-started-with-v070\" aria-label=\"Direct link to Getting started with v0.7.0\" title=\"Direct link to Getting started with v0.7.0\" translate=\"no\">â€‹</a></h2><p>CGP v0.7.0 represents the most significant ergonomics improvement to the library since its initial release. The combination of , , , and  removes the most common sources of boilerplate in CGP code â€” getter traits, manual  clauses, and  prefixes â€” while keeping the generated code fully transparent and zero cost.</p><p>If you are new to CGP, the <a href=\"https://contextgeneric.dev/docs/tutorials/area-calculation/\"><strong>Area Calculation Tutorials</strong></a> are the best place to start. They build up the full picture from plain Rust functions all the way to composable, context-generic providers with pluggable static dispatch.</p>","contentLength":14781,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1rhwxnd/supercharge_rust_functions_with_implicit/"},{"title":"ðŸŒŠ semwave: Fast semver bump propagation","url":"https://www.reddit.com/r/rust/comments/1rhvrbm/semwave_fast_semver_bump_propagation/","date":1772367023,"author":"/u/IAmTsunami","guid":585,"unread":true,"content":"<p>Recently I started working on the tool to solve a specific problem at my company: incorrect version bump propagation in Rust project, given some bumps of dependencies. This problem leads to many bad things, including breaking downstream code, internal registry inconsistencies, angry coworkers, etc.</p><p> won't help here (as it only checks the code for breaking changes, without propagating bumps to dependents that 'leak' this code in their public API), and <a href=\"https://rust-lang.github.io/rfcs/1977-public-private-dependencies.html\">private dependencies</a> are not ready yet. That's why I decided to make <a href=\"https://github.com/uandere/semwave\"></a>.</p><p>Basically, it answers the question:</p><blockquote><p>\"If I bump crates A, B and C in this Rust project - what else do I need to bump and how?\"</p></blockquote><p> will take the crates that changed their versions (the \"seeds\") in a breaking manner and \"propagate\" the bump wave through your workspace, so you don't have to wonder \"Does crate X depends on Y in a breaking or a non-breaking way\"? The result is three lists: MAJOR bumps, MINOR bumps, and PATCH bumps, plus optional warnings when it had to guess conservatively. It doesn't need conventional commits and it is super light and fast, as we only operate on versions (not the code) of crates and their dependents.</p><p>Under the hood, it walks the workspace dependency graph starting from the seeds. For each dependent, it checks whether the crate leaks any seed types in its public API by analyzing its  JSON. If it does, that crate itself needs a bump - and becomes a new seed, triggering the same check on its dependents, and so on until the wave settles.</p><p>I find it really useful for large Cargo workspaces, like  repo (although you can use it for simple crates too). For example, here's my tool answering the question \"What happens if we introduce breaking changes to arrayvec AND itertools in rust-analyzer repo?\":</p><pre><code>&gt; semwave --direct arrayvec,itertools Direct mode: assuming BREAKING change for {\"arrayvec\", \"itertools\"} Analyzing stdx for public API exposure of [\"itertools\"] -&gt; stdx leaks itertools (Minor): -&gt; xtask is binary-only, no public API to leak Analyzing vfs for public API exposure of [\"stdx\"] -&gt; vfs leaks stdx (Minor): Analyzing test-utils for public API exposure of [\"stdx\"] -&gt; test-utils leaks stdx (Minor): Analyzing vfs-notify for public API exposure of [\"stdx\", \"vfs\"] -&gt; vfs-notify leaks stdx (Minor): -&gt; vfs-notify leaks vfs (Minor): Analyzing syntax for public API exposure of [\"itertools\", \"stdx\"] ... === Analysis Complete === MAJOR-bump list (Requires MAJOR bump / â†‘.0.0): {} MINOR-bump list (Requires MINOR bump / x.â†‘.0): {\"project-model\", \"syntax-bridge\", \"proc-macro-srv\", \"load-cargo\", \"hir-expand\", \"ide-completion\", \"hir-def\", \"cfg\", \"vfs\", \"ide-diagnostics\", \"ide\", \"ide-db\", \"span\", \"ide-ssr\", \"rust-analyzer\", \"ide-assists\", \"base-db\", \"stdx\", \"syntax\", \"test-utils\", \"vfs-notify\", \"hir-ty\", \"proc-macro-api\", \"tt\", \"test-fixture\", \"hir\", \"mbe\", \"proc-macro-srv-cli\"} PATCH-bump list (Requires PATCH bump / x.y.â†‘): {\"xtask\"} </code></pre><p>I would really appreciate any activity under this post and/or <a href=\"https://github.com/uandere/semwave\">Github repo</a> as well as any questions/suggestions.</p><p>P.S. The tool is in active development and is unstable at the moment. Additionally, for the first version of the tool I used LLM (to quickly validate the idea), so please beware of that. Now I don't use language models and write the tool all by myself.</p>","contentLength":3269,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"How much did Rust help you in your work?","url":"https://www.reddit.com/r/rust/comments/1rhts1u/how_much_did_rust_help_you_in_your_work/","date":1772360053,"author":"/u/therealsyumjoba","guid":588,"unread":true,"content":"<p>After years of obsessed learning for Rust along with its practices and semantics, it is really helping in my career, so much so that I would not shy away from admitting that Rust has been the prime factory in making me a hireable profile. </p><p>I basically have to thank Rust for making me able to write code that can go in production and not break even under unconventional circumstances.</p><p>I was wondering how much is Rust helping with careers and whatnot over here.</p><p>I wanna clarify, I did not simply \"land a Rust job\", I adopted Rust in my habits and it made me capable to subscribe to good contracts and deliver.</p>","contentLength":606,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","rust"]}