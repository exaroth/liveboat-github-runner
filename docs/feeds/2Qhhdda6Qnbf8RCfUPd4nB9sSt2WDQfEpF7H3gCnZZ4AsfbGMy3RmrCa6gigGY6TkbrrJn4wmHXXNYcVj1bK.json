{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Building the MagicMirror in Rust with iced GUI Library ü¶Ä","url":"https://www.reddit.com/r/rust/comments/1ipzubj/building_the_magicmirror_in_rust_with_iced_gui/","date":1739620595,"author":"/u/amindiro","guid":629,"unread":true,"content":"<p>I recently embarked on a journey to build a custom MagicMirror using the Rust programming language, and I‚Äôd like to share my experiences. I wrost a blog post titled <a href=\"https://aminediro.com/posts/mirrors/#mirrors\">\"software you can love: miroir √î mon beau miroir\"</a> this project was my attempt to create a stable, resource-efficient application for the Raspberry Pi 3A.</p><p>Here's what I loved about using Rust and the iced GUI library:</p><ul><li><p><strong>Elm Architecture + Rust is a match made in heaven:</strong> iced was perfect for my needs with its Model, View, and Update paradigms. It helped keep my state management concise and leverage Rust type system</p></li><li><p> Opting for this lightweight rendering library reduced the size of the binary significantly, ending with a 9MB binary.</p></li><li><p> Although troublesome at first, I used ‚Äòcross‚Äô to cross compile Rust for armv7.</p></li></ul><p>If anyone is keen, I‚Äôm thinking of open-sourcing this project and sharing it with the community. Insights on enhancing the project's functionality or any feedback would be much appreciated!</p><p>Feel free to reach out if you're interested in the technical nitty-gritty or my experience with Rust GUI libraries in general.</p>","contentLength":1098,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Bringing Nest.js to Rust: Meet Toni.rs, the Framework You‚Äôve Been Waiting For! üöÄ","url":"https://www.reddit.com/r/rust/comments/1iprsmo/bringing_nestjs_to_rust_meet_tonirs_the_framework/","date":1739587338,"author":"/u/Mysterious-Rust","guid":630,"unread":true,"content":"<p>As a Rust developer coming from TypeScript, I‚Äôve been missing a Nest.js-like framework ‚Äî its modularity, dependency injection, and CLI superpowers. But since the Rust ecosystem doesn‚Äôt have a direct counterpart (yet!), I decided to build one myself! üõ†Ô∏è</p><p>Introducing‚Ä¶ <a href=\"https://crates.io/crates/toni\">Toni.rs</a> ‚Äî a Rust framework inspired by the Nest.js architecture, designed to bring the same developer joy to our favorite language. And it‚Äôs live in beta! üéâ</p><p>Here‚Äôs what makes this project interesting:</p><p>Scalable maintainability üß©:</p><p>A modular architecture keeps your business logic decoupled and organized. Say goodbye to spaghetti code ‚Äî each module lives in its own context, clean and focused.</p><p>Need a complete CRUD setup? Just run a single CLI command. And I have lots of ideas for CLI ease. Who needs copy and paste?</p><p>Automatic Dependency Injection ü§ñ:</p><p>Stop wasting time wiring dependencies. Declare your providers, add them to your structure, and let the framework magically inject them. Less boilerplate, more coding.</p><p>Leave your thoughts below ‚Äî suggestions, questions, or even just enthusiasm! üöÄ </p>","contentLength":1089,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Tabiew 0.8.4 Released","url":"https://www.reddit.com/r/rust/comments/1ipp72r/tabiew_084_released/","date":1739578902,"author":"/u/shshemi","guid":631,"unread":true,"content":"<p>Tabiew is a lightweight TUI application that allows users to view and query tabular data files, such as CSV, Parquet, Arrow, Sqlite, and ...</p><ul><li>üìä Support for CSV, Parquet, JSON, JSONL, Arrow, FWF, and Sqlite</li><li>üóÇÔ∏è Multi-table functionality</li></ul><ul><li>UI is updated to be more modern and responsive</li><li>Horizontally scrollable tables</li><li>Visible data frame can be referenced with name \"_\"</li><li>Compatibility with older versions of glibc</li><li>Two new themes (Tokyo Night and Catppuccin)</li></ul>","contentLength":450,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Rust, C(23), or Zig for a Synthesizer?","url":"https://www.reddit.com/r/rust/comments/1ipja2x/rust_c23_or_zig_for_a_synthesizer/","date":1739562706,"author":"/u/mekaulu","guid":627,"unread":true,"content":"<p>I have been programming in C for 8+ years and I am sick of it, but it's really comfortable for me to use it. I have been considering using Rust or Zig(or Ada, but tried it for a few months then gave up) but I can't really decide.</p><p>I know Zig and used it for small experimental game engine but I am quite worried about it not being 1.0 yet( yes I know Bun is using Zig).</p><p>I read a lot about Rust but I have no experience of actually using it therefore learning it probably take a bit of time. Although from what I have read from the docs it seems fairly easy enough for me to understand it, I have no idea what's going on sometimes and that worries me a bit. How much compiler magic is behind Rust? Can I use custom allocators easily? Macros seems to be mandatory to use?</p><p>I generally code a lot of stuff from scratch in C, and I will probably do so in Rust or Zig as well. For example, I have been slowly building \"custom\" stdlib for my needs (like Zig stdlib, all allocations are explicit, it also has optional return types, multithreading, cross-platform graphics library etc.). Even with all that though, like I said, I am sick of it lol.</p><p>So what do you guys recommend?</p><p>Sometimes I just think, \"who cares, just use C and get stuff done\", though for some reason I can't follow through this advice. Idk why tho.</p>","contentLength":1304,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"the ref keyword","url":"https://www.reddit.com/r/rust/comments/1ipixny/the_ref_keyword/","date":1739561817,"author":"/u/Tickstart","guid":628,"unread":true,"content":"<p>I've made a quick mock situation which is analogous to my situation the other day:</p><pre><code>fn main() { let mut v: Option&lt;Vec&lt;usize&gt;&gt; = None; let mut h = 20; while h.ne(&amp;0) { if (h % 3).ge(&amp;1) { match v { Some(ref mut v) =&gt; (*v).push(h), None =&gt; v = Some(vec![h]) } } h -= 1 } println!(\"{v:?}\") } </code></pre><p>I was a bit confused on how it \"should\" be solved. My issue is the \"ref mut\". It made sense to me that I didn't want to consume the vector v, just add to it if it existed and I tried adding ref (then mut), which worked. When I goodled, it seemed ref was a legacy thing and not needed anymore. My question is, how is the idiomatic way to write this? Perhaps it's possible to do in a much simpler way and I just found a way to complicate it for no reason.</p><p>Also, don't worry I know this is a terrible pattern, it was mostly for tesing something.</p>","contentLength":828,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Macro-Less, Highly Integrated OpenAPI Document Generation in Rust with Ohkami","url":"https://medium.com/@kanarus786/macro-less-highly-integrated-openapi-document-generation-in-rust-with-ohkami-912de388adc1","date":1739557605,"author":"/u/kanarus","guid":626,"unread":true,"content":"<p>In Rust web dev, <a href=\"https://github.com/juhaku/utoipa\" rel=\"noopener ugc nofollow\" target=\"_blank\">utoipa</a> is the most popular crate for generating OpenAPI document from server code. While it‚Äôs a great tool, it can be frustrating due to excessive macro use.</p><p>A new web framework Ohkami offers a ,  way to generate OpenAPI document with its ‚Äúopenapi‚Äù feature.</p><p>Let‚Äôs take following code as an example. It‚Äôs the same sample from the ‚Äúopenapi‚Äù section of the README, but with openapi-related parts removed:</p><pre></pre><p>While this compiles and works as a pseudo user management server, activating ‚Äúopenapi‚Äù feature causes a compile error, telling that User and CreateUser don‚Äôt implement ohkami::openapi::Schema.</p><p>As indicated by this, Ohkami with ‚Äúopenapi‚Äù feature effectively handles type information and intelligently collects its endpoints‚Äô metadata. It allows code like:</p><pre></pre><p>to assemble metadata into an OpenAPI document and output it to a file .</p><p>Then, how we implement Schema? Actually we can easily impl Schema by hand, or just #[derive(Schema)] is available! In this case, derive is enough:</p><pre></pre><p>That‚Äôs it! Just adding these derives allows Ohkami::generate to output following file:</p><pre></pre><p>Additionally, it‚Äôs easy to define the User schema as a component instead of duplicating inline schemas. In derive, just add #[openapi(component)] helper attribute:</p><pre></pre><pre></pre><p>And  #[operation] attribute is available to set summary, description, and override operationId and each response‚Äôs description:</p><pre></pre><pre></pre><p>Let‚Äôs take a look at how this document generation works!</p><p>First, the #[derive(Schema)]s are expanded as following:</p><pre></pre><pre></pre><p>The DSL enables to easily impl manually.</p><p>Schema trait links the struct to an item of type called ‚ÄúSchemaRef‚Äù.</p><h2>2. openapi_* hooks of FromParam, FromRequest, IntoResponse</h2><p>FromParam, FromRequest and IntoResponse are Ohkami‚Äôs core traits appeared in the handler bound:</p><pre></pre><p>When ‚Äúopenapi‚Äù feature is activated, they additionally have following methods:</p><pre></pre><p>Ohkami leverages these methods in IntoHandler to generate consistent openapi::Operation, reflecting the actual handler signature like <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/fang/handler/into_handler.rs#L328-L335\" rel=\"noopener ugc nofollow\" target=\"_blank\">this</a>.</p><p>Moreover, Ohkami properly propagates schema information in common cases like <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/response/into_response.rs#L114-L128\" rel=\"noopener ugc nofollow\" target=\"_blank\">this</a>, allowing users to focus only on the types and schemas of their app.</p><h2>3. routes metadata of Router</h2><p>In Ohkami, what‚Äôs called router::base::Router <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/router/base.rs#L8-L18\" rel=\"noopener ugc nofollow\" target=\"_blank\">has ‚Äúroutes‚Äù property</a> that stores all the routes belonging to an Ohkami instance. This is returned alongside router::final::Router from ‚Äúfinalize‚Äù step, and is used to assemble metadata of all endpoints.</p><p>What Ohkami::generate itself does is just to serialize an item of type openapi::document::Document and write it to a file.</p><p>The openapi::document::Document item is created by<a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/ohkami/src/router/final.rs#L54-L59\" rel=\"noopener ugc nofollow\" target=\"_blank\"> ‚Äúgen_openapi_doc‚Äù of router::final::Router</a>, summarized as follows:</p><pre></pre><p>That‚Äôs how Ohkami generates OpenAPI document!</p><p>There is, however, a problem in , Cloudflare Workers: Ohkami is loaded to Miniflare or Cloudflare Workers as WASM, so it can only generate OpenAPI document andcannot write it to the user‚Äôs local file system.</p><p>To work around this, Ohkami provides a CLI tool <a href=\"https://github.com/ohkami-rs/ohkami/blob/6e243ac823e21f286aca2660f9d38f7bde381c5a/scripts/workers_openapi.js\" rel=\"noopener ugc nofollow\" target=\"_blank\">scripts/workers_openapi.js</a>. This is, for example, used in package.json of Cloudflare Workers + OpenAPI template:</p><pre></pre><p>generates OpenAPI document!</p>","contentLength":3119,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1iph9lk/macroless_highly_integrated_openapi_document/"}],"tags":["dev","reddit","rust"]}