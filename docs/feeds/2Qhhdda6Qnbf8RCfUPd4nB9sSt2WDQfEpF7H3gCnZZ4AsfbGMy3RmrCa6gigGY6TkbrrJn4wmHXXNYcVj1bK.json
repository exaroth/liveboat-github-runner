{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Resistance to Rust abstractions for DMA mapping [LWN.net]","url":"https://lwn.net/SubscriberLink/1006805/f75d238e25728afe/","date":1738552078,"author":"/u/OptimalFa","guid":330,"unread":true,"content":"<blockquote><table><tbody><tr><td><p>\nThe following subscription-only content has been made available to you \nby an LWN subscriber.  Thousands of subscribers depend on LWN for the \nbest news from the Linux and free software communities.  If you enjoy this \narticle, please consider <a href=\"https://lwn.net/subscribe/\">subscribing to LWN</a>.  Thank you\nfor visiting LWN.net!\n</p></td></tr></tbody></table></blockquote><div>\n           By January 30, 2025\n           </div>\nWhile the path toward the ability to write device drivers in Rust has been\nanything but smooth, steady progress has been made and that goal is close\nto being achieved — for some types of drivers at least.  Device drivers\nneed to be able to set up memory areas for direct memory access (DMA)\ntransfers, though; that means Rust drivers will need a set of\nabstractions to interface with the kernel's DMA-mapping subsystem.  Those\nabstractions have run into resistance that has the potential to block\nprogress on the Rust-for-Linux project as a whole.\n<p>\nDMA transfers move data directly between RAM and the device of interest,\nwithout involving the CPU.  It is difficult to get any sort of reasonable\nI/O performance without DMA, so almost all devices support it.  Making DMA\nwork, though, is not just a matter of handing a memory address to a\nperipheral device; there are many concerns that must be dealt with.  These\ninclude maintaining cache coherency, ensuring that pages are resident in\nRAM, handling device-specific addressing limitations, programming I/O\nmemory-management units, and more.  Plus, of course, every architecture\ndoes things differently.  The DMA-mapping layer exists to hide most of\nthese problems from device drivers behind an architecture-independent\ninterface.\n</p><p>\nDrivers written in Rust will need to do DMA, so they will need access to\nthe mapping layer.  There have been patches to provide some of that access\nin circulation for some time; Abdiel Janulgue posted <a href=\"https://lwn.net/ml/all/20250108122825.136021-1-abdiel.janulgue@gmail.com\">a version\nof this work</a> in early January.  This series adds a small Rust module\nwith sufficient support to set up coherent mappings (long-term mappings in\ncache-coherent memory) for drivers.  This work only covers part of the DMA\nAPI, but it is sufficient for simpler devices.  Upcoming drivers will\nrequire that these abstractions are in place.\n</p><p>\nBut Christoph Hellwig, who does a lot of work with the DMA-mapping layer,\n<a href=\"https://lwn.net/ml/all/20250108135951.GA18074@lst.de\">turned this submission\naway</a> with a message reading, in its entirety: \"<q>No rust code in\nkernel/dma, please</q>\" (despite the fact that the patch did not put any\ncode in that directory).  When pressed, he <a href=\"https://lwn.net/ml/all/20250108151858.GB24499@lst.de\">added</a> that developers\nshould keep these abstractions in their own code and <a href=\"https://lwn.net/ml/all/20250110083955.GA5395@lst.de\">said</a> that he had no\ninterest in maintaining multi-language code.  Rust developers should keep\ntheir wrapping code to themselves, he concluded.\n</p><p>\nDanilo Krummrich <a href=\"https://lwn.net/ml/all/Z4D5a5NYrAbNxUL6@pollux\">pointed out</a>\nthat the proposed abstractions were doing exactly that — keeping the Rust\ncode separate from the rest: \"<q>We wrote a single piece of Rust code that\nabstracts the C API for all Rust drivers, which we offer to maintain\nourselves</q>\".  The conversation then went quiet for several days, after\nwhich Krummrich <a href=\"https://lwn.net/ml/all/Z4kG5AcVeQKegLnb@pollux\">said</a>:\n\"<q>Since there hasn't been a reply so far, I assume that we're good with\nmaintaining the DMA Rust abstractions separately</q>\".\n</p><p>\nHellwig, though, <a href=\"https://lwn.net/ml/all/20250128092334.GA28548@lst.de\">made it\nclear</a> that he is not on board with that plan.  He does not want the\nRust code anywhere near the DMA layer, and that fact that somebody else\nwould be maintaining it does not change his view.  Adding another language\n(he was clear that he was talking about any language, not Rust in\nparticular) would, he said, make Linux as a whole \"\".  That has, for now, brought the conversation to a halt.\n</p><p>\nWithout DMA support, there can be no interesting drivers written in Rust.\nSo one option that the Rust-for-Linux developers have at this point is to\ngive up on the whole thing and find a less frustrating project to work on.\nAs appealing as this option might be, it still is probably not their\nfirst choice, though.\n</p><p>\nAn alternative would be to do what Hellwig is suggesting and put the\nabstractions into each driver that needs them.  That, however, is not a\npath toward a more maintainable kernel.  When the DMA API changes, as it\ninevitably will, numerous drivers will have to be fixed, one by one, rather\nthan fixing a single set of abstractions that are used by all.  So this,\ntoo, might not appear at the top of the list of options as seen by the\ndevelopers involved.\n</p><p>\nYet another approach might be to stash the DMA abstractions somewhere out\nof Hellwig's immediate sight — not in the  directory, in\nother words.  At that point it becomes just another user of the DMA API\nthat, in theory, is not subject to more scrutiny than any other driver.\nThe only problem with this idea is that Janulgue's patch already does that,\nand it was not sufficient.\n</p><p>\nSomeday, there will need to be a more decisive answer to this\nquestion.  Krummrich has tried to bring this about with <a href=\"https://lwn.net/ml/all/Z5qeoqRZKjiR1YAD@pollux\">a note</a> asking for Linus Torvalds\nor Greg Kroah-Hartman to make a decision regarding these abstractions.\nOther Rust developers have <a href=\"https://lwn.net/ml/all/293df3d54bad446e8fd527f204c6dc301354e340.camel@mailbox.org\">reiterated</a>\nthat they would take responsibility for the maintenance of this code, and\nthat it would not affect the DMA subsystem.  Jason Gunthorpe <a href=\"https://lwn.net/ml/all/20250130154646.GA2298732@nvidia.com\">questioned</a> that last\nclaim, noting that a 6.14 pull request was delayed due to a Rust build\nproblem, but Kroah-Hartman <a href=\"https://lwn.net/ml/all/2025013030-gummy-cosmic-7927@gregkh\">answered</a> that it was\n\"<q>a tooling issue that people missed due to the holidays</q>\" rather than\nan example of Rust code holding up development.  Neither he nor Torvalds\nhas made any decrees on whether the code in question will be merged, though.\n</p><p>\n\nBy allowing the entry of Rust, the kernel community has decided\n— on a provisional basis, at least — that it is indeed willing to maintain\na multi-language code base.  Perhaps, for now, the desire to banish Rust\ncode to the periphery of the kernel makes some sense, while Rust is still\nseen as an ongoing experiment.  If it is eventually decided that the Rust\nexperiment has failed, backing the existing Rust code out will be easier if\nit's confined to the edges.\n</p><p>\nBut it seems increasingly unlikely that the Rust experiment will be judged\nthat way.  Rust clearly can be used to write kernel code, and there would\nappear to be some significant advantages to doing that.  If the experiment\nhas indeed succeeded then, at some point, the language will need to be\ntreated as a first-class citizen within the kernel.  Over time, \"I don't\nwant to deal with more than one language\" will be an increasingly weak\nargument against a contribution written in Rust.\n</p><p>\nThat day may be a while in coming yet.  Already overworked kernel\nmaintainers will have to find time to learn Rust well enough to manage it\nwithin their subsystems.  Incoming Rust developers can shoulder some of\nthat burden, but they too will need time to acquire anywhere near the level of\nexperience that the current maintainers have — experience that the kernel\ncommunity depends on heavily.  A change of this magnitude to a body of code\nas large as the kernel was never going to be a quick or easy affair; it has\ngone as well as could have been expected so far, but there will be more,\nperhaps harder, obstacles to overcome in the future.</p>","contentLength":7052,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1igfeja/resistance_to_rust_abstractions_for_dma_mapping/"},{"title":"Simple wgpu (24.0.1) + winit (0.30.8) template","url":"https://www.reddit.com/r/rust/comments/1ig3ys7/simple_wgpu_2401_winit_0308_template/","date":1738521130,"author":"/u/Foxicution","guid":328,"unread":true,"content":"<div><p>Recently I decided to try out <a href=\"https://github.com/gfx-rs/wgpu\">wgpu</a> and ran into issues trying to get a basic triangle render working.</p><ol><li>The official examples were very hard to gasp for me, as they contained a lot of abstractions.</li><li>The standalone examples were a lot better, but they didn't contain instructions on how to compile for WebAssembly.</li><li>Other resources were usually outdated and didn't work for the current versions of wgpu and winit.</li></ol><p>Because of this I made myself a <a href=\"https://github.com/Foxicution/wgpu-template\">minimal working example</a> for the current version of winit and wgpu to use as a template for other projects and thought it might be useful to some other people.</p><p>Feedback is highly appreciated, and hope this can help people get into wgpu quicker.</p></div>   submitted by   <a href=\"https://www.reddit.com/user/Foxicution\"> /u/Foxicution </a>","contentLength":712,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"[Media] Flashing own code to e-link price tag only using a pico","url":"https://www.reddit.com/r/rust/comments/1ig37ah/media_flashing_own_code_to_elink_price_tag_only/","date":1738519252,"author":"/u/tracyspacygo","guid":332,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I got tired of tracking software versions manually... So I built \"Veno\"","url":"https://www.reddit.com/r/rust/comments/1ifxknr/i_got_tired_of_tracking_software_versions/","date":1738504109,"author":"/u/Marekzan","guid":331,"unread":true,"content":"<p>At work, I deal with multiple software artifacts—repositories, container images, Helm charts. Some of them are critical, and keeping them up to date is non-negotiable. But tracking them manually? That’s a nightmare.</p><p>At first, I tried the usual methods: setting up email notifications, following RSS feeds, even writing a few scripts to scrape version numbers. But each artifact lived in its own ecosystem—some on GitHub, others on DockerHub or ArtifactHub. Some had built-in notification systems, some didn’t. And worst of all, I had no .</p><p>I needed a way to track everything in one place. Not just track, but also get notified in the right way. Some updates needed an email. Others were better suited for a Slack message or a webhook trigger for automation, or all of them (just to be sure ;) ).</p><p>So I built —a simple tool that lets you define  (the things you care about) and attach  (the places you want updates to go). One configuration file, multiple sinks, and no more version-hunting.</p><p>Right now, Veno supports <strong>GitHub, DockerHub, and ArtifactHub</strong> as sources, with notifications via <strong>Email, Webhooks, Google Chat, and Slack</strong>. A CLI version is up and running, and a web service is in the works. Eventually, I want to add <strong>scheduled tracking (daemon mode)</strong> so it runs in the background.</p><p>If you're in the same boat—managing multiple software artifacts and tired of manually checking for updates—Veno might be useful for you. I’d love feedback, feature requests, and contributors! </p><p>Would this be useful for your workflow? Let me know what you'd like to see in a tool like this!</p><p>: I started learning Rust about 6 months ago, so I'd appreciate some feedback about idiomatic Rust and or other tips how to improve! The version checking logic is still kind of janky and the GitHub logic only supports semver currently.<p> I am going to improve upon the version logic in future releases!</p></p>","contentLength":1880,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"I thought TypeScript's type system was powerful. Until I tried Rust","url":"https://www.reddit.com/r/rust/comments/1ifurb2/i_thought_typescripts_type_system_was_powerful/","date":1738493365,"author":"/u/nikitarevenco","guid":333,"unread":true,"content":"<p>My first language was JavaScript. Then TypeScript. TypeScript caught many bugs which I've experienced with JS, such as spending 2 hours debugging because I accidentally wrote \"false\" instead of false. TypeScript caught these bugs. I was amazed by how \"powerful\" its type system is</p><p>Then I tried Rust. I've been programming in Rust for about 2 months now. </p><p>Rust's type system to TypeScript is like TypeScript's type system to JavaScript. I wouldn't have believed these worlds before Rust. Having a type system which actually co-exists with your code is really, really delightful.</p><p>When a value claims to have some type in TypeScript, you can't be sure that it actually is that type. Any of the 100s of function calls used to derive this value may have used an  assertion, and if this assertion is wrong then the type is invalid. If an invalid type is somewhere deep enough it can spread like the plague, but you won't know.</p><p>TypeScript's type inference compared to Rust's is weaker. This means there are often situations where you're forced to use an  assertion. And that's pretty bad, because now you've introduced an extra chance for incorrect types to be introduces and proliferate in your code</p><p>When people said \"haha using JavaScript on the backend\", I thought TypeScript is the solution. But if you want to be certain your program will work correctly you'll have to be extra careful when using TypeScript, values can claim to be some type while not actually being that type.</p><p>In some sense, using an  assertion is similar to using  in Rust. You're making a promise that your program upholds some invariants that the compiler can't infer itself. And the Rust community places a lot of importance on properly documenting why certain invariants are upheld for  blocks. But  are not treated nearly the same, they're often just used without a second thought. And that's a problem</p><p>Having a strong type system is one of the most important factors about a language, to me at least. Type systems allow you to express the purpose of your program in a way that your code never will.</p><p>I am super grateful to Rust and Haskell for opening my eyes on type systems. I'm also super grateful for all the work done on the TypeScript compiler. While it's far from perfect, I understand it's the way it is and has to be that way. There's not much TS can do since it compiles to the same old JavaScript. TypeScript it is an essential layer of protection on top of your JavaScript. </p><p>But I'm really looking forward to a future where we don't need to use TypeScript anymore, and Rust frameworks such as Dioxus can become popular like Next.js (I can dream...)</p>","contentLength":2623,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Python developer getting started with Rust","url":"https://www.reddit.com/r/rust/comments/1ift6e5/python_developer_getting_started_with_rust/","date":1738486340,"author":"/u/InfluenceFit478","guid":329,"unread":true,"content":"<p>I’m a Python developer (mostly backend and data related work, approx 12 years) and I’m seeing a big part of my toolchain transitioning to having a core built in Rust (polars, orjson, Pydantic, uv, ruff). All of these tools seem super exciting and I’m keen to contribute to some of them. However, I’d have to start from scratch learning Rust.</p><p>Any suggestions on where to start? </p>","contentLength":384,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","reddit","rust"]}