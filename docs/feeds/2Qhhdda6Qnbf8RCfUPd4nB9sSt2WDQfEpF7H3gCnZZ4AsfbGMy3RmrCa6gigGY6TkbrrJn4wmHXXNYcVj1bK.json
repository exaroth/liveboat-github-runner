{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"items":[{"title":"Rust WASM Plugins Example","url":"https://www.reddit.com/r/rust/comments/1hvaz5f/rust_wasm_plugins_example/","date":1736200284,"author":"/u/emblemparade","unread":true,"content":"<!-- SC_OFF --><div class=\"md\"><p><a href=\"https://github.com/tliron/rust-wasm-plugins-examples\">See the GitHub repository</a></p> <p>(Edit: it&#39;s &quot;Wasm&quot;, not &quot;Wasm&quot;, but unfortunately I can&#39;t fix the title)</p> <h1>A Great Fit</h1> <p>You&#39;ve probably heard that <a href=\"https://web.dev/explore/webassembly\">Wasm</a> (WebAssembly) can be a great way to support plugins in your application. Plugin authors can write them in any Wasm-compatible language and you&#39;re off to the races with your choice among various excellent and safe Wasm runtimes for Rust, including ones optimized for embedded environments (e.g. <a href=\"https://github.com/wasmi-labs/wasmi\">wasmi</a>).</p> <h1>Not So Easy</h1> <p>Unfortunately, you&#39;re going to find out (in early 2025) that examples of this often-mentioned use case are hard to come by, and that so much of the documentation is irrelevant, confusing, incomplete, or just out of date, as things have been moving quite quickly in the Wasm world.</p> <p>If you&#39;ve read Surma&#39;s <a href=\"https://surma.dev/things/rust-to-webassembly/\">Rust to WebAssembly the hard way</a> (highly recommended starting point!) then you might feel quite confident in your ability to build <code>.wasm</code> modules, load them into Rust, call functions in them, and expose functions to them. But the hard way becomes a dead end as you realize something quite critical: Wasm only supports the transfer of just primitive numeric types, namely integers and floats (and not even unsigned integers). This is an intentional and understandable design choice to keep Wasm lean and mean and agnostic to any specific implementation.</p> <p>But this means that if you want to transfer something as basic as a string or a vector then you&#39;ll have the delve deep into the the Wasm memory model. People have come up with various solutions for Rust, from piggy-backing on <a href=\"https://doc.rust-lang.org/std/ffi/struct.CString.html\">std::ffi::CString</a> to exposing custom malloc/free functions to the Wasm module. But not only are these solutions painful, they would obviously need to be ported to every language we want to support, each with its own string and array models. There was, and still is, a need for some kind of standard, built on top of Wasm, that would support higher-level constructs in a portable way.</p> <h1>The Temporary Solution</h1> <p>It took some time for the community to rally around one. For a while, a promising proposal was Wasm Interfaces (WAI). This was <a href=\"https://github.com/wasmerio/wai\">pioneered by Wasmer</a>, where the <a href=\"https://docs.wasmer.io/wai\">documentation</a> still points to it as &quot;the&quot; solution (early 2025). As usual in the Wasm world, even that documentation can only take you so far. None of it actually mentions hosting WAI in Rust! And it only shows importing interfaces, not exporting them, though I have managed to learn how to handle exports by delving into the WAI tooling source code. The idea behind WAI is that you describe your interface in a <a href=\"https://github.com/wasmerio/wai/blob/main/WAI.md\"><code>.wai</code> file</a> and use tooling (e.g. macros) to generate the boilerplate code for clients and hosts, a lot like how things work with RPC protocols (e.g. protobufs).</p> <p>WAI had not been widely adopted, however it does work and is also quite straightforward. We won&#39;t be using it in this example, but it&#39;s useful to be aware of its existence.</p> <h1>The Promising Solution</h1> <p>But the consensus now seems to be around the <a href=\"https://component-model.bytecodealliance.org/\">Wasm Component Model</a>, which expands on WAI with proper namespacing, resources, and richer custom data types. The Component Model is actually part of WASI, and indeed is being used to provide the WASI extensions. So, what&#39;s <a href=\"https://wasi.dev/\">WASI</a>? It&#39;s an initiative by the community to deliver a set of common APIs on top of Wasm for accessing streams, like files and stdout/stderr, network sockets, and eventually threads. I say &quot;eventually&quot; because WASI is still very much a work in progress. As of now (early 2025) we just got &quot;preview 2&quot; of it. Luckily, Rust can target &quot;wasip2&quot;, meaning that it can be used to create the latest and greatest Components. Though, note that wasip2 does produce larger minimal <code>.wasm</code> files than WAI due to the inclusion of the machinery for the Component Model.</p> <p>Like WAI, the Component Model relies on an interface definition file, <a href=\"https://github.com/WebAssembly/component-model/blob/main/design/mvp/WIT.md\"><code>.wit</code></a>. And <a href=\"https://wasmtime.dev/\">Wasmtime</a> has the tooling for it! Yay! So, are we finally off to the races with our plugin system?</p> <p>Not so fast. Again, finding examples and straightforward documentation is not easy. Wasmtime is a very comprehensive and performative implementation, but it&#39;s also designed by committee and has a lot of contributors. And due to the fast-moving nature of these things, what you find might not represent what is actually going on or what you should be using.</p> <h1>Finally We Get to the Point</h1> <p>All that to say, that&#39;s why I created this repository. It&#39;s intended to be a minimal and straightforward example of how to build plugins in Rust (as Components) and how to host them in your application using Wasmtime and its WIT tooling. Well, at least for early 2025... As of now it does not demonstrate the more advanced features of WIT, such as custom data types, but I might add those in the future.</p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/emblemparade\"> /u/emblemparade </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hvaz5f/rust_wasm_plugins_example/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hvaz5f/rust_wasm_plugins_example/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"rust-analyzer changelog #267","url":"https://www.reddit.com/r/rust/comments/1hv7jgs/rustanalyzer_changelog_267/","date":1736192002,"author":"/u/WellMakeItSomehow","unread":true,"content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/WellMakeItSomehow\"> /u/WellMakeItSomehow </a> <br/> <span><a href=\"https://rust-analyzer.github.io/thisweek/2025/01/06/changelog-267.html\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hv7jgs/rustanalyzer_changelog_267/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"&impl or &dyn","url":"https://www.reddit.com/r/rust/comments/1hv0n0w/impl_or_dyn/","date":1736174826,"author":"/u/Seriy0904","unread":true,"content":"<!-- SC_OFF --><div class=\"md\"><p>I am a newbie in rust. I&#39;ve been reading some stuff regarding traits, and I seem to be confused what is the difference between this: <code>rust fn print_area(shape: &amp;dyn Shape) { println!(&quot;Area: {}&quot;, shape.area()); } </code> And this : <code>rust fn print_area(shape: &amp;impl Shape) { println!(&quot;Area: {}&quot;, shape.area()); } </code></p> </div><!-- SC_ON --> &#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Seriy0904\"> /u/Seriy0904 </a> <br/> <span><a href=\"https://www.reddit.com/r/rust/comments/1hv0n0w/impl_or_dyn/\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1hv0n0w/impl_or_dyn/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Lisp interpreter in a browser with Rust + WASM","url":"https://www.reddit.com/r/rust/comments/1huyr7a/lisp_interpreter_in_a_browser_with_rust_wasm/","date":1736169412,"author":"/u/Independent-Golf-754","unread":true,"content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/Independent-Golf-754\"> /u/Independent-Golf-754 </a> <br/> <span><a href=\"https://vishpat.github.io/lisp-rs-wasm\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1huyr7a/lisp_interpreter_in_a_browser_with_rust_wasm/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"Proving that 1 + 1 = 10 in Rust","url":"https://www.reddit.com/r/rust/comments/1huvseo/proving_that_1_1_10_in_rust/","date":1736158091,"author":"/u/EightLines_03","unread":true,"content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/EightLines_03\"> /u/EightLines_03 </a> <br/> <span><a href=\"https://tavianator.com/2020/one_plus_one.html\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1huvseo/proving_that_1_1_10_in_rust/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""},{"title":"kira (game audio library) v0.10 - significant performance improvements, pause/resume mixer tracks, spatial audio overhaul","url":"https://www.reddit.com/r/rust/comments/1huolzs/kira_game_audio_library_v010_significant/","date":1736130905,"author":"/u/tesselode","unread":true,"content":"&#32; submitted by &#32; <a href=\"https://www.reddit.com/user/tesselode\"> /u/tesselode </a> <br/> <span><a href=\"https://github.com/tesselode/kira/releases/tag/v0.10.0\">[link]</a></span> &#32; <span><a href=\"https://www.reddit.com/r/rust/comments/1huolzs/kira_game_audio_library_v010_significant/\">[comments]</a></span>","flags":null,"enclosureUrl":"","enclosureMime":""}]}