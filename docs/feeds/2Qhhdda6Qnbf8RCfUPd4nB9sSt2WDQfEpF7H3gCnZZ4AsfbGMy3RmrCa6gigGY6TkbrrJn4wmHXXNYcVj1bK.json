{"id":"2Qhhdda6Qnbf8RCfUPd4nB9sSt2WDQfEpF7H3gCnZZ4AsfbGMy3RmrCa6gigGY6TkbrrJn4wmHXXNYcVj1bK","title":"top scoring links : rust","displayTitle":"Reddit - Rust","url":"https://www.reddit.com/r/rust/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/rust/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"beekeeper: an ergonomic workerpool crate","url":"https://www.reddit.com/r/rust/comments/1i9bkjc/beekeeper_an_ergonomic_workerpool_crate/","date":1737767980,"author":"/u/jdidion","guid":588,"unread":true,"content":"<p>Hi <a href=\"https://www.reddit.com/r/rust\">r/rust</a>! I've just published <a href=\"https://docs.rs/beekeeper/latest/beekeeper/\">beekeeper</a>, a workerpool library written in Rust.</p><p>This crate started as a fork of <a href=\"https://github.com/lorepozo/workerpool\">workerpool</a>, but at this point it's pretty much a re-write and has lots of additional features, including: * A  trait that is not required to extend  * The ability to write workers with mutable state * Support for custom worker factories * Stock worker implementations, including support for parallelizing callables (functions or closures) * Methods for submitting batches of tasks * The ability to retrieve results as either ordered or unordered iterators, send them to a channel (with support for several alternative channel crates), or store them in the workerpool data structure (called a ) for later retrieval * The ability to pause and resume processing * (optional) support for automatically retrying failures * (optional) support for pinning worker threads to CPU cores</p><p>I'd love for you to try it out and give feedback about what could be improved.</p>","contentLength":965,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Iroh: p2p chat, in rust, from scratch","url":"https://youtu.be/ogN_mBkWu7o","date":1737749386,"author":"/u/diogocsvalerio","guid":592,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1i94oxv/iroh_p2p_chat_in_rust_from_scratch/"},{"title":"What technology was used to create the core of rust?","url":"https://www.reddit.com/r/rust/comments/1i93tma/what_technology_was_used_to_create_the_core_of/","date":1737747155,"author":"/u/BeastBoyMike","guid":587,"unread":true,"content":"<p>Like what language did they write the rust compiler in..? It's core libraries, are they adopted from c/c++?</p>","contentLength":107,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Build It Yourself","url":"https://lucumr.pocoo.org/2025/1/24/build-it-yourself/","date":1737729756,"author":"/u/burntsushi","guid":591,"unread":true,"content":"<p>written on Friday, January 24, 2025</p><p>Another day, another <a href=\"https://lucumr.pocoo.org/2016/3/24/open-source-trust-scaling/\">rant</a><a href=\"https://lucumr.pocoo.org/2022/1/10/dependency-risk-and-funding/\">about</a><a href=\"https://lucumr.pocoo.org/2024/3/26/rust-cdo/\">dependencies</a>. from me.  This time I will ask you that we\nstart and support a vibe shift when it comes to dependencies.</p><p>You're probably familiar with the concept of “dependency churn.”  It's that\nnever-ending treadmill of updates, patches, audits, and transitive\ndependencies that we as developers love to casually install in the name of\nproductivity.  Who doesn't enjoy waiting for yet another \njust so you can get that fix for a bug you don't even have?</p><p>It's a plague in most ecosystems with good packaging solutions.\nJavaScript and Rust are particularly badly affected by that.  A brand new\nTokio project drags in 28 crates, a new Rocket project balloons that to\n172, and a little template engine like MiniJinja can exist with just a\nsingle dependency — while its CLI variant slurps up 142.</p><p>If that doesn't sound like a big deal, let's consider <a href=\"https://crates.io/crates/terminal_size\">terminal_size</a>.  It is a crate that does\nexactly what its name suggests: it figures out your terminal dimensions.\nThe underlying APIs it uses have effectively been stable since the earliest days of computing\nterminals—what, 50 years or so? And yet, for one function, terminal-size\nmanages to introduce three or four additional crates, depending on your\noperating system.  That triggers a whole chain reaction, so you end up\ncompiling thousands of other functions just to figure out if your terminal\nis 80x25 or 120x40.  That crate had 26 releases.  My own version of that\nthat I have stuck away in a project from 10 years ago still works without\na single update.  Because shocker: nothing about figuring out terminal\nsizes has changed.  </p><p>So why does  have so many updates if it's so stable?\nBecause it's build on top of platform abstraction libraries that\nconstantly churn, so it needs to update to avoid code duplication and\nblowing up compile times even more.</p><p>But “big supply chain” will tell you that you must do it this way.  Don't\nyou dare to copy paste that function into your library.  Or don't you date\nto use “unsafe” yourself.  You're not qualified enough to write unsafe\ncode, let the platform abstraction architects do that.  Otherwise someone\n<a href=\"https://github.com/geiger-rs/cargo-geiger\">will slap you</a>.  There are\nentire companies who are making a living of supplying you with the tools\nneeded to deal with your dependency mess.  In the name of security, we're\npushed to having dependencies and keeping them up to date, despite most of\nthose dependencies being the primary source of security problems.</p><p>The goal of code in many ways should be to be written in a way that it\ndoes not need updates.  It should eventually achieve some level of\nstability.  In the Rust ecosystem stable code is punished.  If you have a\nperfectly working dependency but you have a somewhat inactive bug tracker,\nRUSTSEC will come by and <a href=\"https://lucumr.pocoo.org/2024/3/26/rust-cdo/\">give you a chunk rating</a>.</p><p>But there  a simpler path.  You write code yourself.  Sure, it's more\nwork up front, but once it's written, it's done. No new crates, no waiting\nfor upsteam authors to fix that edge case.  If it's broken for you, you\nfix it yourself.  Code that works doesn't necessarily need the\nmaintenance treadmill.  Your code has a corner case?  Who cares.  This is\nthat vibe shift we need in the Rust world: celebrating fewer dependencies\nrather than more.</p><p>We're at a point in the most ecosystems where pulling in libraries is not\njust the default action, it's seen positively: “Look how modular and\ncomposable my code is!”  Actually, it might just be a symptom of never\nwanting to type out more than a few lines.</p><p>Now one will make the argument that it takes so much time to write all of\nthis.  It's 2025 and it's faster for me to have ChatGPT or Cursor whip up\na dependency free implementation of these common functions, than it is for\nme to start figuring out a dependency.  And it makes sense as for many\nsuch small functions the maintenance overhead is tiny and much lower than\nactually dealing with constant upgrading of dependencies.  The code is just\na few lines and you also get the benefit of no longer need to compile\nthousands of lines of other people's code for a single function.</p><p>But let's face it: corporate code review culture has also has infected\nOpen Source software.  Companies are more likely to reward engineers than\nscold them for pulling in that new “shiny library” that solves the problem\nthey never actually had.  That creates problems, so dependabot and friends\nwere born.  Today I just dread getting dependabot pull requests but on\nprojects but I have to accept it.  I'm part of an ecosystem with my stuff\nand that ecosystem is all about churn, churn, churn.  In companies you can\nalso keep entire internal engineering teams busy with vendoring\ndependencies, internal audits and upgrading things throughout the company.</p><p>Fighting this fight is incredibly hard!  Every new hire has been trained\non the idea that dependencies are great, that code reuse is great.  That\nhaving old code sitting around is a sign of bad engineering culture.</p><p>It's also hard to fight this in Open Source.  Years ago I wrote <a href=\"https://crates.io/crates/sha1_smol\">sha1-smol</a> which originally was just called\n.  It became the standard crate to calculate SHA1 hashes.\nEventually I was pressured to donate that package name to rust-crypto and\nto depend on the rest of the crypto ecosystem as it was so established.\nIf you want to use the new sha1 crate, you get to enjoy 10 dependencies.\nBut there was just no way around it, because that name in the registry is\nprecious and people also wanted to have trait compatibility.  It feels\ntiring to be the only person in a conversation pushing to keep the churn\ndown and dependencies low.</p><p>It's time to have a new perspective: we should give kudos to engineers who\nwrite a small function themselves instead of hooking in a transitive web\nof crates.  We should be suspicious of big crate graphs.  Celebrated are\nthe minimal dependencies, the humble function that just quietly does the\njob, the code that doesn't need to be touched for years because it was\ndone right once.</p><p>And sure, it's not black and white.  There are the important libraries\nthat solve hard problems.  Graphics libraries that abstract over complex\ndrivers, implementations of protocols like HTTP and QUIC.  I won't be able\nto get rid of tokio and I have no desire to.  But when you end up using\none function, but you compile hundreds, some alarm bell should go off.</p><p>We need that vibe shift.  To celebrate building it yourself when it's\nappropriate to do so.  To give credit to library authors who build low to\nno-dependency Open Source libraries.</p><p>For instance minijinja celebrates it in the readme:</p><pre>$ cargo tree\nminimal v0.1.0 (examples/minimal)\n└── minijinja v2.6.0 (minijinja)\n    └── serde v1.0.144\n</pre><p>And it has a PR to eventually <a href=\"https://github.com/mitsuhiko/minijinja/pull/539\">get rid of the last dependency</a>.  And sometime this\nyear I will make it my goal to go ahead proudly and trim down all that fat\nin my projects.</p>","contentLength":6868,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1i8wwy0/build_it_yourself/"},{"title":"Transforms: Reference frames tracking through time, is now no_std!","url":"https://www.reddit.com/r/rust/comments/1i8uxuy/transforms_reference_frames_tracking_through_time/","date":1737723967,"author":"/u/Strange-Guidance7654","guid":590,"unread":true,"content":"<p>I made a post a few months ago with the initial release and I am happy to see some usage on my work. I have continued developing the library.</p><p>: The Transforms crate aims to solve the isue in robotics where every sensor and limb in a robot has its own point of reference. Transforms provides a tracking system that links all these reference frames together and tracks them through time, such that their relative positions can always be queried.</p><p>This crate is heavily inspired by ROS2 / TF2, but is its own implementation and built fully from the ground up.</p><p>: In an attempt to increase the conciseness and minimalism in the crate, I removed any nested async implementations and made the crate no_std compatible.</p><p>Thank you very much for your time reading this and I welcome any constructive criticism.</p>","contentLength":794,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Windows Kernel Programming with Rust - Matthias Heiden | EuroRust 2024","url":"https://www.youtube.com/watch?v=NfBXDEgm6VY","date":1737702609,"author":"/u/small_kimono","guid":589,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/rust/comments/1i8pumg/windows_kernel_programming_with_rust_matthias/"}]}