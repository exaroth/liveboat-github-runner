{"id":"MvwLKznkcWQJt9LV3qspiNNstpReRGojdXM3bsYDh","title":"Kubernetes Blog","displayTitle":"Dev - Kubernetes Blog","url":"https://kubernetes.io/feed.xml","feedLink":"https://kubernetes.io/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":3,"items":[{"title":"Tuning Linux Swap for Kubernetes: A Deep Dive","url":"https://kubernetes.io/blog/2025/08/19/tuning-linux-swap-for-kubernetes-a-deep-dive/","date":1755628200,"author":"","guid":716,"unread":true,"content":"<p>The Kubernetes <a href=\"https://kubernetes.io/docs/concepts/cluster-administration/swap-memory-management/\">NodeSwap feature</a>, likely to graduate to  in the upcoming Kubernetes v1.34 release,\nallows swap usage:\na significant shift from the conventional practice of disabling swap for performance predictability.\nThis article focuses exclusively on tuning swap on Linux nodes, where this feature is available. By allowing Linux nodes to use secondary storage for additional virtual memory when physical RAM is exhausted, node swap support aims to improve resource utilization and reduce out-of-memory (OOM) kills.</p><p>However, enabling swap is not a \"turn-key\" solution. The performance and stability of your nodes under memory pressure are critically dependent on a set of Linux kernel parameters. Misconfiguration can lead to performance degradation and interfere with Kubelet's eviction logic.</p><p>In this blogpost, I'll dive into critical Linux kernel parameters that govern swap behavior. I will explore how these parameters influence Kubernetes workload performance, swap utilization, and crucial eviction mechanisms.\nI will present various test results showcasing the impact of different configurations, and share my findings on achieving optimal settings for stable and high-performing Kubernetes clusters.</p><h2>Introduction to Linux swap</h2><p>At a high level, the Linux kernel manages memory through pages, typically 4KiB in size. When physical memory becomes constrained, the kernel's page replacement algorithm decides which pages to move to swap space. While the exact logic is a sophisticated optimization, this decision-making process is influenced by certain key factors:</p><ol><li>Page access patterns (how recently pages are accessed)</li><li>Page dirtyness (whether pages have been modified)</li><li>Memory pressure (how urgently the system needs free memory)</li></ol><h3>Anonymous vs File-backed memory</h3><p>It is important to understand that not all memory pages are the same. The kernel distinguishes between anonymous and file-backed memory.</p><p>: This is memory that is not backed by a specific file on the disk, such as a program's heap and stack. From the application's perspective this is private memory, and when the kernel needs to reclaim these pages, it must write them to a dedicated swap device.</p><p>: This memory is backed by a file on a filesystem. This includes a program's executable code, shared libraries, and filesystem caches. When the kernel needs to reclaim these pages, it can simply discard them if they have not been modified (\"clean\"). If a page has been modified (\"dirty\"), the kernel must first write the changes back to the file before it can be discarded.</p><p>While a system without swap can still reclaim clean file-backed pages memory under pressure by dropping them, it has no way to offload anonymous memory. Enabling swap provides this capability, allowing the kernel to move less-frequently accessed memory pages to disk to conserve memory to avoid system OOM kills.</p><h3>Key kernel parameters for swap tuning</h3><p>To effectively tune swap behavior, Linux provides several kernel parameters that can be managed via .</p><ul><li>: This is the most well-known parameter. It is a value from 0 to 200 (100 in older kernels) that controls the kernel's preference for swapping anonymous memory pages versus reclaiming file-backed memory pages (page cache).\n<ul><li>: The kernel will be aggressive in swapping out less-used anonymous memory to make room for file-cache.</li><li>: The kernel will strongly prefer dropping file cache pages over swapping anonymous memory.</li></ul></li><li>: This parameter tells the kernel to keep a minimum amount of memory free as a buffer. When the amount of free memory drops below the this safety buffer, the kernel starts more aggressively reclaiming pages (swapping, and eventually handling OOM kills).\n<ul><li> It acts as a safety lever to ensure the kernel has enough memory for critical allocation requests that cannot be deferred.</li><li>: Setting a higher  effectively raises the floor for for free memory, causing the kernel to initiate swap earlier under memory pressure.</li></ul></li><li><code>vm.watermark_scale_factor</code>: This setting controls the gap between different watermarks: ,  and , which are calculated based on .\n<ul><li>:\n<ul><li>: When free memory is below this mark, the  kernel process wakes up to reclaim pages in the background. This is when a swapping cycle begins.</li><li>: When free memory hits this minimum level, then aggressive page reclamation will block process allocation. Failing to reclaim pages will cause OOM kills.</li><li>: Memory reclamation stops once the free memory reaches this level.</li></ul></li><li>: A higher  careates a larger buffer between the  and  watermarks. This gives  more time to reclaim memory gradually before the system hits a critical state.</li></ul></li></ul><p>In a typical server workload, you might have a long-running process with some memory that becomes 'cold'. A higher  value can free up RAM by swapping out the cold memory, for other active processes that can benefit from keeping their file-cache.</p><p>Tuning the  and  parameters to move the swapping window early will give more room for  to offload memory to disk and prevent OOM kills during sudden memory spikes.</p><p>To understand the real-impact of these parameters, I designed a series of stress tests.</p><ul><li>: GKE on Google Cloud</li><li>: 1.33.2</li><li>:  (8GiB RAM, 50GB swap on a  disk, without encryption), Ubuntu 22.04</li><li>: A custom Go application designed to allocate memory at a configurable rate, generate file-cache pressure, and simulate different memory access patterns (random vs sequential).</li><li>: A sidecar container capturing system metrics every second.</li><li>: Critical system components (kubelet, container runtime, sshd) were prevented from swapping by setting  in their respective cgroups.</li></ul><p>I ran a stress-test pod on nodes with different swappiness settings (0, 60, and 90) and varied the  and  parameters to observe the outcomes under heavy memory allocation and I/O pressure.</p><h4>Visualizing swap in action</h4><p>The graph below, from a 100MBps stress test, shows swap in action. As free memory (in the \"Memory Usage\" plot) decreases, swap usage () and swap-out activity () increase. Critically, as the system relies more on swap, the I/O activity and corresponding wait time ( in the \"CPU Usage\" plot) also rises, indicating CPU stress.</p><p>My initial tests with default kernel parameters (, , <code>watermark_scale_factor=10</code>) quickly led to OOM kills and even unexpected node restarts under high memory pressure. With selecting appropriate kernel parameters a good balance in node stability and performance can be achieved.</p><p>The swappiness parameter directly influences the kernel's choice between reclaiming anonymous memory (swapping) and dropping page cache. To observe this, I ran a test where one pod generated and held file-cache pressure, followed by a second pod allocating anonymous memory at 100MB/s, to observe the kernel preference on reclaim:</p><p>My findings reveal a clear trade-off:</p><ul><li>: The kernel proactively swapped out the inactive anonymous memory to keep the file cache. This resulted in high and sustained swap usage and significant I/O activity (\"Blocks Out\"), which in turn caused spikes in I/O wait on the CPU.</li><li>: The kernel favored dropping file-cache pages delaying swap consumption. However, it's critical to understand that this <strong>does not disable swapping</strong>. When memory pressure was high, the kernel still swapped anonymous memory to disk.</li></ul><p>The choice is workload-dependent. For workloads sensitive to I/O latency, a lower swappiness is preferable. For workloads that rely on a large and frequently accessed file cache, a higher swappiness may be beneficial, provided the underlying disk is fast enough to handle the load.</p><h4>Tuning watermarks to prevent eviction and OOM kills</h4><p>The most critical challenge I encountered was the interaction between rapid memory allocation and Kubelet's eviction mechanism. When my test pod, which was deliberately configured to overcommit memory, allocated it at a high rate (e.g., 300-500 MBps), the system quickly ran out of free memory.</p><p>With default watermarks, the buffer for reclamation was too small. Before  could free up enough memory by swapping, the node would hit a critical state, leading to two potential outcomes:</p><ol><li> If kubelet's eviction manager detected  was below its threshold, it would evict the pod.</li><li> In some high-rate scenarios, the OOM Killer would activate before eviction could complete, sometimes killing higher priority pods that were not the source of the pressure.</li></ol><p>To mitigate this I tuned the watermarks:</p><ol><li>Increased  to 512MiB: This forces the kernel to start reclaiming memory much earlier, providing a larger safety buffer.</li><li>Increased  to 2000: This widened the gap between the  and  watermarks (from ≈337MB to ≈591MB in my test node's ), effectively increasing the swapping window.</li></ol><p>This combination gave  a larger operational zone and more time to swap pages to disk during memory spikes, successfully preventing both premature evictions and OOM kills in my test runs.</p><p>Table compares watermark levels from  (Non-NUMA node):</p><table><thead><tr><th> and <code>watermark_scale_factor=10</code></th><th><code>min_free_kbytes=524288KiB</code> and <code>watermark_scale_factor=2000</code></th></tr></thead><tbody><tr><td>Node 0, zone Normal  &nbsp; pages free 583273  &nbsp; min 10504  &nbsp; high 15756  &nbsp; present 1310720 </td><td>Node 0, zone Normal  &nbsp; pages free 470539  &nbsp; low 337017  &nbsp; spanned 1310720 &nbsp; managed 1274542</td></tr></tbody></table><p>The graph below reveals that the kernel buffer size and scaling factor play a crucial role in determining how the system responds to memory load. With the right combination of these parameters, the system can effectively use swap space to avoid eviction and maintain stability.</p><p>Enabling swap in Kubernetes is a powerful tool, but it comes with risks that must be managed through careful tuning.</p><ul><li><p><strong>Risk of performance degradation</strong> Swapping is orders of magnitude slower than accessing RAM. If an application's active working set is swapped out, its performance will suffer dramatically due to high I/O wait times (thrashing). Swap could preferably be provisioned with a SSD backed storage to improve performance.</p></li><li><p><strong>Risk of masking memory leaks</strong> Swap can hide memory leaks in applications, which might otherwise lead to a quick OOM kill. With swap, a leaky application might slowly degrade node performance over time, making the root cause harder to diagnose.</p></li><li><p><strong>Risk of disabling evictions</strong> Kubelet proactively monitors the node for memory-pressure and terminates pods to reclaim the resources. Improper tuning can lead to OOM kills before kubelet has a chance to evict pods gracefully. A properly configured  is essential to ensure kubelet's eviction mechanism remains effective.</p></li></ul><p>Together, the kernel watermarks and kubelet eviction threshold create a series of memory pressure zones on a node. The eviction-threshold parameters need to be adjusted to configure Kubernetes managed evictions occur before the OOM kills.</p><p>As the diagram shows, an ideal configuration will be to create a large enough 'swapping zone' (between  and  watermarks) so that the kernel can handle memory pressure by swapping before available memory drops into the Eviction/Direct Reclaim zone.</p><p>Based on these findings, I recommend the following as a starting point for Linux nodes with swap enabled. You should benchmark this with your own workloads.</p><ul><li>: Linux default is a good starting point for general-purpose workloads. However, the ideal value is workload-dependent, and swap-sensitive applications may need more careful tuning.</li><li><code>vm.min_free_kbytes=500000</code> (500MB): Set this to a reasonably high value (e.g., 2-3% of total node memory) to give the node a reasonable safety buffer.</li><li><code>vm.watermark_scale_factor=2000</code>: Create a larger window for  to work with, preventing OOM kills during sudden memory allocation spikes.</li></ul><p>I encourage running benchmark tests with your own workloads in test-environments, when setting up swap for the first time in your Kubernetes cluster. Swap performance can be sensitive to different environment differences such as CPU load, disk type (SSD vs HDD) and I/O patterns.</p>","contentLength":11722,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Introducing Headlamp AI Assistant","url":"https://kubernetes.io/blog/2025/08/07/introducing-headlamp-ai-assistant/","date":1754593200,"author":"","guid":715,"unread":true,"content":"<p><em>This announcement originally <a href=\"https://headlamp.dev/blog/2025/08/07/introducing-the-headlamp-ai-assistant\">appeared</a> on the Headlamp blog.</em></p><p>To simplify Kubernetes management and troubleshooting, we're thrilled to\nintroduce <a href=\"https://github.com/headlamp-k8s/plugins/tree/main/ai-assistant#readme\">Headlamp AI Assistant</a>: a powerful new plugin for Headlamp that helps\nyou understand and operate your Kubernetes clusters and applications with\ngreater clarity and ease.</p><p>Whether you're a seasoned engineer or just getting started, the AI Assistant offers:</p><ul><li> Ask questions like <em>\"Is my application healthy?\"</em> or\n without needing deep Kubernetes knowledge.</li><li> Start with high-level queries and dig deeper with prompts\nlike <em>\"List all the problematic pods\"</em> or <em>\"How can I fix this pod?\"</em></li><li> Ask questions in the context of what you're viewing\nin the UI, such as </li><li> Let the AI take action for you, like <em>\"Restart that\ndeployment\"</em>, with your permission.</li></ul><p>Here is a demo of the AI Assistant in action as it helps troubleshoot an\napplication running with issues in a Kubernetes cluster:</p><p>Large Language Models (LLMs) have transformed not just how we access data but\nalso how we interact with it. The rise of tools like ChatGPT opened a world of\npossibilities, inspiring a wave of new applications. Asking questions or giving\ncommands in natural language is intuitive, especially for users who aren't deeply\ntechnical. Now everyone can quickly ask how to do X or Y, without feeling awkward\nor having to traverse pages and pages of documentation like before.</p><p>Therefore, Headlamp AI Assistant brings a conversational UI to <a href=\"https://headlamp.dev\">Headlamp</a>,\npowered by LLMs that Headlamp users can configure with their own API keys.\nIt is available as a Headlamp plugin, making it easy to integrate into your\nexisting setup. Users can enable it by installing the plugin and configuring\nit with their own LLM API keys, giving them control over which model powers\nthe assistant. Once enabled, the assistant becomes part of the Headlamp UI,\nready to respond to contextual queries and perform actions directly from the\ninterface.</p><p>As expected, the AI Assistant is focused on helping users with Kubernetes\nconcepts. Yet, while there is a lot of value in responding to Kubernetes\nrelated questions from Headlamp's UI, we believe that the great benefit of such\nan integration is when it can use the context of what the user is experiencing\nin an application. So, the Headlamp AI Assistant knows what you're currently\nviewing in Headlamp, and this makes the interaction feel more like working\nwith a human assistant.</p><p>For example, if a pod is failing, users can simply ask \nand the AI Assistant will respond with the root cause, like a missing\nenvironment variable or a typo in the image name. Follow-up prompts like\n allow the AI Assistant to suggest a fix, streamlining\nwhat used to take multiple steps into a quick, conversational flow.</p><p>Sharing the context from Headlamp is not a trivial task though, so it's\nsomething we will keep working on perfecting.</p><p>Context from the UI is helpful, but sometimes additional capabilities are\nneeded. If the user is viewing the pod list and wants to identify problematic\ndeployments, switching views should not be necessary. To address this, the AI\nAssistant includes support for a Kubernetes tool. This allows asking questions\nlike \"Get me all deployments with problems\" prompting the assistant to fetch\nand display relevant data from the current cluster. Likewise, if the user\nrequests an action like \"Restart that deployment\" after the AI points out what\ndeployment needs restarting, it can also do that. In case of \"write\"\noperations, the AI Assistant does check with the user for permission to run them.</p><p>Although the initial version of the AI Assistant is already useful for\nKubernetes users, future iterations will expand its capabilities. Currently,\nthe assistant supports only the Kubernetes tool, but further integration with\nHeadlamp plugins is underway. Similarly, we could get richer insights for\nGitOps via the Flux plugin, monitoring through Prometheus, package management\nwith Helm, and more.</p><p>And of course, as the popularity of MCP grows, we are looking into how to\nintegrate it as well, for a more plug-and-play fashion.</p><p>We hope this first version of the AI Assistant helps users manage Kubernetes\nclusters more effectively and assist newcomers in navigating the learning\ncurve. We invite you to try out this early version and give us your feedback.\nThe AI Assistant plugin can be installed from Headlamp's Plugin Catalog in the\ndesktop version, or by using the container image when deploying Headlamp.\nStay tuned for the future versions of the Headlamp AI Assistant!</p>","contentLength":4489,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Kubernetes v1.34 Sneak Peek","url":"https://kubernetes.io/blog/2025/07/28/kubernetes-v1-34-sneak-peek/","date":1753660800,"author":"","guid":714,"unread":true,"content":"<p>Kubernetes v1.34 is coming at the end of August 2025.\nThis release will not include any removal or deprecation, but it is packed with an impressive number of enhancements.\nHere are some of the features we are most excited about in this cycle!</p><p>Please note that this information reflects the current state of v1.34 development and may change before release.</p><h2>Featured enhancements of Kubernetes v1.34</h2><p>The following list highlights some of the notable enhancements likely to be included in the v1.34 release,\nbut is not an exhaustive list of all planned changes.\nThis is not a commitment and the release content is subject to change.</p><h3>The core of DRA targets stable</h3><p><a href=\"https://kubernetes.io/docs/concepts/scheduling-eviction/dynamic-resource-allocation/\">Dynamic Resource Allocation</a> (DRA) provides a flexible way to categorize,\nrequest, and use devices like GPUs or custom hardware in your Kubernetes cluster.</p><p>Since the v1.30 release, DRA has been based around claiming devices using  that are opaque to the core of Kubernetes.\nThe relevant enhancement proposal, <a href=\"https://kep.k8s.io/4381\">KEP-4381</a>, took inspiration from dynamic provisioning for storage volumes.\nDRA with structured parameters relies on a set of supporting API kinds: ResourceClaim, DeviceClass, ResourceClaimTemplate,\nand ResourceSlice API types under , while extending the  for Pods with a new  field.\nThe core of DRA is targeting graduation to stable in Kubernetes v1.34.</p><p>With DRA, device drivers and cluster admins define device classes that are available for use.\nWorkloads can claim devices from a device class within device requests.\nKubernetes allocates matching devices to specific claims and places the corresponding Pods on nodes that can access the allocated devices.\nThis framework provides flexible device filtering using CEL, centralized device categorization, and simplified Pod requests, among other benefits.</p><p>Once this feature has graduated, the  APIs will be available by default.</p><h3>ServiceAccount tokens for image pull authentication</h3><p>The <a href=\"https://kubernetes.io/docs/concepts/security/service-accounts/\">ServiceAccount</a> token integration for  credential providers is likely to reach beta and be enabled by default in Kubernetes v1.34.\nThis allows the  to use these tokens when pulling container images from registries that require authentication.</p><p>That support already exists as alpha, and is tracked as part of <a href=\"https://kep.k8s.io/4412\">KEP-4412</a>.</p><p>The existing alpha integration allows the  to use short-lived, automatically rotated ServiceAccount tokens (that follow OIDC-compliant semantics) to authenticate to a container image registry.\nEach token is scoped to one associated Pod; the overall mechanism replaces the need for long-lived image pull Secrets.</p><p>Adopting this new approach reduces security risks, supports workload-level identity, and helps cut operational overhead.\nIt brings image pull authentication closer to modern, identity-aware good practice.</p><h3>Pod replacement policy for Deployments</h3><p>After a change to a <a href=\"https://kubernetes.io/docs/concepts/workloads/controllers/deployment/\">Deployment</a>, terminating pods may stay up for a considerable amount of time and may consume additional resources.\nAs part of <a href=\"https://kep.k8s.io/3973\">KEP-3973</a>, the <code>.spec.podReplacementPolicy</code> field will be introduced (as alpha) for Deployments.</p><p>If your cluster has the feature enabled, you'll be able to select one of two policies:</p><dl><dd>Creates new pods as soon as old ones start terminating, resulting in faster rollouts at the cost of potentially higher resource consumption.</dd><dd>Waits until old pods fully terminate before creating new ones, resulting in slower rollouts but ensuring controlled resource consumption.</dd></dl><p>This feature makes Deployment behavior more predictable by letting you choose when new pods should be created during updates or scaling.\nIt's beneficial when working in clusters with tight resource constraints or with workloads with long termination periods.</p><p>It's expected to be available as an alpha feature and can be enabled using the <code>DeploymentPodReplacementPolicy</code> and <code>DeploymentReplicaSetTerminatingReplicas</code> feature gates in the API server and kube-controller-manager.</p><h3>Production-ready tracing for  and API Server</h3><p>To address the longstanding challenge of debugging node-level issues by correlating disconnected logs,\n<a href=\"https://kep.k8s.io/2831\">KEP-2831</a> provides deep, contextual insights into the .</p><p>This feature instruments critical  operations, particularly its gRPC calls to the Container Runtime Interface (CRI), using the vendor-agnostic OpenTelemetry standard.\nIt allows operators to visualize the entire lifecycle of events (for example: a Pod startup) to pinpoint sources of latency and errors.\nIts most powerful aspect is the propagation of trace context; the  passes a trace ID with its requests to the container runtime, enabling runtimes to link their own spans.</p><p>This effort is complemented by a parallel enhancement, <a href=\"https://kep.k8s.io/647\">KEP-647</a>, which brings the same tracing capabilities to the Kubernetes API server.\nTogether, these enhancements provide a more unified, end-to-end view of events, simplifying the process of pinpointing latency and errors from the control plane down to the node.\nThese features have matured through the official Kubernetes release process.\n<a href=\"https://kep.k8s.io/2831\">KEP-2831</a> was introduced as an alpha feature in v1.25, while <a href=\"https://kep.k8s.io/647\">KEP-647</a> debuted as alpha in v1.22.\nBoth enhancements were promoted to beta together in the v1.27 release.\nLooking forward, Kubelet Tracing (<a href=\"https://kep.k8s.io/2831\">KEP-2831</a>) and API Server Tracing (<a href=\"https://kep.k8s.io/647\">KEP-647</a>) are now targeting graduation to stable in the upcoming v1.34 release.</p><h3> and  traffic distribution for Services</h3><p>The  field within a Kubernetes <a href=\"https://kubernetes.io/docs/concepts/services-networking/service/\">Service</a> allows users to express preferences for how traffic should be routed to Service endpoints.</p><p><a href=\"https://kep.k8s.io/3015\">KEP-3015</a> deprecates  and introduces two additional values:  and .\n is equivalent to the current .\n prioritizes sending traffic to endpoints on the same node as the client.</p><p>This feature was introduced in v1.33 behind the <code>PreferSameTrafficDistribution</code> feature gate.\nIt is targeting graduation to beta in v1.34 with its feature gate enabled by default.</p><h3>Support for KYAML: a Kubernetes dialect of YAML</h3><p>KYAML aims to be a safer and less ambiguous YAML subset, and was designed specifically\nfor Kubernetes. Whatever version of Kubernetes you use, you'll be able use KYAML for writing manifests\nand/or Helm charts.\nYou can write KYAML and pass it as an input to  version of ,\nbecause all KYAML files are also valid as YAML.\nWith kubectl v1.34, we expect you'll also be able to request KYAML output from  (as in ).\nIf you prefer, you can still request the output in JSON or YAML format.</p><p>KYAML addresses specific challenges with both YAML and JSON.\nYAML's significant whitespace requires careful attention to indentation and nesting,\nwhile its optional string-quoting can lead to unexpected type coercion (for example: <a href=\"https://hitchdev.com/strictyaml/why/implicit-typing-removed/\">\"The Norway Bug\"</a>).\nMeanwhile, JSON lacks comment support and has strict requirements for trailing commas and quoted keys.</p><p><a href=\"https://kep.k8s.io/5295\">KEP-5295</a> introduces KYAML, which tries to address the most significant problems by:</p><ul><li><p>Always double-quoting value strings</p></li><li><p>Leaving keys unquoted unless they are potentially ambiguous</p></li><li><p>Always using  for mappings (associative arrays)</p></li></ul><p>This might sound a lot like JSON, because it is! But unlike JSON, KYAML supports comments, allows trailing commas, and doesn't require quoted keys.</p><p>We're hoping to see KYAML introduced as a new output format for  v1.34.\nAs with all these features, none of these changes are 100% confirmed; watch this space!</p><p>As a format, KYAML is and will remain a , ensuring that any compliant YAML parser can parse KYAML documents.\nKubernetes does not require you to provide input specifically formatted as KYAML, and we have no plans to change that.</p><h3>Fine-grained autoscaling control with HPA configurable tolerance</h3><p><a href=\"https://kep.k8s.io/4951\">KEP-4951</a> introduces a new feature that allows users to configure autoscaling tolerance on a per-HPA basis,\noverriding the default cluster-wide 10% tolerance setting that often proves too coarse-grained for diverse workloads.\nThe enhancement adds an optional  field to the HPA's  and  sections,\nenabling different tolerance values for scale-up and scale-down operations,\nwhich is particularly valuable since scale-up responsiveness is typically more critical than scale-down speed for handling traffic surges.</p><p>Released as alpha in Kubernetes v1.33 behind the  feature gate, this feature is expected to graduate to beta in v1.34.\nThis improvement helps to address scaling challenges with large deployments, where for scaling in,\na 10% tolerance might mean leaving hundreds of unnecessary Pods running.\nUsing the new, more flexible approach would enable workload-specific optimization for both\nresponsive and conservative scaling behaviors.</p><p>New features and deprecations are also announced in the Kubernetes release notes.\nWe will formally announce what's new in <a href=\"https://github.com/kubernetes/kubernetes/blob/master/CHANGELOG/CHANGELOG-1.34.md\">Kubernetes v1.34</a> as part of the CHANGELOG for that release.</p><p>The Kubernetes v1.34 release is planned for <strong>Wednesday 27th August 2025</strong>. Stay tuned for updates!</p><p>The simplest way to get involved with Kubernetes is to join one of the many <a href=\"https://github.com/kubernetes/community/blob/master/sig-list.md\">Special Interest Groups</a> (SIGs) that align with your interests.\nHave something you'd like to broadcast to the Kubernetes community? Share your voice at our weekly <a href=\"https://github.com/kubernetes/community/tree/master/communication\">community meeting</a>, and through the channels below.\nThank you for your continued feedback and support.</p>","contentLength":8979,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","k8s"]}