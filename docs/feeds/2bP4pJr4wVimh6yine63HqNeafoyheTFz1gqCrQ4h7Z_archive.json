{"id":"2bP4pJr4wVimh6yine63HqNeafoyheTFz1gqCrQ4h7Z","title":"AlgoMaster Newsletter","displayTitle":"Dev - Algomaster","url":"https://blog.algomaster.io/feed","feedLink":"https://blog.algomaster.io/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":7,"items":[{"title":"System Design Interviews were HARD Until I Learned these 15 Tips","url":"https://blog.algomaster.io/p/system-design-interview-tips","date":1737001843,"author":"Ashish Pratap Singh","guid":657,"unread":true,"content":"<p>When I started preparing for  for the first time in 2019, I felt completely overwhelmed. It wasn’t a subject covered in college, and I had no prior experience building scalable systems.</p><p>But, over time, I realized that <strong>you don’t need professional experience with distributed systems to pass system design interviews</strong>.</p><p>Even experienced engineers often find these interviews challenging because the format is unique and requires a specific approach.</p><p>The good news is that once you understand the , the , and , and learn how to connect them effectively, system design interviews become far less intimidating.</p><p>In this article, I’ll share  that improved my system design interview skills and made it significantly easier—and hopefully, they’ll do the same for you.</p><p>In a system design interview, the interviewer evaluates your ability to , , and .</p><p>Here’s what they are looking for:</p><ul><li><p> Can you ask the right questions to clarify functional and non-functional requirements?</p></li><li><p> Can you outline the main components of the system (e.g., clients, APIs, databases, caching, load balancers) and explain how they interact?</p></li></ul><ul><li><p> Can your design handle increased traffic or scale with user growth? </p></li><li><p> Can you address single points of failure and ensure fault tolerance?</p></li><li><p> Can you explain the pros and cons of your decisions and justify your choices?</p></li><li><p> Can you dive into the details of critical components (e.g., database schema, caching strategy, API design)?</p></li><li><p><strong>Bottlenecks and Edge Cases:</strong> Can you identify potential issues and propose strategies to mitigate them?</p></li><li><p> Can you articulate your ideas clearly and engage in a constructive discussion with the interviewer?</p></li><li><p> Are you receptive to feedback and able to refine your design?</p></li><li><p> Can you manage your time effectively and focus on high-impact components?</p></li><li><p> Are you familiar with common system design patterns (e.g., sharding, replication, caching)?</p></li><li><p> Can you discuss tools or technologies relevant to the problem?</p></li></ul><p>System design interviews typically last , which means managing your time effectively is crucial.</p><p>A well-structured approach ensures you cover all key aspects of the design while leaving room for discussion and feedback with the interviewer.</p><p>Here’s a framework you can follow:</p><ol><li><p><strong>Clarifying Requirements (5-10 minutes):</strong> Understand functional and non-functional needs.</p></li><li><p><strong>High-Level Design (10-15 minutes): </strong>Outline the system's main components and overall architecture (e.g., clients, database, cache, load balancer, messaging queues).</p></li><li><p><strong>Database Design (5-8 minutes): </strong>Choose the appropriate database type (SQL, NoSQL, or hybrid). Define schemas and discuss partitioning, indexing, replication, and caching.</p></li><li><p><strong>API Design (5-8 minutes): </strong>Define intuitive and scalable APIs. List critical endpoints and their purpose.</p></li><li><p><strong>Deep Dive into Key Components (15-20 minutes): </strong>Discuss 2-3 critical components in detail.</p></li><li><p><strong>Handling Trade-Offs and Edge Cases (5-10 minutes): </strong>Highlight trade-offs, bottlenecks, and failure handling. Propose mitigation strategies.</p></li><li><p><strong>Address scalability, security and monitoring (5-10 minutes): </strong>Explain how your design handles growth, ensures security, and incorporates monitoring.</p></li></ol><p>You can adjust this framework based on the problem type and requirements.</p><blockquote><p>I haven’t included  here but I recommend minimal capacity estimation at the start to set context (e.g., \"The system will handle 1 million requests per day\").</p><p>Avoid detailed calculations unless explicitly required. You don’t want to waste your precious time doing unnecessary maths calculation.</p></blockquote><p>A common mistake many candidates make is jumping directly into designing the system without fully understanding what needs to be built.</p><p>System design questions are intentionally  and often underspecified. Interviewers deliberately withhold details, expecting you to ask the right questions to uncover the information you need.</p><p>To succeed, start by clarifying the —the  and  the system must support.</p><p>At this stage, avoid thinking about design, implementation, or technical specifics. The primary goal is to define  needs to be built, not  to build it or the scale it needs to support. Focus purely on understanding the \"what.\"</p><p>Based on the problem, list down the core features and use cases and confirm them with the interviewer.</p><ul><li><p>What specific features does the system need?</p></li><li><p>Are there any must-have or optional features?</p></li><li><p>What are the main objects and their relations?</p></li><li><p>How the objects will interact with each other and access pattern?</p></li><li><p>Can the system’s objects be modified after creation?</p></li><li><p>What types of data will the system handle?</p></li></ul><p> For a chat application:</p><ul><li><p>Users should be able to send and receive messages.</p></li><li><p>The primary objects are users and messages.</p></li><li><p>Users should view all messages in chronological order.</p></li><li><p>Messages may be edited or deleted after being sent.</p></li><li><p>Messages may include text, images, and videos.</p></li></ul><blockquote><p>Your aim is to ask just enough questions to gather a clear picture of all important use cases for the system.</p></blockquote><p>Once functional requirements are well-defined, shift your focus to <strong>non-functional requirements</strong>.</p><p>These describe  the system should perform its functions.</p><p>The most common non-functional requirements you should consider in a system design interview are:</p><ul><li><p> How quickly should the system respond to user requests?</p></li><li><p> Should the system tolerate downtime? If yes, how much?</p></li><li><p> Is strong or eventual consistency required?</p></li><li><p> Are there any special security considerations or workflows?</p></li></ul><p><strong>Questions to Clarify NFRs:</strong></p><ul><li><p>What is the  of the system?</p><ul><li><p>How many users should it support?</p></li><li><p>How many requests per second should the server handle?</p></li></ul></li><li><p>Is  acceptable? What is the cost of downtime for this system?</p></li><li><p>Is the system  or ? What is the read-to-write ratio?</p></li><li><p>Should updates be visible to users instantly, or is a delay acceptable?</p></li><li><p>Are there any specific  concerns?</p><ul><li><p> Are there workflows involving sensitive data or code execution?</p></li></ul></li></ul><p> For a chat application:</p><ul><li><p> 1 million daily active users, with up to 10,000 concurrent users per server.</p></li><li><p> Aim for 99.99% uptime (no more than ~52 minutes of downtime per year).</p></li><li><p> High read volume as users fetch messages frequently compared to writing messages.</p></li><li><p> Messages should appear in real-time for recipients.</p></li></ul><p><strong>This post is for paid subscribers.</strong> If you're interested in becoming a paid subscriber or have questions about it—such as the benefits, expense templates, or alternative payment options (e.g., UPI)—you can find more details </p>","contentLength":6279,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fabdee1ae-3577-48de-bc65-1f0945ddb78e_1608x1164.png","enclosureMime":"","commentsUrl":null},{"title":"6 Coding Interview Secrets from a 2-Time ICPC Finalist","url":"https://blog.algomaster.io/p/coding-interview-secrets-from-a-icpc-finalist","date":1736830814,"author":"Ashish Pratap Singh","guid":656,"unread":true,"content":"<p>Hi everyone, Ashish here!</p><p>Today’s article features a special guest , a competitive programmer and a 2-Time  Finalist.</p><p>In this article, Alberto will share his insights on <strong>improving your problem-solving skills</strong> and <strong>preparing for coding interviews</strong>.</p><p>Ever felt like coding interviews are designed to make you question your entire career?</p><p>As someone who’s been under the spotlight at the ICPC World Finals—not once but twice—I know what it’s like to face impossible-seeming challenges.</p><p>Competitive programming taught me how to tackle problems systematically, handle pressure, and, most importantly, keep going when things felt impossible.</p><p>But here’s the thing: <em>you don’t need an ICPC title to crush your coding interviews.</em></p><p>You just need a focused plan, a bit of grit, and the right mindset.</p><h3><strong>1. You Need to Lay the Right Foundation</strong></h3><p>Coding interviews aren’t just about algorithms—they’re about confidence.</p><p>Yet one of the biggest fears is walking in and realizing you’re not prepared for the basics.</p><p>The solution? Master these core areas:</p><ul></ul><p>💡  Focus on one topic at a time. Consistency over cramming—it works.</p><p>I remember spending hours on my first binary tree problem, convinced I’d never get it.</p><p>But once I learned to break the problem down step by step, the complexity melted away.</p><h3><strong>2. Then, You Need to Start Recognizing Patterns</strong></h3><p>Ever feel like you’ve solved hundreds of problems but still get stuck?</p><p>It’s not about solving —it’s about solving smarter.</p><p>Coding problems often follow predictable patterns.</p><p>When you recognize the underlying structure, the solution becomes much simpler.</p><p>Here are a few patterns worth mastering:</p><ul><li><p> Ideal for sorted arrays.</p></li><li><p> For substring or interval problems.</p></li><li><p> For efficiently finding an element in a sorted list.</p></li><li><p>To answer range sum queries in constant time.</p></li><li><p>For finding the next/previous greater or smaller element.</p></li><li><p>For exploring all possible configurations.</p></li></ul><p>💡  Pick a pattern and dive deep. Solve 5–10 problems for each, focusing on understanding  the pattern works.</p><p>Think of patterns like shortcuts on a map—they get you to the solution faster, with fewer dead ends.</p><h3><strong>3. At Some Point, You Need to Simulate the Real Deal</strong></h3><p>Here’s the fear no one talks about: freezing during an interview.</p><p>You know the material, but when it’s time to perform, your brain says, “Nope.”</p><p>Sweaty palms, a simple BFS problem, and 20 minutes of staring at the screen like it was written in ancient Greek.</p><p>Recreate interview conditions so the real thing feels like just another session.</p><ul><li><p>Set a timer and work on a problem without syntax hints.</p></li><li><p>Use a whiteboard or plain text editor—no IDE crutches.</p></li><li><p>Practice explaining your thought process out loud.</p></li></ul><p>💡  Schedule a mock interview with a peer or use an online platform.</p><p>It’s awkward at first, but it’s the fastest way to build confidence.</p><h3><strong>4. If You Don’t Have Much Time, You Need to Focus on High-Impact Topics</strong></h3><p>Not all topics are prioritized equally.</p><p>Spending hours on niche problems might feel productive, but it won’t help when interviewers hit you with the classics.</p><ul><li><p> Search and Sorting algorithms, two pointers.</p></li><li><p>: Reversal, cycle detection, and partitioning.</p></li><li><p>: Binary trees, binary search trees, and traversals.</p></li><li><p> DFS, BFS, topological sorting, and shortest path algorithms.</p></li><li><p>: Permutations, combinations, Sudoku solver, and N-Queens problem.</p></li><li><p>: Top-K elements, and merging K sorted lists.</p></li><li><p>: Word search, autocomplete, and prefix matching.</p></li><li><p> Problems like Knapsack or Longest Common Subsequence.</p></li></ul><p>💡  Track your progress on high-yield topics using tools like Notion or Trello.</p><p>Seeing your wins pile up is a great motivator.</p><p>The goal isn’t to know everything—it’s to be a pro at what matters most.</p><h3><strong>5. If You Want to be an Engineer, You Need to Communicate Like an Engineer</strong></h3><p>Coding interviews aren’t just about solving problems—they’re about showing  you solve problems.</p><p>Clear communication sets you apart.</p><ol><li><p> Restate it to show you understand.</p></li><li><p> Share your strategy before you start coding.</p></li><li><p> Explain your logic, handle edge cases, and think aloud.</p></li></ol><p>💡  Record yourself solving a problem.</p><p>Play it back to catch moments where you over-complicate or skip explanations.</p><p>Interviewers don’t expect perfection—they expect clarity and problem-solving skills.</p><h3><strong>6. And Finally, You Need to Build Resilience</strong></h3><p>Let’s talk about failure.</p><p>It’s not if—it’s when. But every mistake is a step closer to mastery.</p><p>During my ICPC journey, I submitted hundreds of wrong answers.</p><p>Some were silly oversights; others were genuinely tough problems.</p><p>But every “wrong answer” was a chance to learn something new.</p><p>💡  Keep a failure journal.</p><p>Write down problems you struggled with, what you learned, and how you’ll tackle similar issues in the future.</p><p>Failure isn’t the end; it’s the beginning of better solutions.</p><p>Here are a few resources I personally used to improve at problem-solving:</p><ul><li><ul><li><p>Section for training as a team.</p></li><li><p>Educational section to learn new topics.</p></li><li><p>Highly engaged community and blogs where people go beyond the basics.</p></li></ul></li><li><ul><li><p>Slightly advanced topics.</p></li><li><p>The most beautiful algorithmic problems you will ever see.</p></li></ul></li></ul><p>If you’ve ever doubted your ability to land that dream job, let me be the proof: persistence, focus, and the right system can transform everything.</p><p>And leveraging your competitive advantage will change your life—more on that in this post:</p><div data-attrs=\"{&quot;id&quot;:153618089,&quot;url&quot;:&quot;https://albexl.substack.com/p/competitive-programming-changed-my&quot;,&quot;publication_id&quot;:1412859,&quot;publication_name&quot;:&quot;Algorithmically Speaking&quot;,&quot;publication_logo_url&quot;:&quot;https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F122a9387-dca2-4a14-9358-97b897b474ce_1024x1024.png&quot;,&quot;title&quot;:&quot;Competitive Programming Changed My Life Forever&quot;,&quot;truncated_body_text&quot;:&quot;I’m writing to you from Gothenburg, Sweden—a place where I’ve found the perfect balance between meaningful work and a fulfilling life.&quot;,&quot;date&quot;:&quot;2024-12-26T12:07:24.294Z&quot;,&quot;like_count&quot;:31,&quot;comment_count&quot;:7,&quot;bylines&quot;:[{&quot;id&quot;:121975303,&quot;name&quot;:&quot;Alberto Gonzalez&quot;,&quot;handle&quot;:&quot;albexl&quot;,&quot;previous_name&quot;:&quot;Alberto Gonzalez 🚢&quot;,&quot;photo_url&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/0463f9f0-08db-4877-aa9c-e18dbb8888b3_1024x1024.png&quot;,&quot;bio&quot;:&quot;MSc. Computer Science &amp; Writer | I help you secure software engineering jobs, and create a personal brand that draws high-value opportunities | Cappuccino lover ☕&quot;,&quot;profile_set_up_at&quot;:&quot;2023-02-12T22:44:33.354Z&quot;,&quot;publicationUsers&quot;:[{&quot;id&quot;:1375368,&quot;user_id&quot;:121975303,&quot;publication_id&quot;:1412859,&quot;role&quot;:&quot;admin&quot;,&quot;public&quot;:true,&quot;is_primary&quot;:false,&quot;publication&quot;:{&quot;id&quot;:1412859,&quot;name&quot;:&quot;Algorithmically Speaking&quot;,&quot;subdomain&quot;:&quot;albexl&quot;,&quot;custom_domain&quot;:null,&quot;custom_domain_optional&quot;:false,&quot;hero_text&quot;:&quot;Balancing your life while navigating the engineering world is scary until you read Algorithmically Speaking. Actionable work strategies, health tips, and relationship-building advice for software engineers.&quot;,&quot;logo_url&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/122a9387-dca2-4a14-9358-97b897b474ce_1024x1024.png&quot;,&quot;author_id&quot;:121975303,&quot;theme_var_background_pop&quot;:&quot;#99A2F1&quot;,&quot;created_at&quot;:&quot;2023-02-12T22:44:53.280Z&quot;,&quot;rss_website_url&quot;:null,&quot;email_from_name&quot;:&quot;Alberto from Algorithmically Speaking&quot;,&quot;copyright&quot;:&quot;Alberto Gonzalez&quot;,&quot;founding_plan_name&quot;:&quot;Core Supporter&quot;,&quot;community_enabled&quot;:true,&quot;invite_only&quot;:false,&quot;payments_state&quot;:&quot;enabled&quot;,&quot;language&quot;:null,&quot;explicit&quot;:false,&quot;is_personal_mode&quot;:false}},{&quot;id&quot;:3541789,&quot;user_id&quot;:121975303,&quot;publication_id&quot;:3474876,&quot;role&quot;:&quot;admin&quot;,&quot;public&quot;:true,&quot;is_primary&quot;:false,&quot;publication&quot;:{&quot;id&quot;:3474876,&quot;name&quot;:&quot;Code With AI&quot;,&quot;subdomain&quot;:&quot;programwithai&quot;,&quot;custom_domain&quot;:null,&quot;custom_domain_optional&quot;:false,&quot;hero_text&quot;:&quot;The leading paid newsletter for GitHub Copilot prompts, and how to turn AI into your own personal pair programmer.&quot;,&quot;logo_url&quot;:&quot;https://substack-post-media.s3.amazonaws.com/public/images/6a1d4d60-653f-460b-916f-6967a5b1f3bf_1024x1024.png&quot;,&quot;author_id&quot;:121975303,&quot;theme_var_background_pop&quot;:&quot;#FF6719&quot;,&quot;created_at&quot;:&quot;2024-12-06T16:46:59.453Z&quot;,&quot;rss_website_url&quot;:null,&quot;email_from_name&quot;:&quot;Alberto from Code With AI&quot;,&quot;copyright&quot;:&quot;Alberto Gonzalez&quot;,&quot;founding_plan_name&quot;:&quot;Core Supporter&quot;,&quot;community_enabled&quot;:true,&quot;invite_only&quot;:false,&quot;payments_state&quot;:&quot;enabled&quot;,&quot;language&quot;:null,&quot;explicit&quot;:false,&quot;is_personal_mode&quot;:false}}],&quot;twitter_screen_name&quot;:&quot;albe_xl&quot;,&quot;is_guest&quot;:false,&quot;bestseller_tier&quot;:null}],&quot;utm_campaign&quot;:null,&quot;belowTheFold&quot;:true,&quot;type&quot;:&quot;newsletter&quot;,&quot;language&quot;:&quot;en&quot;}\" data-component-name=\"EmbeddedPostToDOM\"><a native=\"true\" href=\"https://albexl.substack.com/p/competitive-programming-changed-my?utm_source=substack&amp;utm_campaign=post_embed&amp;utm_medium=web\"><div><div>Competitive Programming Changed My Life Forever</div></div><div>I’m writing to you from Gothenburg, Sweden—a place where I’ve found the perfect balance between meaningful work and a fulfilling life…</div><div>22 days ago · 31 likes · 7 comments · Alberto Gonzalez</div></a></div><p>Your dream job isn’t just about a bigger paycheck. It’s about proving to yourself that you belong.</p><p>Let’s turn those hidden fears into unstoppable momentum.</p>","contentLength":5696,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F60ad9422-f08a-4055-bd8e-911adbe29b73_3742x2366.png","enclosureMime":"","commentsUrl":null},{"title":"Introducing Weekly Premium Deep Dives","url":"https://blog.algomaster.io/p/introducing-weekly-premium-deep-dives","date":1736658108,"author":"Ashish Pratap Singh","guid":655,"unread":true,"content":"<p>I launched this newsletter in  with one goal: to make complex  and  topics simple and accessible.</p><p>Ten months, , and  later, this newsletter has grown to a community of  — all thanks to your incredible support!</p><p>Over the past 10 months, I’ve consistently published at least one article every week.</p><p>Along the way, I’ve received a lot of requests and feedback. One thing became clear: many readers want <strong>more in-depth explanations</strong>, <strong>higher-quality resources, coverage of advanced topics and more support.</strong></p><p>As a result, I’ve decided to devote more time and energy to this newsletter to deliver even greater value.</p><p>I’m introducing a , while continuing to offer free content:</p><h4><strong>Free Subscribers Benefits:</strong></h4><h4><strong>Paid Subscribers Benefits:</strong></h4><p>📝 <strong>Exclusive Deep-Dive Article Every Thursday covering:</strong></p><ul><li><p>Advanced topics that push your understanding further.</p></li><li><p>Crash courses on DSA and system design concepts.</p></li><li><p>System design interview problems (HLD, LLD) and case studies.</p></li><li><p>Real-world coding challenges.</p></li><li><p>Tips for interviews and career growth.</p></li><li><p>More visuals and diagrams.</p></li></ul><p><strong>📂 Full Access to all articles.</strong></p><p>💬 <strong>Priority Replies to Your Questions and Comments.</strong></p><p>✨ <strong>and influence what I write about next.</strong></p><p>🤝 <strong>Private Discord Community to </strong>connect with like-minded peers, ask questions, resume review, mock interviews and more.</p><p>📚 <strong>Free Access to Future E-Books, Cheat Sheets, and Templates</strong></p><h4><strong>Founding Member Benefits:</strong></h4><p>Everything in the paid subscription plan, plus:</p><p>📞 A  with me to discuss anything — career advice, mock interviews, dsa, system design, or personal growth.</p><p> from me via chat for any questions or discussions.</p><p>If you’ve enjoyed my free articles like these:</p><p>…then you’re going to love the exclusive, deeper content coming your way as a paid subscriber!</p><p>The first paid article will go out this .</p><p><strong>$100 per year, or $10/month.</strong></p><p><strong>✨ To thank you for being an early supporter, subscribe in the next 72 hours and get 30% off forever — just $70, or $7/month ✨</strong></p><p>Since most of what I write is highly relevant to software engineers, you can probably use your <strong>company’s learning budget</strong> to cover the subscription cost. You can find an expense template .</p><p>If you can’t afford it, please reach out at <a href=\"mailto:contact@algomaster.io\">contact@algomaster.io</a>. Include your reason and LinkedIn profile if possible, and we’ll work something out.</p><p>If you've found this newsletter valuable, or just want to support my work, I'd be incredibly grateful for your subscription.</p><p>Thank you for being a part of this journey. I’m excited to continue growing this community with you!</p>","contentLength":2495,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F5b20e9cd-9f6a-4752-8b74-b7cb25c9a8ba_946x733.png","enclosureMime":"","commentsUrl":null},{"title":"How to Start LeetCode in 2025","url":"https://blog.algomaster.io/p/how-to-start-leetcode-in-2025","date":1736054985,"author":"Ashish Pratap Singh","guid":654,"unread":true,"content":"<p>It’s  and most top tech companies are still asking  in coding interviews.</p><p>But getting started on LeetCode is harder than ever. With over 3,000 problems, it’s easy to feel overwhelmed and lost.</p><ul><li><p><strong>Which problems should you solve? </strong></p></li><li><p><strong>How many problems are enough for coding interviews?</strong></p></li><li><p><strong>How much time should you spend on each problem?</strong></p></li></ul><p>I will answer these questions and more in this article to make your journey smoother, and lot less less painful.</p><p>For context - I’ve solved more than 1,500 LeetCode problems and cleared interviews at multiple big tech companies including Amazon, Google, and Microsoft and in this article I’ll share everything I’ve learned to help you start and navigate LeetCode more effectively.</p><p>I’ll share practical tips and resources to help you save time, stay focused and build your problem-solving skills without feeling overwhelmed.</p><h2>Why do you even need LeetCode?</h2><p>You might be wondering: why is everyone doing LeetCode questions. Is it really necessary to land a Software Engineering job?</p><p>The short answer is: .</p><p>There are plenty of startups and smaller companies that focus more on your experience with specific tech stacks and the projects you’ve built. They might not even include LeetCode style questions in their interview process.</p><p>But if your goal is to work at big tech companies like Amazon, Google, or Microsoft, you would need to practice LeetCode style questions since that’s what they ask in their interviews.</p><h2>Which programming language to choose?</h2><p>This is a question I get asked all the time.</p><p>Many people get stuck at deciding which programming language to use.</p><p>But here’s the truth: <strong>It doesn’t really matter.</strong> A programming language is just a tool. Once you understand the approach to solving a problem, you can implement it in any language.</p><p>In my experience giving interviews, unless the job specifically requires expertise in a certain language, you’ll be fine using any language you’re comfortable with.</p><p>The point is, LeetCode isn’t about syntax. It’s about using the right data structures, algorithms, and your ability to think critically and solve problems.</p><p>That said, if you’re new to coding, I recommend starting with  It’s beginner-friendly and has a simpler syntax.</p><p>If you already know a language—stick with it. </p><p>Whether it’s C++, Java, C#, JavaScript, TypeScript or Go, there’s no need to switch.</p><p>You don’t need to be an expert in your chosen language, but you should know the basics like:</p><ul><li><p>and input/output operations</p></li></ul><p>Beyond the basics, spend some time learning the  for common data structures and algorithms.</p><p>These libraries save time and let you focus on solving the problem rather than reimplementing data structures from scratch.</p><ul><li><p>Python has lists, dictionaries, and sets.</p></li><li><p>Java has ArrayList, HashMap, and PriorityQueue.</p></li><li><p>C++ offers the STL library with vector, map, and set.</p></li></ul><p>Before diving into LeetCode problems, it’s good to familiarize yourself with the fundamentals of data structures and algorithms.</p><ul><li><p><strong>Basic Data Structures like</strong> Arrays, strings, linked lists, stacks, queues, hash tables, and binary trees.</p></li><li><p><strong>and Fundamental Algorithms like</strong> Sorting techniques, binary search, and recursion.</p></li></ul><p>Recursion is particularly important, since many problems specially tree and graph related ones rely heavily on it.</p><p>When you’re familiar with these topics, it becomes much easier to recognize which concept applies to a specific problem.</p><p>You don’t need to dive too deeply into every topic upfront. Most of your understanding will develop naturally as you solve problems.</p><p>There are plenty of resources available online to help you get started. Don’t waste time searching for the “perfect” resource—pick one and start learning.</p><p><strong>The focus should always be on progress, not perfection.</strong></p><p>Here are some resources I personally found quite useful:</p><p> It’s my second channel where I upload animated tutorials on DSA and LeetCode patterns.</p><p>Here’s a comprehensive list of DSA topics you should know for coding interviews:</p><h2>Learn one topic at a time</h2><p>If you’re a beginner, focus on one topic at a time to avoid feeling overwhelmed.</p><p>For example: Start with , the move to , then progress to more complex topics like , , and .</p><p>This approach helps you develop a deeper understanding of each topic and teaches you how to recognize when to use a particular data structure or algorithm.</p><p>Once you’ve learned the basics of a topic and understand how to implement it from scratch, it’s time to put your knowledge to the test.</p><p>Solve 4-5 easy problems related to that topic on LeetCode.</p><ul><li><p>and Build confidence in applying the concepts.</p></li></ul><p>If you want to learn more about how to master a DSA topic, you can check out this article where I discuss it in more detail:</p><h2>Which problems should you solve?</h2><p>If you open LeetCode, there are over </p><p>That number alone can feel overwhelming. So, how do you decide which ones to solve?</p><p>Start with  for each topic. These are perfect for building confidence and understanding the basics of problem-solving.</p><p>Once you’re comfortable with the easy ones, gradually challenge yourself with slightly harder problems that push you beyond your comfort zone.</p><p>Remember, <strong>real growth happens when you</strong> constantly </p><p>Don’t worry about hard problems in the beginning.</p><p>Most coding interviews focus on , so that’s where you should spend the majority of your time.</p><p>These lists are excellent, and I highly recommend solving every problem on them.</p><h2>How many problems should you solve?</h2><p>There’s no magic number, but from my experience,  is the sweet spot.</p><p>However, it’s not about solving just any 300 problems. Focus on  that cover the most topics and patterns.</p><p>To make it easier for you, I’ve created a : a curated list of the <strong>Top 300 LeetCode Problems</strong> organized into that are most commonly asked in coding interviews.</p><p>You can find it on  Just head to the practice page. You will see a structured list  that you can follow from top to bottom.</p><ul><li><p>Resources to help you learn the topics.</p></li><li><p>Ability to track your progress and mark problems for future revision.</p></li><li><p>Links to <strong>GitHub and YouTube solutions</strong>.</p></li><li><p>and ability to filter problems based on pattern, difficulty level and status.</p></li></ul><p>Don’t rush through problems just to increase your count. Instead of focusing on the quantity of problems you solve, focus on what you learn from each problem.</p><p>It’s far better to deeply understand and solve 50 problems than to superficially solve 500 problems.</p><p>After solving a problem, ask yourself:</p><ul><li><p><em>Why does this solution work?</em></p></li><li><p><em>What’s the one key insight that made everything else easier?</em></p></li></ul><p>Also, try to make it fun. There is a fun in learning to solve coding challenges. It’s not just about getting a job.</p><h2>Focus on learning Patterns</h2><p>The key to getting better at LeetCode is learningas manypatterns as possible.</p><p>Instead of focusing on individual questions, focus on identifying  that connect similar problems.</p><p>On LeetCode, you’ll come across multiple problems that follow a similar patterns. Once you solve one of them, you can apply the same approach to solve others.</p><p>For example: After learning the monotonic stack , I was able to solve over 10 similar problems.</p><p>I made a  covering the 15 <strong>most important LeetCode patterns</strong> I learned after solving over 1,500 problems. You can check it out later.</p><p>On , I’ve categorized problems by pattern. This makes it easy to focus on one pattern at a time. By going through the list, you will get to know all the important patterns for coding interviews.</p><h2>How to approach a new problem?</h2><h4><strong>1. Read the Problem Statement Twice</strong></h4><p>The first time, focus on getting the big picture. What is the problem asking you to do?</p><p>On the second read, pay attention to specific constraints and conditions. These small details often provide clues for optimizing your solution.</p><h4><strong>2. Analyze the Input and Output Examples</strong></h4><p>Carefully go through the examples provided in the problem.</p><p>Walk through the input and output step by step to understand how the problem works. I have found that, many times simply walking through a few examples helped me figure out the solution.</p><h4><strong>3. Visualize with pen and paper</strong></h4><p>Many problems specially the ones related to trees and graphs are much easier to understand when you draw them out.</p><p>Try to take examples that cover different scenarios and input sizes. Think about any  that might come up.</p><h4><strong>4. Start with a Brute Force Approach</strong></h4><p>Don’t expect to come up with the most optimal solution right away.</p><p>First see, if you can solve the problems using a brute force approach. While it might not be efficient, it gives you a baseline to improve upon.</p><h4><strong>5. Optimize Your Solution</strong></h4><p>Once you have a brute force solution, focus on optimizing it.</p><p>Here are few things to consider:</p><ul><li><p><strong>Leverage Unused Information</strong>: Look for details you might have missed. For instance, if the problem states that the array is sorted, consider leveraging this to use binary search or a two-pointer approach.</p></li><li><p>: If certain calculations are repeated multiple times, consider precomputing them. Use techniques like  or  to avoid redundant calculations. Hash tables are widely used in interview questions and should be at the top of your mind.</p></li><li><p><strong>Make Time vs. Space Tradeoffs:</strong> Sometimes, using additional memory (e.g., hash tables) can speed up your solution.</p></li><li><p><strong>Data Structure Brainstorm:</strong> Run through the popular data structures and try to apply each one to the problem at hand.</p></li></ul><p>Avoid overcomplicating your solution. At every stage ask yourself, <em><strong>\"Is there a simpler way to do this?\"</strong></em>. This will not only make your solution easier to understand but it will also reduce the chances of errors during coding.</p><h4><strong>7. Analyze Time and Space Complexity</strong></h4><p>Develop the habit of analyzing the time and space complexity of every problem you submit.</p><h2>How much time should you spend on each problem?</h2><p>When you’re just starting out, even  can take a while to solve. That’s completely normal—don’t get discouraged if you can’t come up with a solution right away.</p><p>Your main goal in the beginning should be to  and understanding the problem deeply. Real progress happens when you take the time to think, make mistakes and refine your approach.</p><p>But, some problems involve specific tricks or patterns that are hard to figure out unless you’ve seen them before.</p><p>Spending hours on such problems without progress can be counterproductive.</p><p>Here’s a good rule of thumb:</p><ul><li><p>Give yourself  of focused effort for each problem.</p></li><li><p>If you’re still stuck, it’s okay to look at hints or solutions.</p></li></ul><p>Read the official solution and and try to understand the top voted solutions on LeetCode discussion forum.</p><p>Don’t just move on after viewing the solution. Try to grasp why the solution works.</p><p>Rewrite the solution from scratch without looking at the code. Writing it yourself helps you internalize the approach and ensures you truly understand it.</p><p>If you couldn’t solve the problem on your first attempt, mark it for  and revisit it after a few weeks. Revisiting problems helps reinforce your understanding and ensures long-term retention.</p><p>One of the most common mistakes—one that I made myself—is  to difficult problems and moving on.</p><p>At first, it might seem like a shortcut, but in reality, it’s a  for three main reasons:</p><ol><li><p><strong>You’ll quickly forget memorized solutions.</strong> Without understanding the logic behind them, they won’t stick in your memory.</p></li><li><p><strong>Your problem-solving skills won’t improve.</strong> Memorization skips the critical thinking process, which is the real value of practicing coding problems.</p></li><li><p><strong>You’ll struggle in interviews.</strong> Most interviewers ask variants of problems or follow-up questions, and without a deep understanding, you won’t be able to adapt.</p></li></ol><p>Instead of memorizing, focus on understanding the solution, even if it takes hours.</p><p>Break it down step by step and ask yourself:</p><ul><li><p><strong>Why does this approach work?</strong></p></li><li><p><strong>What’s the key insight that simplifies the problem?</strong></p></li><li><p><strong>How can I apply this approach to similar problems?</strong></p></li></ul><p>This effort pays off in the long term. The deeper your understanding, the more confident you’ll feel explaining your thought process during interviews.</p><h2>Practice in a timed environment</h2><p>Solving a problem during an interview is very different from solving it from the comfort of your home.</p><p>That’s why it’s a good idea to time-box yourself and practice in a timed environment after you have learned the basics and solved 100-150 problems.</p><p>Simply turn on a timer while practicing and try to complete the problem within that time.</p><ul><li><p>For , aim to complete them in </p></li><li><p>For , set a timer for </p></li><li><p>For , allow yourself </p></li></ul><p>To take your practice a step further:</p><ul><li><p>Try  by simulating past LeetCode contests.</p></li></ul><p>It’s okay if you struggle to solve even one problem initially—this is normal. The goal is to gain experience solving problems within a time limit.</p><p>When I started participating in contests, I could only solve 1-2 problems. But with consistent practice, I improved to solving 3 problems, and eventually, I was able to solve all of them in some contests.</p><p>Getting good at LeetCode isn’t just about learning new concepts or solving problems—it’s also about retaining that knowledge over time.</p><p>That’s why you should regularly revisit concepts and problems you’ve already solved, especially the ones you found challenging.</p><p>Try to solve those problems again <strong>without looking at the solution.</strong></p><p>By practicing consistently and revisiting old problems, you’ll make it much easier to retain what you’ve learned over time.</p><p>I discuss more about how to effectively revise LeetCode problems in this article, so make sure to check it out: </p><p>Getting good at LeetCode takes time.</p><p>Some topics might take weeks or even months to master, and that’s okay. </p><p>Be patient with yourself and remember: It’s completely normal to feel stuck or frustrated when working on a tough problem or grasping a complex topic.</p><p>If a problem feels too hard, take a break, then come back to it with a fresh perspective.</p><p>The more you practice, the better you will get at solving LeetCode problems.</p><p>If you found this article helpful and want to dive deeper, consider becoming a . You’ll get exclusive in-depth content every Thursday, along with  that will help you level up your knowledge.</p><p>Hope you enjoyed reading this article.</p><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content every week.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/how-i-mastered-data-structures-and-algorithms?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQ1NjU1MjUyLCJpYXQiOjE3MjE1MjE3MzEsImV4cCI6MTcyNDExMzczMSwiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.2cNY811YEugd5iH9XJQhakBzyahGqF7PcATBlFj5J2w&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p>I hope you have a lovely day!</p>","contentLength":14230,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2F1a074c17-0163-4236-86a4-1cc16d63cc1f_800x616.jpeg","enclosureMime":"","commentsUrl":null},{"title":"7 Cache Eviction Strategies You Should Know","url":"https://blog.algomaster.io/p/7-cache-eviction-strategies","date":1735824121,"author":"Ashish Pratap Singh","guid":653,"unread":true,"content":"<p> is a technique to make applications lightning fast, reduce database load, and improve user experience.</p><p>But, cache memory is  - you can’t store everything.</p><p>So, how do you decide which items to keep and which ones to evict when space runs out?</p><p>This is where <strong>cache eviction strategies</strong> come into play. They determine which items are removed to make room for new ones.</p><p>In this article, we’ll dive into <strong>7 Cache Eviction Strategies</strong> explaining what they are, how they work, their pros and cons.</p><p> provides deep session replays with every detail you need to find and fix a bug. From frontend screens to backend traces, metrics, and logs, all in one place. Debug faster and fix customer problems more easily, so you and your team can stay focused on building great software, not combing through APM data.</p><h2> (LRU)</h2><p> evicts the item that hasn’t been used for the longest time.</p><p>The idea is simple: if you haven’t accessed an item in a while, it’s less likely to be accessed again soon.</p><ul><li><p>: LRU keeps track of when each item in the cache was last accessed. This can be done using various data structures, such as a  or a combination of a  and a .</p></li><li><p><strong>Cache Hit (Item Found in Cache):</strong> When an item is accessed, it is moved to the  position in the tracking data structure (e.g., moving it to the front of a list).</p></li><li><p><strong>Cache Miss (Item Not Found in Cache):</strong></p><ul><li><p>If the item isn’t in the cache and the cache has free space, it is added directly.</p></li><li><p>If the cache is full, the  is evicted to make space for the new item.</p></li></ul></li><li><p>The item that has been accessed least recently (tracked at the beginning of the list) is removed from the cache.</p></li></ul><p>Consider a cache with a capacity of 3:</p><ol><li><p>: Empty cache.</p></li><li><p>Access  → Cache: [B, C, A] (A becomes recently used)</p></li><li><p>Add → Cache: [C, A, D] (B is evicted as it's the “least recently used”)</p></li></ol><ol><li><p>: Easy to understand and widely adopted.</p></li><li><p>: Keeps frequently accessed items in the cache.</p></li><li><p><strong>Optimized for Real-World Usage</strong>: Matches many access patterns, such as web browsing and API calls.</p></li></ol><ol><li><p>: Tracking usage order can consume additional memory.</p></li><li><p>: For large caches, maintaining the access order may introduce computational overhead.</p></li><li><p>: Assumes past access patterns will predict future usage, which may not always hold true.</p></li></ol><h2> (LFU)</h2><p> evicts the item with the lowest access frequency. It assumes that items accessed less frequently in the past are less likely to be accessed in the future.</p><p>Unlike LRU, which focuses on , LFU emphasizes  of access.</p><ul><li><p>: LFU maintains a frequency count for each item in the cache, incrementing the count each time the item is accessed.</p></li><li><p><strong>Cache Hit (Item Found in Cache):</strong> When an item is accessed, its frequency count is increased.</p></li><li><p><strong>Cache Miss (Item Not Found in Cache):</strong></p><ul><li><p>If the cache has available space, the new item is added with an initial frequency count of 1.</p></li><li><p>If the cache is full, the <strong>item with the lowest frequency</strong> is evicted to make room for the new item. If multiple items share the same lowest frequency, a secondary strategy (like LRU or FIFO) resolves ties.</p></li></ul></li><li><p>: Remove the item with the smallest frequency count.</p></li></ul><p>Consider a cache with a capacity of 3:</p><ol><li><p>: Empty cache.</p></li><li><p>Add  → Cache: [A (freq=1)]</p></li><li><p>Add  → Cache: [A (freq=1), B (freq=1)]</p></li><li><p>Add  → Cache: [A (freq=1), B (freq=1), C (freq=1)]</p></li><li><p>Access  → Cache: [A (freq=2), B (freq=1), C (freq=1)]</p></li><li><p>Add  → Cache: [A (freq=2), C (freq=1), D (freq=1)] (B is evicted as it has the lowest frequency).</p></li><li><p>Access  → Cache: [A (freq=2), C (freq=2), D (freq=1)]</p></li></ol><ol><li><p><strong>Efficient for Predictable Patterns</strong>: Retains frequently accessed data, which is often more relevant.</p></li><li><p><strong>Highly Effective for Popular Data</strong>: Works well in scenarios with clear \"hot\" items.</p></li></ol><ol><li><p>: Requires additional memory to track frequency counts.</p></li><li><p>: Tracking and updating frequency can slow down operations.</p></li><li><p>: May keep items that were frequently accessed in the past but are no longer relevant.</p></li></ol><h2>3. First In, First Out (FIFO)</h2><p>FIFO evicts the item that was added first, regardless of how often it’s accessed.</p><p>FIFO operates under the assumption that items added earliest are least likely to be needed as the cache fills up.</p><ul><li><p>: When an item is added to the cache, it is placed at the end of the queue.</p></li><li><p><strong>Cache Hit (Item Found in Cache): </strong>No changes are made to the order of items. FIFO does not prioritize recently accessed items.</p></li><li><p><strong>Cache Miss (Item Not Found in Cache):</strong></p><ul><li><p>If there is space in the cache, the new item is added to the end of the queue.</p></li><li><p>If the cache is full, the item at the front of the queue (the oldest item) is evicted to make space for the new item.</p></li></ul></li><li><p>: The oldest item, which has been in the cache the longest, is removed to make room for the new item.</p></li></ul><p>Let’s assume a cache with a capacity of 3:</p><ol><li><p>Add  → Cache: [B, C, D] (A is evicted because it was added first).</p></li><li><p>Access  → Cache: [B, C, D] (Order remains unchanged).</p></li><li><p>Add  → Cache: [C, D, E] (B is evicted because it was the oldest remaining item).</p></li></ol><ol><li><p>: FIFO is straightforward and requires minimal logic.</p></li><li><p>: No need to track additional metadata like access frequency or recency.</p></li><li><p>: Eviction follows a predictable order.</p></li></ol><ol><li><p>: Items still in frequent use can be evicted, reducing cache efficiency.</p></li><li><p><strong>Suboptimal for Many Use Cases</strong>: FIFO is rarely ideal in modern systems where recency and frequency matter.</p></li><li><p>: If old but frequently used items are evicted, the cache loses its utility.</p></li></ol><h2>4. Random Replacement (RR)</h2><p>RR cache eviction strategy is the simplest of all: when the cache is full, it evicts a random item to make space for a new one.</p><p>It doesn't track recency, frequency, or insertion order, making it a lightweight approach with minimal computational overhead.</p><p>This simplicity can sometimes be surprisingly effective, especially in systems with unpredictable or highly dynamic access patterns.</p><ul><li><p>: When an item is added to the cache and there is space, it is stored directly.</p></li><li><p> If the requested item exists in the cache, it is served, and no changes are made to the cache.</p></li><li><p> If the item is not in the cache and the cache is full, a random item is removed.</p></li><li><p>: The randomly selected item is removed, and the new item is added to the cache.</p></li></ul><p>Let’s assume a cache with a capacity of 3:</p><ol><li><p>Add  → Cache: [B, C, D] (A is randomly evicted).</p></li><li><p>Add  → Cache: [C, E, D] (B is randomly evicted).</p></li></ol><ol><li><p>: No need for metadata like access frequency or recency.</p></li><li><p>: Computational and memory requirements are minimal.</p></li><li><p><strong>Fair for Unpredictable Access Patterns</strong>: Avoids bias toward recency or frequency, which can be useful in some scenarios.</p></li></ol><ol><li><p>: A frequently used item might be evicted, reducing cache efficiency.</p></li><li><p><strong>Inefficient for Stable Access Patterns</strong>: Doesn’t adapt well when certain items are consistently accessed.</p></li><li><p><strong>High Risk of Poor Cache Hit Rates</strong>: Random eviction often leads to suboptimal retention of important items.</p></li></ol><h2>5. Most Recently Used (MRU)</h2><p> is the opposite of <strong>Least Recently Used (LRU)</strong>. In MRU, the item that was accessed most recently is the first to be evicted when the cache is full.</p><p>The idea behind MRU is that the most recently accessed item is likely to be a temporary need and won’t be accessed again soon, so evicting it frees up space for potentially more valuable data.</p><ul><li><p>: When a new item is added to the cache, it is marked as the most recently used.</p></li><li><p><strong>Cache Hit (Item Found in Cache):</strong> When an item is accessed, it is marked as the most recently used.</p></li><li><p><strong>Cache Miss (Item Not Found in Cache):</strong></p><ul><li><p>If the cache has available space, the new item is added directly.</p></li><li><p>If the cache is full, the most recently used item is evicted to make room for the new item.</p></li></ul></li><li><p>: The item that was accessed or added most recently is removed.</p></li></ul><p>Let’s assume a cache with a capacity of 3:</p><ol><li><p>Access  → Cache: [A, B, C] (C is marked as the most recently used).</p></li><li><p>Add  → Cache: [A, B, D] (C is evicted as it was the most recently used).</p></li><li><p>Access  → Cache: [A, B, D] (B becomes the most recently used).</p></li><li><p>Add  → Cache: [A, D, E] (B is evicted as it was the most recently used).</p></li></ol><ol><li><p><strong>Effective in Specific Scenarios</strong>: Retains older data, which might be more valuable in certain workloads.</p></li><li><p>: Requires minimal metadata.</p></li></ol><ol><li><p><strong>Suboptimal for Most Use Cases</strong>: MRU assumes recent data is less valuable, which is often untrue for many applications.</p></li><li><p><strong>Poor Hit Rate in Predictable Patterns</strong>: Fails in scenarios where recently accessed data is more likely to be reused.</p></li><li><p>: Limited applicability compared to other strategies like LRU or LFU.</p></li></ol><p> is a cache eviction strategy where each cached item is assigned a fixed lifespan. Once an item’s lifespan expires, it is automatically removed from the cache, regardless of access patterns or frequency.</p><p>This ensures that cached data remains fresh and prevents stale data from lingering in the cache indefinitely.</p><ul><li><p>: When an item is added to the cache, a TTL value (e.g., 10 seconds) is assigned to it. The expiration time is usually calculated as .</p></li><li><p><strong>Cache Access (Hit or Miss)</strong>: When an item is accessed, the cache checks its expiration time:</p><ul><li><p>If the item is expired, it is removed from the cache, and a cache miss is recorded.</p></li><li><p>If the item is valid, it is served as a cache hit.</p></li></ul></li><li><p>: Expired items are automatically removed either during periodic cleanup or on access.</p></li></ul><p>Let’s assume a cache with a TTL of 5 seconds:</p><ol><li><p>Add  with TTL = 5s → Cache: [A (expires in 5s)]</p></li><li><p>Add  with TTL = 10s → Cache: [A (5s), B (10s)]</p></li><li><p>After 6 seconds → Cache: [B (expires in 4s)] (A is evicted because its TTL expired).</p></li><li><p>Add  with TTL = 5s → Cache: [B (4s), C (5s)]</p></li></ol><p>If an item is accessed after its TTL expires, it results in a cache miss.</p><p>TTL is often implemented in caching systems like  or , where you can specify expiration times for each key.</p><ol><li><p>: Automatically removes stale data, ensuring only fresh items remain in the cache.</p></li><li><p>: TTL values are easy to assign during cache insertion.</p></li><li><p>: No need to track usage patterns or access frequency.</p></li><li><p>: Stale data is cleared out systematically, avoiding cache bloat.</p></li></ol><ol><li><p>: Items may be evicted prematurely even if they are frequently accessed.</p></li><li><p>: Items that haven’t expired but are still irrelevant occupy cache space.</p></li><li><p>: TTL doesn’t adapt to dynamic workloads or usage patterns.</p></li></ol><p>Two-Tiered Caching combines two layers of cache—usually a  (in-memory) and a  (distributed or shared). </p><p>The local cache serves as the first layer (hot cache), providing ultra-fast access to frequently used data, while the remote cache acts as the second layer (cold cache) for items not found in the local cache but still needed relatively quickly.</p><ol><li><p>:</p><ul><li><p>Resides on the same server as the application, often in memory (e.g., ,  in the application)..</p></li><li><p>Provides ultra-fast access to frequently accessed data, reducing latency and server load.</p></li><li><p>Examples: In-memory data structures like  or frameworks like .</p></li></ul></li><li><p><strong>Remote Cache (Second Tier)</strong>:</p><ul><li><p>Shared across multiple servers in the system. Slightly slower due to network overhead but offers larger storage and shared consistency.</p></li><li><p>Used to store data that is not in the local cache but is still frequently needed.</p></li><li><p>Examples: Distributed cache systems like  or .</p></li></ul></li></ol><ul><li><p>A client request checks the  first.</p></li><li><p>If the data is not found (cache miss), it queries the .</p></li><li><p>If the data is still not found (another cache miss), it retrieves the data from the primary data source (e.g., a database), stores it in both the local and remote caches, and returns it to the client.</p></li></ul><ol><li><p>: Local cache provides near-instantaneous response times for frequent requests.</p></li><li><p>: Remote cache adds scalability and allows data sharing across multiple servers.</p></li><li><p>: Two-tiered caching significantly minimizes calls to the backend database.</p></li><li><p>: If the local cache fails, the remote cache acts as a fallback.</p></li></ol><ol><li><p>: Managing two caches introduces more overhead, including synchronization and consistency issues.</p></li><li><p>: Inconsistent updates between tiers may lead to serving stale data.</p></li><li><p><strong>Increased Latency for Remote Cache Hits</strong>: Accessing the second-tier remote cache is slower than the local cache.</p></li></ol><p>If you found this article helpful and want to dive deeper, consider becoming a . You’ll get exclusive in-depth content every Thursday, along with  that will help you level up your knowledge.</p><p>Hope you enjoyed reading this article.</p><p>If you found it valuable, hit a like ❤️ and consider subscribing for more such content every week.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/how-i-mastered-data-structures-and-algorithms?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQ1NjU1MjUyLCJpYXQiOjE3MjE1MjE3MzEsImV4cCI6MTcyNDExMzczMSwiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.2cNY811YEugd5iH9XJQhakBzyahGqF7PcATBlFj5J2w&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p>I hope you have a lovely day!</p>","contentLength":12030,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fe981dbbb-6d70-41ad-b6df-43c5bcb20f76_582x390.png","enclosureMime":"","commentsUrl":null},{"title":"How to Choose the Right Database in a System Design Interview","url":"https://blog.algomaster.io/p/how-to-choose-the-right-database","date":1735219825,"author":"Ashish Pratap Singh","guid":652,"unread":true,"content":"<p>In , the quality of your design and its ability to scale depends heavily on the  you choose.</p><p>Choosing the wrong database can lead to high latency, data loss, or even system downtime.</p><p>In this article, we will cover the  that come up often in system design interviews and explore the best databases for each scenario.</p><p> provides deep session replays with every detail you need to find and fix a bug. From frontend screens to backend traces, metrics, and logs, all in one place. Debug faster and fix customer problems more easily, so you and your team can stay focused on building great software, not combing through APM data.</p><h2>1. Structured Data Requiring ACID Compliance</h2><p>Consider a major online marketplace like  or , which processes millions of transactions daily. </p><p>Each order involves multiple interdependent operations:</p><ul><li><p>Deducting payment from the customer.</p></li><li><p>Recording the sale for accounting and analytics.</p></li></ul><p>These operations need  and  transactions to avoid any data anomalies or transaction failures.</p><ul><li><p> ensures that if you fail to charge the customer’s credit card, you won’t ship the item.</p></li><li><p> guarantees that the product count never goes negative if the system runs out of stock.</p></li><li><p> prevents two customers from purchasing the last item at the exact same time.</p></li><li><p> ensures that once a payment is processed, you can’t lose that record if the server crashes the next second.</p></li></ul><h4>Recommended Database - </h4><p>When you need strict data consistency and a well-defined schema,  like  or  are often the best choice.</p><p>These databases are specifically designed to enforce relationships, constraints, and transactional guarantees.</p><p>This article is for paid subscribers. As a paid subscriber you get an exclusive deep dive every Thursday + .</p>","contentLength":1699,"flags":null,"enclosureUrl":"https://substackcdn.com/image/fetch/f_auto,q_auto:good,fl_progressive:steep/https%3A%2F%2Fsubstack-post-media.s3.amazonaws.com%2Fpublic%2Fimages%2Fc724d440-c5f7-46a9-9554-0835cc70085f_1064x623.png","enclosureMime":"","commentsUrl":null},{"title":"I solved 1583 LeetCode problems so you don't have to","url":"https://blog.algomaster.io/p/launching-algomasterio","date":1734843670,"author":"Ashish Pratap Singh","guid":651,"unread":true,"content":"<p>I’m excited to announce something I’ve been working on for the past 5 months!</p><p> is now live – a FREE platform to help you practice a curated list of LeetCode problems organized by patterns.</p><p>Having solved over , I’ve carefully selected the  and grouped them into  to help you prepare smarter, not harder.</p><p>These topics are ordered like a roadmap, allowing you to follow them step-by-step from top to bottom.</p><p>Here’s what makes AlgoMaster special:</p><ul><li><p>: Each problem comes with intuitive explanations, multiple approaches, and time complexity analysis – all available in a dedicated .</p></li><li><p>: Supports <strong>7 popular programming languages</strong> for interviews: Java, Python, C++, C#, JavaScript, TypeScript, and Go.</p></li><li><p><strong>Structured Learning Tracks</strong>: Choose a track based on your preparation time:</p><ul><li><p>: 3+ months</p></li><li><p>: 1-3 months (subset of AlgoMaster 300)</p></li><li><p>: Less than 1 month (subset of AlgoMaster 150).</p></li></ul></li><li><p>: Filter problems by pattern, difficulty, status, or keywords.</p></li><li><p>: Mark problems as completed or star them for revision.</p></li></ul><p>This is just version 0. I plan to add more features in the future and would love your feedback!</p><p>I’ll be publishing high-quality tutorials on these topics/patterns and solution to these LeetCode problems on my . Subscribe to stay updated!</p><p>💡  I’ve worked hard to minimize the infrastructure cost to keep this completely free for the community. I hope you find it valuable!</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/launching-algomasterio?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>Feel free to share it with others.</p></div></div><p>I hope you have a lovely day!</p>","contentLength":1421,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/d3099f07-04fb-48a0-a503-814700d6cde8_1368x953.png","enclosureMime":"","commentsUrl":null}]}