{"id":"2bP4pJr4wVimh6yine63HqNeafoyheTFz1gqCrQ4h7Z","title":"AlgoMaster Newsletter","displayTitle":"Dev - Algomaster","url":"https://blog.algomaster.io/feed","feedLink":"https://blog.algomaster.io/","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"I Created the most Comprehensive LLD Interview Resource","url":"https://blog.algomaster.io/p/launching-premium-lld-resource","date":1755777720,"author":"Ashish Pratap Singh","guid":713,"unread":true,"content":"<p>It‚Äôs one of the most comprehensive and high quality resource you can find online with <strong>support for 5 programming languages</strong> ‚Äî Java, Python, C++, C#, and TypeScript.</p><p>Many chapters are . To unlock full access, you would need to become a  to the newsletter.</p><ul><li><p> and </p></li><li><p> and other important </p></li><li><p> (with real-world examples)</p></li><li><p><strong>40+ LLD interview problems</strong> (with more added over time)</p></li><li><p>, with UML class diagrams and design patterns explained in context.</p></li><li><p>Support for <strong>Java, Python, C++,  C#, and TypeScript</strong></p></li><li><p>Built-in  and  where you can edit, run and see the solution output directly on the site (supports Java, Python, C++,  and C#)</p></li><li><p> to test your understanding.</p></li></ul><p>I‚Äôve poured a lot of thought and effort into making this course as useful and practical as possible. I truly hope you‚Äôll find it valuable in your interview prep journey.</p><p>I will keep making improvements and enhancements to this resource over time.</p><p>You may already know my , which is one of the most popular resources to learn LLD. This course takes it to the next level, offering a far better reading experience, focused specifically on interview prep. </p><p>I have also updated the solutions in the Github repository with more design patterns and class diagrams.</p><p>Starting , subscription pricing will increase:</p><ul></ul><p>Subscribe now to lock in the current price.</p><p>All <strong>existing paid subscribers</strong> will continue at their current rate.</p><h4>üíé New: Lifetime Access Plan</h4><p>You can now get  to all current and future AlgoMaster premium content for a .</p><p>For any questions related to content or subscription, please reply to this email or reach out at </p>","contentLength":1549,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/1bdf8340-7a0f-42e0-8609-c5174fb17828_2048x1426.jpeg","enclosureMime":"","commentsUrl":null},{"title":"What is GeoHashing?","url":"https://blog.algomaster.io/p/geohashing","date":1753874488,"author":"Ashish Pratap Singh","guid":712,"unread":true,"content":"<p>Imagine you‚Äôre building a system like , , or a nearby restaurant finder.</p><p>You need to store and query millions or even billions of location points to find <strong>what's \"close\" to a specific point? </strong>And you want to do it .</p><p>But querying latitude and longitude ranges can get messy and slow, especially at scale.</p><p>That‚Äôs where  comes in.</p><p>In this article, we‚Äôll explore:</p><ul><li><p>Limitations and trade-offs</p></li><li><p>Practical System Design Example</p></li></ul><p> are critical but time-consuming.  acts as your AI co-pilot, providing instant Code review comments and potential impacts of every pull request.</p><p>Beyond just flagging issues, CodeRabbit provides <strong>one-click fix suggestions</strong> and lets you define <strong>custom code quality rules</strong> using AST Grep patterns, catching subtle issues that traditional static analysis tools might miss.</p><p> has so far reviewed more than , installed on , and used by <strong>70 thousand Open-source projects</strong>. CodeRabbit is free for all open-source repo's.</p><p>Imagine you have a database table of restaurants, with columns for  and . A user at (<strong>lat: 34.0523, lon: -118.2438</strong>) wants to find all restaurants within a 1km radius.</p><p>How would you write this query?</p><p>A naive approach might be a \"bounding box\" query:</p><p>This works, but it has major performance problems at scale:</p><p>Most databases use , which are fantastic for one-dimensional data. But they struggle with 2D queries. The database can use an index on latitude, but then it has to do a full scan of all matching rows to filter by longitude (or vice-versa). </p><p>A  on (latitude, longitude) helps, but it still doesn't truly understand spatial locality.</p><p>We need a way to represent 2D proximity in a 1D format that a standard database index can efficiently search. That‚Äôs what  is about.</p><p> is a method of encoding geographic coordinates (latitude, longitude) into a short alphanumeric string.</p><p>It was invented by  as a way to enable efficient spatial indexing and proximity search in databases and distributed systems.</p><p> The coordinates for downtown  can be encoded as the geohash: .</p><p>This hash looks like just a random string of characters but it has two magical properties:</p><p>The more characters two GeoHashes share at the beginning (i.e., the longer their common prefix), the <strong>closer those two locations are geographically</strong>.</p><p>This means: will usually have .  will have <strong>completely different prefixes</strong>.</p><p>GeoHashes are : each additional character in the hash zooms in to a more precise region.</p><ul><li><p> and  share the first  ‚Üí they belong to  but are .</p></li><li><p> and  share only the first  ‚Üí they are , likely hundreds of kilometers.</p></li><li><p> ‚Üí starts with a <strong>completely different prefix</strong>. It represents a  region, possibly on another continent.</p></li></ul><h3>2. One-Dimensional and Indexable</h3><p>GeoHashes convert 2D coordinates (latitude, longitude) into a . This string can be stored in a  or  field in a relational or NoSQL database, and indexed efficiently using a  or .</p><ul><li><p>Fast lookups of nearby places</p></li><li><p>Easy sharding based on location</p></li><li><p>Efficient sorting and filtering using standard indexes</p></li></ul><p>GeoHashing may look like magic at first glance, but it‚Äôs built on a simple and elegant idea: convert a 2D geographic point into a 1D string through binary encoding and interleaving.</p><p>Let‚Äôs walk through the process of encoding a  pair into a GeoHash ‚Äî step by step.</p><h2>Step 1: Define the Initial Ranges</h2><p>We begin by defining the global bounds of latitude and longitude:</p><ul><li><p> ranges from </p></li><li><p> ranges from </p></li></ul><p>These represent the full span of the Earth‚Äôs surface in both dimensions.</p><p>The goal is to gradually  this range by encoding whether a coordinate lies in the  of the current interval, similar to a binary search.</p><h2>Step 2: Convert to Binary by Interleaving</h2><p>Now, we start converting the latitude and longitude into binary.</p><p>We start with the full range of values:</p><ul></ul><p>We then <strong>repeatedly divide each range in half</strong> and record a binary digit based on which half the coordinate falls into:</p><ul><li><p>If the value is in the , we append a .</p></li><li><p>If the value is in the , we append a .</p></li></ul><p>This is a lot like binary search ‚Äî but instead of just narrowing down to a value, we record each decision as a bit in the final output.</p><h3>Interleaving Latitude and Longitude Bits</h3><p>We don‚Äôt encode latitude and longitude separately. We  their bits:</p><ul><li><p>4th bit ‚Üí latitude... and so on.</p></li></ul><p>This interleaving produces a  that represents the position in a Morton curve (Z-order curve), which helps preserve spatial locality.</p><p>Let‚Äôs walk through the first few steps for the point: <strong>(37.7749¬∞ N, -122.4194¬∞ W)</strong></p><h4>Step 1: Longitude ‚Üí -122.4194¬∞</h4><p>Initial range: </p><ol><li><p>Midpoint =  ‚Üí -122.4194 &lt; 0 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí -122.4194 &lt; -90 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí -122.4194 &gt; -135 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí -122.4194 &lt; -112.5 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí -122.4194 &gt; -123.75 ‚Üí  ‚Üí New range: </p></li></ol><p>So first 5 longitude bits = </p><h4>Step 2: Latitude ‚Üí 37.7749¬∞</h4><p>Initial range: </p><ol><li><p>Midpoint =  ‚Üí 37.7749 &gt; 0 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí 37.7749 &lt; 45 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí 37.7749 &gt; 22.5 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí 37.7749 &gt; 33.75 ‚Üí  ‚Üí New range: </p></li><li><p>Midpoint =  ‚Üí 37.7749 &lt; 39.375 ‚Üí  ‚Üí New range: </p></li></ol><p>First 5 latitude bits = </p><h4>Step 3: Interleave the Bits</h4><p>Interleaving the two binary sequences:</p><pre><code>Longitude bits:  0 0 1 0 1  \nLatitude bits:   1 0 1 1 0  \n\nInterleaved:     0 1 0 0 1 1 1 0 1 0</code></pre><p>Resulting binary string (10 bits): </p><h4>Step 4: Continue Until You Reach Desired Precision</h4><p>You typically continue this process until you have:</p><ul><li><p> ‚Üí 6-character GeoHash</p></li><li><p> ‚Üí 7-character GeoHash</p></li><li><p> ‚Üí very high precision</p></li></ul><h2>Step 3: Convert Binary to Base32 String</h2><p>Once we‚Äôve built a long binary string by interleaving latitude and longitude bits, we need to <strong>compress it into something shorter and human-readable.</strong></p><p>This is where  comes in.</p><ul><li><p>Take the interleaved binary string and split it into .</p></li><li><p>Convert each 5-bit chunk into a Base32 character.</p></li></ul><h4>Base32 Alphabet Used in GeoHashing:</h4><pre><code>0123456789bcdefghjkmnpqrstuvwxyz</code></pre><blockquote><p>Note: The letters , , , and  are intentionally omitted to avoid confusion with similar-looking digits or letters (, , etc.).</p></blockquote><p>This step compresses a potentially long binary string into a , usually between , depending on the desired precision.</p><p>Let‚Äôs say your interleaved binary string is:</p><p>Break it into 5-bit groups and convert each chunk into a Base32 character:</p><ul></ul><p>Each additional character in the GeoHash increases the precision of the location.</p><p>You can  of your spatial encoding just by adjusting the number.</p><p>GeoHashing offers benefits that are highly valuable in location-based services:</p><h4>Efficient Proximity Search</h4><p>Instead of range queries on lat/lon, you can:</p><ul><li><p>Use GeoHash prefix matching</p></li><li><p>Search within a bounding box by comparing string prefixes</p></li></ul><p>Databases like PostgreSQL, Cassandra, and MongoDB can:</p><ul><li><p>Index strings faster than floating-point pairs</p></li><li><p>Use trie or B-tree-based lookups for prefix search</p></li></ul><p>GeoHashes are great for sharding data in distributed systems:</p><ul><li><p>Assign prefixes to different servers/partitions</p></li><li><p>Keep nearby data close together</p></li></ul><p>GeoHashing is widely used in location-based apps and geospatial databases. </p><p>Here are some real-world examples where GeoHashing shines:</p><h4>Ridesharing Platforms (e.g., Uber, Lyft)</h4><p>GeoHashes can be used to group drivers and riders into  based on their current location.</p><ul><li><p>When a rider requests a trip, the system calculates their GeoHash (e.g., to 6 or 7 characters).</p></li><li><p>It then quickly finds drivers in the <strong>same or neighboring GeoHash cells</strong>, drastically reducing the search space.</p></li><li><p>This enables <strong>real-time proximity matching</strong> without scanning all active drivers.</p></li></ul><h4>Food Delivery Services (e.g., Swiggy, Zomato)</h4><p>When a user opens the app to browse nearby restaurants:</p><ul><li><p>Their coordinates are converted into a GeoHash.</p></li><li><p>The backend queries all restaurants whose stored GeoHashes  or its neighbors.</p></li><li><p>This allows the system to serve relevant results , even with millions of entries in the database.</p></li></ul><h4>Geospatial Databases (e.g., Elasticsearch, MongoDB)</h4><p>GeoHashing is often used under the hood in spatial indexing strategies.</p><ul><li><p> supports  aggregations to efficiently bucket documents by location.</p></li><li><p> can store GeoHashes for fast, prefix-based querying on 2D location fields.</p></li></ul><p>GeoHashing is a powerful tool for spatial indexing but like any abstraction, it comes with trade-offs.</p><ul><li><p> It maps a 2D problem to a 1D problem, allowing for extremely fast prefix searches on standard database indexes.</p></li><li><p> You can easily \"zoom in\" or \"zoom out\" by simply adjusting the length of the geohash string you use for querying. This is great for map UIs.</p></li><li><p> It scales horizontally very well. The workload is easily distributable.</p></li><li><p> It works with any database that supports string indexing (PostgreSQL, MySQL, etc.).</p></li></ul><ul><li><p> You must query neighboring cells to avoid missing nearby points that fall across a boundary. This adds a little complexity to the query logic.</p></li><li><p> Geohash cells are rectangular, and their shape distorts and becomes less square-like as you move away from the equator. This means a geohash doesn't represent a uniform circular area.</p></li><li><p> Two points can be in the same geohash cell but at opposite corners, making them farther apart than a point in a neighboring cell. This is why the final, precise distance calculation is necessary.</p></li><li><p> On its own, geohashing is a proximity search, not a true \"k-Nearest Neighbors\" search. You must combine it with a post-filtering distance calculation to get accurate k-NN results.</p></li></ul><p>Now let‚Äôs look at how to <strong>practically implement GeoHashing</strong> to build a location-based feature like showing nearby restaurants.</p><p>Let's say we have a  table in our database.</p><p>To enable fast geospatial queries:</p><ul><li><p>We add a new column called .</p></li><li><p>Every time a restaurant is created or its location is updated, we:</p><ul><li><p>Calculate its GeoHash (e.g., with ).</p></li><li><p>Store it in the  column.</p></li></ul></li></ul><p>This prepares the data for <strong>efficient prefix-based lookups</strong>.</p><p>Since GeoHash is stored as a string, we can index it with a  which enables fast, lexicographical prefix filtering.</p><h3>2. Querying for Nearby Items</h3><p>Let's say a user is at a location that maps to GeoHash: .</p><p>To find nearby restaurants within, say, a , the most basic query would be:</p><p>This works well in many cases, but there's a .</p><p>What if the user is standing  of the  cell, and the closest restaurant is just  in a neighboring cell like ?</p><p>The query above would  that restaurant even though it may be just 20 meters away.</p><h3>3. The Solution: Include Neighboring Cells</h3><p>Each GeoHash defines a bounding box. If we also consider the 8 immediate neighbors around that box, we cover <strong>the full surrounding area</strong>, eliminating blind spots at cell edges.</p><ol><li><p> Capture user's current latitude and longitude.</p></li><li><p> Convert that location to a GeoHash with your chosen precision (e.g., ).</p></li><li><p> Use a GeoHash utility/library to get the 8 surrounding GeoHashes.</p></li><li><p> Query the database for items whose geohash starts with  of these 9 prefixes (the user's cell + 8 neighbors).</p></li></ol><p>The GeoHash-based prefix query is , but still slightly approximate.</p><p>So once we get the <strong>candidate set of restaurants</strong>, we do a second, more precise filtering step:</p><ul><li><p>Use the  or  to compute the  between the user‚Äôs location and each candidate.</p></li><li><p> any restaurants that fall  the desired radius (e.g., beyond 200m).</p></li><li><p> the remaining results by distance to return the nearest ones first.</p></li></ul><blockquote><p>The expensive Haversine computation is done on  of rows, not , which keeps the system performant.</p></blockquote><p>While  is a fast, lightweight, and scalable approach to spatial indexing, it's not the only option. </p><p>Several other data structures are commonly used in geospatial systems, each with their own strengths and trade-offs:</p><p>These are <strong>tree-based spatial partitioning structures</strong> that recursively divide the space into smaller regions.</p><ul><li><p> divide 2D space into four quadrants at each level.</p></li><li><p> divide k-dimensional space by alternating splitting axes (e.g., latitude and longitude).</p></li></ul><p>GeoHashing can be conceptually seen as a simplified, linearized representation of a , following a space-filling curve like a Z-order (Morton) curve.</p><p> are commonly used in spatial databases such as  (PostgreSQL extension), , and .</p><ul><li><p>They group nearby objects into .</p></li><li><p>Each node in the tree contains the <strong>minimum bounding rectangle (MBR)</strong> that encloses its children.</p></li><li><p>This structure supports efficient queries for containment, intersection, and nearest neighbors.</p></li></ul><p>If you found it valuable, hit a like ‚ù§Ô∏è and consider subscribing for more such content.</p><p>If you have any questions or suggestions, leave a comment.</p><div data-attrs=\"{&quot;url&quot;:&quot;https://blog.algomaster.io/p/scalability?utm_source=substack&amp;utm_medium=email&amp;utm_content=share&amp;action=share&amp;token=eyJ1c2VyX2lkIjo4MzYwMjc0MywicG9zdF9pZCI6MTQwMDc4MDk0LCJpYXQiOjE3Mzc1MzgxODMsImV4cCI6MTc0MDEzMDE4MywiaXNzIjoicHViLTIyMDIyNjgiLCJzdWIiOiJwb3N0LXJlYWN0aW9uIn0.xroFXQDDEPvo2FWnnt-G2Ji9MzYIDtJ68NRQX6sT8x8&quot;,&quot;text&quot;:&quot;Share&quot;}\" data-component-name=\"CaptionedButtonToDOM\"><div><p>This post is public so feel free to share it.</p></div></div><p> If you‚Äôre enjoying this newsletter and want to get even more value, consider becoming a .</p><p>I hope you have a lovely day!</p>","contentLength":12278,"flags":null,"enclosureUrl":"https://substack-post-media.s3.amazonaws.com/public/images/d645062c-ae73-46ea-836e-1c60a4849471_2048x1365.jpeg","enclosureMime":"","commentsUrl":null}],"tags":["dev"]}