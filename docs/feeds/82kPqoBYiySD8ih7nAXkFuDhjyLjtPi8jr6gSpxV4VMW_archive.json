{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":2,"items":[{"title":"More predictable benchmarking with testing.B.Loop","url":"https://go.dev/blog/testing-b-loop","date":1743552000,"author":"Junyang Shao","guid":158,"unread":true,"content":"<p>Go developers who have written benchmarks using the\n<a href=\"https://pkg.go.dev/testing\" rel=\"noreferrer\" target=\"_blank\"></a> package might have encountered some of\nits various pitfalls. Go 1.24 introduces a new way to write benchmarks that’s just\nas easy to use, but at the same time far more robust:\n<a href=\"https://pkg.go.dev/testing#B.Loop\" rel=\"noreferrer\" target=\"_blank\"></a>.</p><p>Traditionally, Go benchmarks are written using a loop from 0 to :</p><pre><code>func Benchmark(b *testing.B) {\n  for range b.N {\n    ... code to measure ...\n  }\n}\n</code></pre><p>Using  instead is a trivial change:</p><pre><code>func Benchmark(b *testing.B) {\n  for b.Loop() {\n    ... code to measure ...\n  }\n}\n</code></pre><p> has many benefits:</p><ul><li>It prevents unwanted compiler optimizations within the benchmark loop.</li><li>It automatically excludes setup and cleanup code from benchmark timing.</li><li>Code can’t accidentally depend on the total number of iterations or the current\niteration.</li></ul><p>These were all easy mistakes to make with -style benchmarks that would\nsilently result in bogus benchmark results. As an added bonus, -style\nbenchmarks even complete in less time!</p><p>Let’s explore the advantages of  and how to effectively utilize it.</p><h2>Old benchmark loop problems</h2><p>Before Go 1.24, while the basic structure of a benchmark was simple, more sophisticated\nbenchmarks required more care:</p><pre><code>func Benchmark(b *testing.B) {\n  ... setup ...\n  b.ResetTimer() // if setup may be expensive\n  for range b.N {\n    ... code to measure ...\n    ... use sinks or accumulation to prevent dead-code elimination ...\n  }\n  b.StopTimer() // if cleanup or reporting may be expensive\n  ... cleanup ...\n  ... report ...\n}\n</code></pre><p>If setup or cleanup are non-trivial, the developer needs to surround the benchmark loop\nwith  and/or  calls. These are easy to forget, and even if the\ndeveloper remembers they may be necessary, it can be difficult to judge whether setup or\ncleanup are “expensive enough” to require them.</p><p>Without these, the  package can only time the entire benchmark function. If a\nbenchmark function omits them, the setup and cleanup code will be included in the overall\ntime measurement, silently skewing the final benchmark result.</p><p>There is another, more subtle pitfall that requires deeper understanding:\n(<a href=\"https://eli.thegreenplace.net/2023/common-pitfalls-in-go-benchmarking/\" rel=\"noreferrer\" target=\"_blank\">Example source</a>)</p><pre><code>func isCond(b byte) bool {\n  if b%3 == 1 &amp;&amp; b%7 == 2 &amp;&amp; b%17 == 11 &amp;&amp; b%31 == 9 {\n    return true\n  }\n  return false\n}\n\nfunc BenchmarkIsCondWrong(b *testing.B) {\n  for range b.N {\n    isCond(201)\n  }\n}\n</code></pre><p>In this example, the user might observe  executing in sub-nanosecond\ntime. CPUs are fast, but not that fast! This seemingly anomalous result stems\nfrom the fact that  is inlined, and since its result is never used, the\ncompiler eliminates it as dead code. As a result, this benchmark doesn’t measure \nat all; it measures how long it takes to do nothing. In this case, the sub-nanosecond\nresult is a clear red flag, but in more complex benchmarks, partial dead-code elimination\ncan lead to results that look reasonable but still aren’t measuring what was intended.</p><p>Unlike a -style benchmark,  is able to track when it is first called\nin a benchmark when the final iteration ends. The  at the loop’s start\nand  at its end are integrated into , eliminating the need\nto manually manage the benchmark timer for setup and cleanup code.</p><p>Furthermore, the Go compiler now detects loops where the condition is just a call to\n and prevents dead code elimination within the loop. In Go 1.24, this is\nimplemented by disallowing inlining into the body of such a loop, but we plan to\n<a href=\"https://go.dev/issue/73137\">improve</a> this in the future.</p><p>Another nice feature of  is its one-shot ramp-up approach. With a -style\nbenchmark, the testing package must call the benchmark function several times with different\nvalues of , ramping up until the measured time reached a threshold. In contrast, \ncan simply run the benchmark loop until it reaches the time threshold, and only needs to call\nthe benchmark function once. Internally,  still uses a ramp-up process to amortize\nmeasurement overhead, but this is hidden from the caller and can be more efficient.</p><p>Certain constraints of the -style loop still apply to the -style\nloop. It remains the user’s responsibility to manage the timer within the benchmark loop,\nwhen necessary:\n(<a href=\"https://eli.thegreenplace.net/2023/common-pitfalls-in-go-benchmarking/\" rel=\"noreferrer\" target=\"_blank\">Example source</a>)</p><pre><code>func BenchmarkSortInts(b *testing.B) {\n  ints := make([]int, N)\n  for b.Loop() {\n    b.StopTimer()\n    fillRandomInts(ints)\n    b.StartTimer()\n    slices.Sort(ints)\n  }\n}\n</code></pre><p>In this example, to benchmark the in-place sorting performance of ,a\nrandomly initialized array is required for each iteration. The user must still\nmanually manage the timer in such cases.</p><p>Furthermore, there still needs to be exactly one such loop in the benchmark function body\n(a -style loop cannot coexist with a -style loop), and every iteration of the\nloop should do the same thing.</p><p>The  method is now the preferred way to write benchmarks:</p><pre><code>func Benchmark(b *testing.B) {\n  ... setup ...\n  for b.Loop() {\n    // optional timer control for in-loop setup/cleanup\n    ... code to measure ...\n  }\n  ... cleanup ...\n}\n</code></pre><p> offers faster, more accurate, and\nmore intuitive benchmarking.</p><p>A huge thank you to everyone in the community who provided feedback on the proposal\nissue and reported bugs as this feature was released! I’m also grateful to Eli\nBendersky for his helpful blog summaries. And finally a big thank you to Austin Clements,\nCherry Mui and Michael Pratt for their review, thoughtful work on the design options and\ndocumentation improvements. Thank you all for your contributions!</p>","contentLength":5321,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Goodbye core types - Hello Go as we know and love it!","url":"https://go.dev/blog/coretypes","date":1742947200,"author":"Robert Griesemer","guid":157,"unread":true,"content":"<p>\n      Robert Griesemer\n      26 March 2025\n      </p><p>The Go 1.18 release introduced generics and with that a number of new features, including type parameters, type constraints, and new concepts such as type sets.\nIt also introduced the notion of a .\nWhile the former provide concrete new functionality, a core type is an abstract construct that was introduced\nfor expediency and to simplify dealing with generic operands (operands whose types are type parameters).\nIn the Go compiler, code that in the past relied on the <a href=\"https://go.dev/ref/spec/#Underlying_types\">underlying type</a> of an operand,\nnow instead had to call a function computing the operand’s core type.\nIn the language spec, in many places we just needed to replace “underlying type” with “core type”.\nWhat’s not to like?</p><p>Quite a few things, as it turns out!\nTo understand how we got here, it’s useful to briefly revisit how type parameters and type constraints work.</p><h2>Type parameters and type constraints</h2><p>A type parameter is a placeholder for a future type argument;\nit acts like a  whose value is known at compile time,\nsimilar to how a named constant stands for a number, string, or bool whose value is known at compile time.\nLike ordinary variables, type parameters have a type.\nThat type is described by their  which determines\nwhat operations are permitted on operands whose type is the respective type parameter.</p><p>Any concrete type that instantiates a type parameter must satisfy the type parameter’s constraint.\nThis ensures that an operand whose type is a type parameter possesses all of the respective type constraint’s properties,\nno matter what concrete type is used to instantiate the type parameter.</p><p>In Go, type constraints are described through a mixture of method and type requirements which together\ndefine a : this is the set of all the types that satisfy all the requirements. Go uses a\ngeneralized form of interfaces for this purpose. An interface enumerates a set of methods and types,\nand the type set described by such an interface consists of all the types that implement those methods\nand that are included in the enumerated types.</p><p>For instance, the type set described by the interface</p><pre><code>type Constraint interface {\n    ~[]byte | ~string\n    Hash() uint64\n}\n</code></pre><p>consists of all the types whose representation is  or  and whose method set includes the  method.</p><p>With this we can now write down the rules that govern operations on generic operands.\nFor instance, the <a href=\"https://go.dev/ref/spec#Index_expressions\">rules for index expressions</a> state that (among other things)\nfor an operand  of type parameter type :</p><blockquote><p>The index expression  must be valid for values of all types in ’s type set.\nThe element types of all types in ’s type set must be identical.\n(In this context, the element type of a string type is .)</p></blockquote><p>These rules make it possible to index the generic variable  below (<a href=\"https://go.dev/play/p/M1LYKm3x3IB\">playground</a>):</p><pre><code>func at[bytestring Constraint](s bytestring, i int) byte {\n    return s[i]\n}\n</code></pre><p>The indexing operation  is permitted because the type of  is , and the type constraint (type set) of\n contains  and  types for which indexing with  is valid.</p><p>This type set-based approach is very flexible and in line with the intentions of the\n<a href=\"https://go.googlesource.com/proposal/+/refs/heads/master/design/43651-type-parameters.md\" rel=\"noreferrer\" target=\"_blank\">original generics proposal</a>:\nan operation involving operands of generic type should be valid if it is valid for any type permitted by the respective\ntype constraint.\nTo simplify matters with respect to the implementation, knowing that we would be able to relax rules later,\nthis approach was  chosen universally.\nInstead, for instance, for <a href=\"https://go.dev/ref/spec#Send_statements\">Send statements</a>, the spec states that</p><blockquote><p>The channel expression’s  must be a channel, the channel direction must permit send operations,\nand the type of the value to be sent must be assignable to the channel’s element type.</p></blockquote><p>These rules are based on the notion of a core type which is defined roughly as follows:</p><ul><li>If a type is not a type parameter, its core type is just its <a href=\"https://go.dev/ref/spec#Underlying_types\">underlying type</a>.</li><li>If the type is a type parameter, the core type is the single underlying type of all the types in the type parameter’s type set.\nIf the type set has  underlying types, the core type doesn’t exist.</li></ul><p>For instance,  has a core type (), but the  interface above does not have a core type.\nTo make things more complicated, when it comes to channel operations and certain built-in calls (, ) the above definition\nof core types is too restrictive.\nThe actual rules have adjustments that allow for differing channel directions and type sets containing both  and  types.</p><p>There are various problems with this approach:</p><ul><li><p>Because the definition of core type must lead to sound type rules for different language features,\nit is overly restrictive for specific operations.\nFor instance, the Go 1.24 rules for <a href=\"https://go.dev/ref/spec#Slice_expressions\">slice expressions</a> do rely on core types,\nand as a consequence slicing an operand of type  constrained by  is not permitted, even though\nit could be valid.</p></li><li><p>When trying to understand a specific language feature, one may have to learn the intricacies of\ncore types even when considering non-generic code.\nAgain, for slice expressions, the language spec talks about the core type of the sliced operand,\nrather than just stating that the operand must be an array, slice, or string.\nThe latter is more direct, simpler, and clearer, and doesn’t require knowing another concept that may be\nirrelevant in the concrete case.</p></li><li><p>Because the notion of core types exists, the rules for index expressions, and  and  (and others),\nwhich all eschew core types, appear as exceptions in the language rather than the norm.\nIn turn, core types cause proposals such as <a href=\"https://go.dev/issue/48522\">issue #48522</a> which would permit a selector\n to access a field  shared by all elements of ’s type set, to appear to add more exceptions to the\nlanguage.\nWithout core types, that feature becomes a natural and useful consequence of the ordinary rules for non-generic\nfield access.</p></li></ul><p>For the upcoming Go 1.25 release (August 2025) we decided to remove the notion of core types from the\nlanguage spec in favor of explicit (and equivalent!) prose where needed.\nThis has multiple benefits:</p><ul><li>The Go spec presents fewer concepts, making it easier to learn the language.</li><li>The behavior of non-generic code can be understood without reference to generics concepts.</li><li>The individualized approach (specific rules for specific operations) opens the door for more flexible rules.\nWe already mentioned <a href=\"https://go.dev/issue/48522\">issue #48522</a>, but there are also ideas for more powerful\nslice operations, and <a href=\"https://go.dev/issue/69153\">improved type inference</a>.</li></ul><p>The respective <a href=\"https://go.dev/issue/70128\">proposal issue #70128</a> was recently approved and the relevant changes\nare already implemented.\nConcretely this means that a lot of prose in the language spec was reverted to its original,\npre-generics form, and new paragraphs were added where needed to explain the rules as they\npertain to generic operands. Importantly, no behavior was changed.\nThe entire section on core types was removed.\nThe compiler’s error messages were updated to not mention “core type” anymore, and in many\ncases error messages are now more specific by pointing out exactly which type in a type set\nis causing a problem.</p><p>Here is a sample of the changes made. For the built-in function ,\nstarting with Go 1.18 the spec began as follows:</p><blockquote><p>For an argument  with core type that is a channel,\nthe built-in function  records that no more values will be sent on the channel.</p></blockquote><p>A reader who simply wanted to know how  works, had to first learn about core types.\nStarting with Go 1.25, this section will again begin the same way it began before Go 1.18:</p><blockquote><p>For a channel , the built-in function \nrecords that no more values will be sent on the channel.</p></blockquote><p>This is shorter and easier to understand.\nOnly when the reader is dealing with a generic operand will they have to contemplate\nthe newly added paragraph:</p><blockquote><p>If the type of the argument to  is a type parameter\nall types in its type set must be channels with the same element type.\nIt is an error if any of those channels is a receive-only channel.</p></blockquote><p>We made similar changes to each place that mentioned core types.\nIn summary, although this spec update does not affect any current Go program, it opens the\ndoor to future language improvements while making the language as it is today easier to\nlearn and its spec simpler.</p>","contentLength":8094,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}