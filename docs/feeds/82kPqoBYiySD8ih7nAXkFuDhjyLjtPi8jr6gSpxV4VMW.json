{"id":"82kPqoBYiySD8ih7nAXkFuDhjyLjtPi8jr6gSpxV4VMW","title":"The Go Blog","displayTitle":"Dev - Golang Blog","url":"http://blog.golang.org/feed.atom","feedLink":"http://blog.golang.org/feed.atom","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":1,"items":[{"title":"Go’s Sweet 16","url":"https://go.dev/blog/16years","date":1763078400,"author":"Austin Clements, for the Go team","guid":100,"unread":true,"content":"<p>This past Monday, November 10th, we celebrated the 16th anniversary of Go’s\n<a href=\"https://opensource.googleblog.com/2009/11/hey-ho-lets-go.html\" rel=\"noreferrer\" target=\"_blank\">open source\nrelease</a>!</p><p>We released <a href=\"https://go.dev/blog/go1.24\">Go 1.24 in February</a> and <a href=\"https://go.dev/blog/go1.25\">Go 1.25 in\nAugust</a>, following our now well-established and dependable release\ncadence. Continuing our mission to build the most productive language platform\nfor building production systems, these releases included new APIs for building\nrobust and reliable software, significant advances in Go’s track record for\nbuilding secure software, and some serious under-the-hood improvements.\nMeanwhile, no one can ignore the seismic shifts in our industry brought by\ngenerative AI. The Go team is applying its thoughtful and uncompromising mindset\nto the problems and opportunities of this dynamic space, working to bring Go’s\nproduction-ready approach to building robust AI integrations, products, agents,\nand infrastructure.</p><p>First released in Go 1.24 as an experiment and then graduated in Go 1.25, the\nnew <a href=\"https://pkg.go.dev/testing/synctest\" rel=\"noreferrer\" target=\"_blank\"></a> package\nsignificantly simplifies writing tests for <a href=\"https://go.dev/blog/testing-time\">concurrent, asynchronous\ncode</a>. Such code is particularly common in network services,\nand is traditionally very hard to test well. The  package works by\nvirtualizing time itself. It takes tests that used to be slow, flaky, or both,\nand makes them easy to rewrite into reliable and nearly instantaneous tests,\noften with just a couple extra lines of code. It’s also a great example of Go’s\nintegrated approach to software development: behind an almost trivial API, the\n package hides a deep integration with the Go runtime and other parts\nof the standard library.</p><p>This isn’t the only boost the  package got over the past year. The new\n<a href=\"https://pkg.go.dev/testing#B.Loop\" rel=\"noreferrer\" target=\"_blank\"></a> API is both easier to use\nthan the original  API and addresses many of the traditional—and\noften invisible!—<a href=\"https://go.dev/blog/testing-b-loop\">pitfalls</a> of writing Go benchmarks. The\n package also has new APIs that <a href=\"https://pkg.go.dev/testing#T.Context\" rel=\"noreferrer\" target=\"_blank\">make it easy to\ncleanup</a> in tests that use\n<a href=\"https://pkg.go.dev/context#Context\" rel=\"noreferrer\" target=\"_blank\"></a>, and that <a href=\"https://pkg.go.dev/testing#T.Output\" rel=\"noreferrer\" target=\"_blank\">make it\neasy</a> to write to the test’s log.</p><p>Go and containerization grew up together and work great with each other. Go 1.25\nlaunched <a href=\"https://go.dev/blog/container-aware-gomaxprocs\">container-aware scheduling</a>, making\nthis pairing even stronger. Without developers having to lift a finger, this\ntransparently adjusts the parallelism of Go workloads running in containers,\npreventing CPU throttling that can impact tail latency and improving Go’s\nout-of-the-box production-readiness.</p><p>Go 1.25’s new <a href=\"https://go.dev/blog/flight-recorder\">flight recorder</a> builds on our already\npowerful execution tracer, enabling deep insights into the dynamic behavior of\nproduction systems. While the execution tracer generally collected \ninformation to be practical in long-running production services, the flight\nrecorder is like a little time machine, allowing a service to snapshot recent\nevents in great detail  something has gone wrong.</p><h2>Secure software development</h2><p>Go continues to strengthen its commitment to secure software development, making\nsignificant strides in its native cryptography packages and evolving its\nstandard library for enhanced safety.</p><p>Go ships with a full suite of native cryptography packages in the standard\nlibrary, which reached two major milestones over the past year. A security\naudit conducted by independent security firm <a href=\"https://www.trailofbits.com/\" rel=\"noreferrer\" target=\"_blank\">Trail of\nBits</a> yielded <a href=\"https://go.dev/blog/tob-crypto-audit\">excellent\nresults</a>, with only a single low-severity finding.\nFurthermore, through a collaborative effort between the Go Security Team and\n<a href=\"https://geomys.org/\" rel=\"noreferrer\" target=\"_blank\">Geomys</a>, these packages achieved CAVP certification,\npaving the way for <a href=\"https://go.dev/blog/fips140\">full FIPS 140-3 certification</a>. This is a\nvital development for Go users in certain regulated environments. FIPS 140\ncompliance, previously a source of friction due to the need for unsupported\nsolutions, will now be seamlessly integrated, addressing concerns related to\nsafety, developer experience, functionality, release velocity, and compliance.</p><p>The Go standard library has continued to evolve to be  and\n. For example, the <a href=\"https://pkg.go.dev/os#Root\" rel=\"noreferrer\" target=\"_blank\"></a>\nAPI—added in Go 1.24—enables <a href=\"https://go.dev/blog/osroot\">traversal-resistant file system\naccess</a>, effectively combating a class of vulnerabilities where an\nattacker could manipulate programs into accessing files intended to be\ninaccessible. Such vulnerabilities are notoriously challenging to address\nwithout underlying platform and operating system support, and the new\n<a href=\"https://pkg.go.dev/os#Root\" rel=\"noreferrer\" target=\"_blank\"></a> API offers a straightforward,\nconsistent, and portable solution.</p><h2>Under-the-hood improvements</h2><p>In addition to user-visible changes, Go has made significant improvements under\nthe hood over the past year.</p><p>For Go 1.24, we completely <a href=\"https://go.dev/blog/swisstable\">redesigned the \nimplementation</a>, building on the latest and greatest ideas in\nhash table design. This change is completely transparent, and brings significant\nimprovements to  performance, lower tail latency of  operations, and\nin some cases even significant memory wins.</p><p>Go 1.25 includes an experimental and significant advancement in Go’s garbage\ncollector called <a href=\"https://go.dev/blog/greenteagc\">Green Tea</a>. Green Tea reduces garbage\ncollection overhead in many applications by at least 10% and sometimes as much\nas 40%. It uses a novel algorithm designed for the capabilities and constraints\nof today’s hardware and opens up a new design space that we’re eagerly\nexploring. For example, in the forthcoming Go 1.26 release, Green Tea will\nachieve an additional 10% reduction in garbage collector overhead on hardware\nthat supports AVX-512 vector instructions—something that would have been nigh\nimpossible to take advantage of in the old algorithm. Green Tea will be enabled\nby default in Go 1.26; users need only upgrade their Go version to benefit.</p><p>Go is about far more than the language and standard library. It’s a software\ndevelopment platform, and over the past year, we’ve also made four regular\nreleases of the <a href=\"https://go.dev/gopls\">gopls language server</a>, and have formed partnerships to\nsupport emerging new frameworks for agentic applications.</p><p>Gopls provides Go support to VS Code and other LSP-powered editors and IDEs.\nEvery release sees a litany of features and improvements to the experience of\nreading and writing Go code (see the <a href=\"https://go.dev/gopls/release/v0.17.0\">v0.17.0</a>,\n<a href=\"https://go.dev/gopls/release/v0.18.0\">v0.18.0</a>, <a href=\"https://go.dev/gopls/release/v0.19.0\">v0.19.0</a>, and\n<a href=\"https://go.dev/gopls/release/v0.20.0\">v0.20.0</a> release notes for full details, or our new\n<a href=\"https://go.dev/gopls/features\">gopls feature documentation</a>!). Some highlights include many\nnew and enhanced analyzers to help developers write more idiomatic and robust Go\ncode; refactoring support for variable extraction, variable inlining, and JSON\nstruct tags; and an <a href=\"https://go.dev/gopls/features/mcp\">experimental built-in server</a> for the\nModel Context Protocol (MCP) that exposes a subset of gopls’ functionality to AI\nassistants in the form of MCP tools.</p><p>With gopls v0.18.0, we began exploring <em>automatic code modernizers</em>. As Go\nevolves, every release brings new capabilities and new idioms; new and better\nways to do things that Go programmers have been finding other ways to do. Go\nstands by its <a href=\"https://go.dev/doc/go1compat\">compatibility promise</a>—the old way will continue\nto work in perpetuity—but nevertheless this creates a bifurcation between old\nidioms and new idioms. Modernizers are static analysis tools that recognize old\nidioms and suggest faster, more readable, more secure, more \nreplacements, and do so with push-button reliability. What  did for\n<a href=\"https://go.dev/blog/gofmt\">stylistic consistency</a>, we hope modernizers can do for idiomatic\nconsistency. We’ve integrated modernizers as IDE suggestions, where they can\nhelp developers not only maintain more consistent coding standards, but where we\nbelieve they will help developers discover new features and keep up with the\nstate of the art. We believe modernizers can also help AI coding assistants keep\nup with the state of the art and combat their proclivity to reinforce outdated\nknowledge of the Go language, APIs, and idioms. The upcoming Go 1.26 release\nwill include a total overhaul of the long-dormant  command to make it\napply the full suite of modernizers in bulk, a return to its <a href=\"https://go.dev/blog/introducing-gofix\">pre-Go 1.0\nroots</a>.</p><p>At the end of September, in collaboration with\n<a href=\"https://www.anthropic.com/\" rel=\"noreferrer\" target=\"_blank\">Anthropic</a> and the Go community, we released\n<a href=\"https://github.com/modelcontextprotocol/go-sdk/releases/tag/v1.0.0\" rel=\"noreferrer\" target=\"_blank\">v1.0.0</a> of\nthe <a href=\"https://github.com/modelcontextprotocol/go-sdk\" rel=\"noreferrer\" target=\"_blank\">official Go SDK</a> for the\n<a href=\"https://modelcontextprotocol.io/\" rel=\"noreferrer\" target=\"_blank\">Model Context Protocol (MCP)</a>. This SDK\nsupports both MCP clients and MCP servers, and underpins the new MCP\nfunctionality in gopls. Contributing this work in open source helps empower\nother areas of the growing open source agentic ecosystem built around Go, such\nas the recently released <a href=\"https://github.com/google/adk-go\" rel=\"noreferrer\" target=\"_blank\">Agent Development Kit (ADK) for\nGo</a> from <a href=\"https://www.google.com/\" rel=\"noreferrer\" target=\"_blank\">Google</a>.\nADK Go builds on the Go MCP SDK to provide an idiomatic framework for building\nmodular multi-agent applications and systems. The Go MCP SDK and ADK Go\ndemonstrate how Go’s unique strengths in concurrency, performance, and\nreliability differentiate Go for production AI development and we are expecting\nmore AI workloads to be written in Go in the coming years.</p><p>Go has an exciting year ahead of it.</p><p>We’re working on advancing developer productivity through the brand new \ncommand, deeper support for AI coding assistants, and ongoing improvements to\ngopls and VS Code Go. General availability of the Green Tea garbage collector,\nnative support for Single Instruction Multiple Data (SIMD) hardware features,\nand runtime and standard library support for writing code that scales even\nbetter to massive multicore hardware will continue to align Go with modern\nhardware and improve production efficiency. We’re focusing on Go’s “production\nstack” libraries and diagnostics, including a massive (and long in the making)\n<a href=\"https://go.dev/issue/71497\">upgrade to </a>, driven by Joe Tsai and people across\nthe Go community; <a href=\"https://go.dev/design/74609-goroutine-leak-detection-gc\">leaked goroutine\nprofiling</a>, contributed by\n<a href=\"https://www.uber.com/us/en/about/\" rel=\"noreferrer\" target=\"_blank\">Uber’s</a> Programming Systems team; and many\nother improvements to , , and other foundational packages.\nWe’re working to provide well-lit paths for building with Go and AI, evolving\nthe language platform with care for the evolving needs of today’s developers,\nand building tools and capabilities that help both human developers and AI\nassistants and systems alike.</p><p>On this 16th anniversary of Go’s open source release, we’re also looking to the\nfuture of the Go open source project itself. From its <a href=\"https://www.youtube.com/watch?v=wwoWei-GAPo\" rel=\"noreferrer\" target=\"_blank\">humble\nbeginnings</a>, Go has formed a\nthriving contributor community. To continue to best meet the needs of our\never-expanding user base, especially in a time of upheaval in the software\nindustry, we’re working on ways to better scale Go’s development\nprocesses—without losing sight of Go’s fundamental principles—and more deeply\ninvolve our wonderful contributor community.</p><p>Go would not be where it is today without our incredible user and contributor\ncommunities. We wish you all the best in the coming year!</p>","contentLength":10210,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null}],"tags":["dev","go"]}