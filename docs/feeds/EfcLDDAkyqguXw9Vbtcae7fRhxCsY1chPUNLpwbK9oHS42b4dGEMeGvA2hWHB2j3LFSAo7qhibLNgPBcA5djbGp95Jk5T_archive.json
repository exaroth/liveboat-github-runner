{"id":"EfcLDDAkyqguXw9Vbtcae7fRhxCsY1chPUNLpwbK9oHS42b4dGEMeGvA2hWHB2j3LFSAo7qhibLNgPBcA5djbGp95Jk5T","title":"top scoring links : programming","displayTitle":"Reddit - Programming","url":"https://www.reddit.com/r/programming/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/programming/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"AI Coding Is Based on a Faulty Premise","url":"https://articles.pragdave.me/p/ai-coding-is-based-on-a-faulty-premise?r=2rvraz","date":1737758338,"author":"/u/ThatArrowsmith","guid":584,"unread":true,"content":"<p>I am glad to  be living in a time where AI is becoming mainstream. When I write code, I often use AI to complete code and to lookup the way libraries and tools can be used.</p><p>At the same time, I am increasingly distressed by the race to replace human developers, particularly the more junior ones, with AI assistants.</p><p>There is good reason to believe that this is a regressive trend, even in the short-to-medium term. That reason is linked to the history of software development, the software crisis of 1990s, and the movement towards a more agile style of development.</p><p><a href=\"https://en.wikipedia.org/wiki/NATO_Software_Engineering_Conferences\" rel=\"\"> two conferences</a></p><p>During the 1970s, academics (and some larger companies) tried to refine what this phrase meant. </p><p>There was clearly a large chasm between what a customer wanted and the delivery of software to satisfy them. So software engineering came to mean a process of narrowing the gap by dividing it into lots of phases, where the conceptual gap between each phase was smaller (and therefore more tractable) than a single large gap.</p><p><a href=\"https://www.praxisframework.org/files/royce1970.pdf\" rel=\"\">Managing the Development of Large Software Systems</a></p><p>It shows the way many people felt that software should be developed; a set of steps, where the output of each is a refinement of its input. Each step would produce an increasing amount of specification, until finally we reached coding, testing, and delivery.</p><p>This diagram defined a generation of software development practices. Unfortunately, its advocates didn’t bother to read the paper past this nice simple picture. Royce points out that each step is likely to find errors in the preceding step, and so the diagram should look like this:</p><p>Then he points out that the reality is likely to be more anarchic. Errors found towards the end of the process may well have been caused by problems many steps back.</p><p>His solution to this was regrettable: increase the level of detail of the specifications passed between steps. By a lot. Fortunately, because no one bothered to read the whole paper, we were spared that additional process insult.</p><p><a href=\"https://www.researchgate.net/publication/263849222_The_Chaos_Report\" rel=\"\">Chaos Report</a></p><p>In retrospect, the reason was pretty damn obvious:</p><p><a href=\"https://en.wikipedia.org/wiki/Telephone_game\" rel=\"\">telephone</a></p><p>Teams in the 1990s knew intuitively that this kind of snowballing cascade of small errors was unsustainable, so they subverted the project development structures imposed on them. They chose to ignore things that were patently incorrect. They talked to each other, and adjusted what they did in order to produce bits of code that would actually work together. And they got better and better at padding estimates.</p><p>The Manifesto for Agile Software Development, created in 2001, explicitly acknowledged that specifications at all levels were suspect, and that the only true measure of a project is the value it produces. It insisted that people should be in the loop, applying their intuition and skill to take small steps, and then using feedback to asses how successful they’d been. Each step was like a mini-waterfall, tacitly running from requirements to tests in a matter on minutes, often publishing code to the end users many times a day.</p><p>(I’m resisting the temptation here to rant about the current state of “agile.” That’ll be another article.)</p><p>But that’s not what I’m seeing. Companies are jumping on AI as a way of removing those messy (and expensive) humans from the process of developing software.</p><p>Right now (early 2025), we’re starting see a move from AI as coding assistant to AI as program writer. Nonprogrammers are working with Claude and ChatGPT to create simple programs. Companies are experimenting more and more with content produced largely by AI. </p><p>And the problem with that is the same as the problem with the poorly-applied waterfall approach: people don’t know what they want. They’ll ask AI for a solution to their perceived need, and then run what they are given, often without understanding what it does. This applies equally to end users and (amazingly) to developers.</p><p>So the AI produces code based on at best a partial and at worst an inaccurate description, and then that code becomes part of a larger system, integrating with other chunks of imaginary code.</p><p>That’s OK, people say. We’ll have the AI write tests, too.</p><p>Don’t get me wrong. AI is a world-changing tool.</p><p>But good software developers have already changed the world beyond recognition. And they’ve done that by taking uncertain, inaccurate ideas and using their experience, intuition, and communications skills to hone them into something that changes people’s lives.</p><p>Remove these people from the equation, and will be back in the 1990s, in a world full of poor software and unmet needs.</p><p>Or am I just being a Luddite? Let’s discuss below.</p>","contentLength":4605,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1i984yn/ai_coding_is_based_on_a_faulty_premise/"},{"title":"AI is Creating a Generation of Illiterate Programmers","url":"https://nmn.gl/blog/ai-illiterate-programmers","date":1737736437,"author":"/u/namanyayg","guid":586,"unread":true,"content":"<p>A couple of days ago, Cursor went down during the ChatGPT outage.</p><p>I stared at my terminal facing those red error messages that I hate to see. An AWS error glared back at me. I didn’t want to figure it out without AI’s help.</p><p>After 12 years of coding, I’d somehow become worse at my own craft. And this isn’t hyperbole—this is the new reality for software developers.</p><p>First, I stopped reading documentation. Why bother when AI could explain things instantly?</p><p>Then, my debugging skills took the hit. Stack traces now feel unapproachable without AI. I don’t even read error messages anymore, I just copy and paste them.</p><p>I’ve become a human clipboard, a mere intermediary between my code and an LLM.</p><p>Previously, every error message used to teach me something. Now? The solution appears magically, and I learn nothing. The dopamine hit of instant answers has replaced the satisfaction of genuine understanding.</p><p>Deep comprehension is the next thing that was affected. Remember spending hours understanding why a solution works? Now, I simply implement AI suggestions. If they don’t work, I <a href=\"https://nmn.gl/blog/ai-senior-developer\">improve the context</a>, and just ask the AI again. It’s a cycle of increasing dependency.</p><p>Then come the emotional changes. Previously, it was a part of the  of programming to solve new problems. Now, I get frustrated if AI doesn’t give me a solution in 5 minutes.</p><p>The scariest part? I’m building an <a href=\"https://nmn.gl/blog/giga\">AI-powered development tool</a>, but I can’t shake the feeling I’m contributing to the very problem that’s eroding our collective skills.</p><p>I’m not suggesting anything radical like going AI-free completely—that’s unrealistic. Instead, I’m starting with “No-AI Days.” One day a week where:</p><ul><li>Read every error message completely</li><li>Use actual debuggers again</li><li>Read source code instead of asking AI</li></ul><p>I won’t lie, it sucks. I feel slower, dumber, and more frustrated.</p><p>But I can also see the difference. I feel a stronger connection with my code and a sense of ownership, which had slowly disappeared with AI. Plus, I learn a lot more.</p><p>We’re not becoming 10x developers with AI.</p><p>We’re becoming 10x  on AI. </p><p>Every time we let AI solve a problem we could’ve solved ourselves, we’re trading long-term understanding for short-term productivity. We’re optimizing for today’s commit at the cost of tomorrow’s ability.</p><p>I’m not suggesting we abandon AI tools—that ship has sailed. But we need rules of engagement. Here’s some ideas that I have:</p><ul><li>No AI for problems that you haven’t tried to understand first</li><li>Read and understand all AI-suggested solutions</li><li>Regular periods of coding without AI assistance</li><li>Focus on learning patterns, not just fixing immediate issues</li></ul><p>I won’t lie, I don’t think I’ll be able to follow these rules all the time. But it’s a start, and I strongly believe anyone who’s new to programming should  follow all of these rules.</p><p>Right now, somewhere, a new programmer is learning to code. They’ll never know the satisfaction of solving problems truly on their own. They’ll never experience the deep understanding that comes from wrestling with a bug for hours.</p><p>We’re creating a generation of developers who can ask AI the right questions but can’t understand the answers. Every time AI goes down, they’re exposed as increasingly helpless. As of now, <a href=\"https://nmn.gl/blog/ai-midlevel-engineer\">AI isn’t capable enough</a> to replace programmers fully, but this will only get worse as it improves. The real question isn’t whether AI will replace programmers. It’s whether we’re replacing ourselves.</p><p>Try coding without AI for just one day. The results might surprise you.</p>","contentLength":3557,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1i8zi9v/ai_is_creating_a_generation_of_illiterate/"},{"title":"Vim in Zed: Improving the experience (The 2025 Roadmap)","url":"https://zed.dev/blog/vim-2025","date":1737732080,"author":"/u/marcospb19","guid":581,"unread":true,"content":"<p>Zed’s Vim mode continues to improve! My newest favorite feature is the  operator, which was the \"last holdout\" for common Vim operators:</p><p>But we’ve also been making progress on fleshing out the command palette with things like  and  to execute a command on matching (or non-matching) lines.</p><p>The broader community has also been working on pulling in top Vim plugins. We have versions of vim-surround, sneak, and as of recently, tree-sitter text objects:</p><p>All in all, if you use Vim today, the chances are that most of what you want to do on a daily basis in the editor will work in Zed exactly as it does in Vim.</p><p>There are three areas of focus I’d like to push on in 2025 for Vim in Zed:</p><ol><li>Building out the non-editor user experience</li><li>Raising the bar on matching Vim edge-case-for-edge-case.</li><li>Creating a new, better, multi-cursor Vim integration</li></ol><p>Although Vim seems to have “no UI” this is a sleight of hand. After  you’re in ex mode, which is full of features that make it work well. In particular, I want to bring to Zed:</p><ul><li>Filename completion in the command palette , or  for example</li><li>Command history, so you can fix a  without typing it out again</li><li> to run a sequence of keystrokes (and a few other missing commands)</li></ul><p>There are also other Vim UI’s to bring into Zed:</p><ul><li> to see your registers.</li></ul><p>Interestingly both registers and marks are more powerful in Vim than Zed today because they persist state to disk across a restart. We need to build that too.</p><p>Finally Zed has significant surface area that Vim does not have, and I'd like them to feel Vim-native:</p><ul><li>Keyboard shortcuts for collaboration features like ‘follow next person’, and a keyboard driven way to join and leave calls, mute/share etc.</li><li>Better shortcuts for the AI edit predictor, and handling in normal mode. Similarly for the inline assistant, which also tends to bug out in Vim mode today.</li><li>Bringing more netrw like bindings to the project panel</li><li>Tighter integration with the upcoming Git panel</li></ul><p>People who switch to Zed from Vim are attracted by the “just works by default”\naspect of Zed: language servers just work, and the advanced features (AI,\ncollaboration). But, nothing is more frustrating than a Vim mode that doesn’t\nwork   like Vim. We get a lot of VS Code Vim extension refugees, and the number\none complaint is that “it just didn’t feel right”.</p><p>Zed is already much closer to Vim. We have extensive \"side-by-side\" testing\nwhere we run headless Neovim to ensure our keyboard shortcuts do exactly the\nsame thing. That said, there's always more to do, both to add the remaining\nminor motions / come to mind, and fix edge cases in things like .</p><p>Zed has multi-cursor, and Zed’s Vim mode works “as you’d expect” with multiple\ncursors for the most part. The problem I'd like to solve is two-fold:</p><ul><li>Tidying up the bindings so there's a coherent feature set around Vim with multi-cursor.</li><li>In particular making sure you can easily rotate into multi-cursor as though it were another mode.</li><li>Adding to Zed support for moving just one of your selections in case you make a mistake selecting.</li></ul><p>There are a few editors that have prior art here, particularly Kakoune and\nHelix; but also Vim plugins that I want to get inspiration from.</p><p>If you'd like to help work on any of this, you can <a href=\"https://cal.com/conradirwin/pairing\">book time to pair with\nme</a>. Also feel free to peruse the list in\nthe <a href=\"https://zed.dev/channel/vim-393/notes\">Vim channel notes</a> and pick up\nthings that sound interesting to you. While I am happy to accept PRs out of the\nblue, I always prefer talking things through first.</p><p>If there's something I'm missing, or not prioritizing, please add it to the\n<a href=\"https://github.com/zed-industries/zed\">issue tracker</a>, or upvote things that\nare already there.</p>","contentLength":3595,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1i8xsw3/vim_in_zed_improving_the_experience_the_2025/"},{"title":"How I open-sourced my secret access tokens from GitHub, Slack and NPM and who of them cares about it | Vue & Node admin panel framework","url":"https://adminforth.dev/blog/how-i-opensourced-my-secret-tokens/","date":1737729595,"author":"/u/vanbrosh","guid":585,"unread":true,"content":"<p>Our framework has a CI pipeline that runs , publishes the package to NPM (), and creates a new release on GitHub. It also sends a notification about the release to a Slack webhook for our team.</p><p>Secrets for these services were stored in our CI’s built-in Vault (we are running a self-hosted Woodpecker CI).</p><p>Recently, while moving plugins to separate repositories, I decided to try <a href=\"https://infisical.com/\" target=\"_blank\" rel=\"noopener noreferrer\">Infisical</a> for centralized secrets management instead of the internal CI Vault. Infisical provides a self-hosted open-source solution, has a well-organized UI, and offers better access control than our CI Vault. It was important to me that I could reuse secrets across different repositories without copying them every time I created a new plugin.</p><p>Pretty dumb method to export secrets to the  file, but it was late evening, and I didn’t want to spend much time on it at the start.</p><p>I made the first push, and everything worked fine on the first attempt. I was happy.</p><p>Then I started adding the same code to the first plugin, and the plugin build failed with a very unexpected error.</p><p>It said that my NPM token was invalid. I was surprised and started printing the environment variables to see what was wrong (printing environment variables to the build log is a pretty bad practice and is the last thing you want to do, but I knew it was an internal CI, and the project was private).</p><p>I saw that my NPM token was still in the environment variables and was the same.</p><p>I went back to the first repository and retried the build. It failed with the same error.</p><p>I went to NPM and found out that the token had disappeared entirely from the list. I was shocked and recreated it.</p><p>On the next build, I discovered that the Slack webhook was also not working. However, GitHub releases were created without issues in both repositories.</p><p>Then I noticed an email push notification from Slack titled \"Notification about invalidated webhook URLs.\"</p><p>This was the moment I realized that  had simply taken my  file and published it to NPM.</p><p>Shortly after, I noticed a recent email from NPM titled \"Granular access token deleted.\"</p><p>The next thing I did was revoke all tokens, including the GitHub token, which still worked, and unpublish all packages from NPM (though they might still be cloned by some caches/aggregators/archivers).</p><p>GitHub was not able to recognize that the token had been leaked to an NPM package and revoke it. Although they do a pretty good job when you push other vendors’ secrets to a GitHub repository, it seems they don’t check NPM sources.</p><p>NPM detected that the NPM token was published to their registry and revoked it. However, it was hard to understand why—it was simply deleted. They sent an email, but it did not explain why the token was deleted or specify the source of the leak. Showing an error in the tokens list on the NPM website would have been the best option.</p><p>I was surprised, but Slack did a great job. They monitor NPM (I don’t think they monitor the whole NPM registry; there’s probably some interesting technology behind it). They detected that the NPM token was published to the registry and invalidated it. They sent an email with a clear explanation of why it was invalidated and what steps to take next.</p><p>We can talk a lot about bad programming practices, but the main takeaway is that we are human. And humans still make mistakes.It makes a lot of sense to monitor for such human errors.</p><p>In my case, NPM and Slack saved me from a potential security breach. Without their intervention, I would have learned about the issue only when someone used my tokens for malicious purposes.GitHub didn’t detect or revoke the token, and many other services wouldn’t have done so either.</p><p>Here are some common recommendations I learned from this experience:</p><ul><li>Try to limit token access as much as possible to only the required granularity. Even if something is leaked, it won’t cause much harm. Don’t grant access to all resources/packages/repos unless it’s necessary.</li><li>Check what you publish, especially when making changes to your build pipeline. I missed the fact that the  file was being published.</li><li>Appreciate services that monitor for leaks and respond to them. They can save you from potential security breaches.</li></ul>","contentLength":4199,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1i8wurp/how_i_opensourced_my_secret_access_tokens_from/"},{"title":"Two features Typescript will never include","url":"https://www.danielfullstack.com/article/two-features-typescript-will-never-include","date":1737722335,"author":"/u/craciun_07","guid":583,"unread":true,"content":"<p>TypeScript is an amazing tool, but no language is perfect. Some features never make it to TypeScript no matter how useful they might be.</p><p>Today we explore two of them:  and . We’ll look at why they’re not supported and show you some clever workarounds.</p><p>Typescript is closely aligned with <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"https://en.wikipedia.org/wiki/Set_theory\"></a> from mathematics. We know this because Typescript supports set operations with types, such as Union, Intersection, Concatenation…</p><p>But there is no support for Type subtraction, or in other words .</p><p>For example, you can’t say something like . But there is a cool trick you can use as a workaround.</p><p>This trick works best in generic function arguments. Take a look at this handler function that accepts all strings except :</p><p>It’s not perfect, and you can see this workaround only works in specific contexts, but given that there is rarely a need for type subtraction, it does make sense why Typescript wouldn’t support it natively.</p><p>TypeScript uses a structural type system. That means it only cares about the structure of data rather than their names. This is why  don’t exist in TypeScript.</p><p>But let's say you want to distinguish between absolute and relative file path strings. Treating them as interchangeable could lead to bugs later down the line.</p><p>Conveniently, you can simulate nominal types by creating “branded types”:</p><p>This is a neat trick that works for all use cases. I would love to hear situations where you would use it in the comments.</p><p>TypeScript will never officially support negated types or nominal types, but their workarounds still promise good results.</p><p>Do you know other features Typescript is avoiding to add? Please share them in the comments below.</p><blockquote><em>Need a cofounder for your SaaS project? Check out <a target=\"_blank\" rel=\"noopener noreferrer\" href=\"http://www.devmarket.pro\"></a> today!</em></blockquote>","contentLength":1715,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1i8ufr8/two_features_typescript_will_never_include/"},{"title":"Two different URLs in one QR code","url":"https://dualqrcode.com/","date":1737707354,"author":"/u/fixedBaq2jd85","guid":582,"unread":true,"content":"<!DOCTYPE html>","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1i8qw17/two_different_urls_in_one_qr_code/"}]}