{"id":"EfcLDDAkyqguXw9Vbtcae7fRhxCsY1chPUNLpwbK9oHS42b4dGEMeGvA2hWHB2j3LFSAo7qhibLNgPBcA5djbGp95Jk5T","title":"top scoring links : programming","displayTitle":"Reddit - Programming","url":"https://www.reddit.com/r/programming/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/programming/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Single Responsibility Principle (SRP) In React: Write Focused Components","url":"https://thetshaped.dev/p/single-responsibility-principle-srp-in-react-write-focused-components","date":1739120242,"author":"/u/pepincho","guid":443,"unread":true,"content":"<p><a href=\"https://thetshaped.dev/p/solid-principles-writing-robust-and\" rel=\"\">SOLID Principles</a></p><p><a href=\"https://thetshaped.dev/p/solid-principles-writing-robust-and\" rel=\"\">SOLID</a></p><p><a href=\"https://thetshaped.dev/p/solid-principles-writing-robust-and\" rel=\"\">SOLID</a></p><p>By definition, the principle states:</p><blockquote><p><strong>‚ÄùA class should only have one reason to change.‚Äù</strong></p></blockquote><p>In other words, a class, function, or module should have a single responsibility.</p><p>Let‚Äôs first see how things look like when we violate the SRP in React and write not so good enough components.</p><p>The problem with this component is that it:</p><ol><li><p>handles data fetching for the products</p></li><li><p>manages the loading and error states </p></li><li><p>handles the form for adding a new product</p></li><li><p>takes care of the display and layout of the products</p></li></ol><p><strong>ProductsDashboard Component</strong><strong>harder to understand, maintain, debug, test, and reuse</strong></p><p><em>Be the Senior who delivers the standard for writing robust React Components.</em></p><p><strong>separate focused components</strong></p><ul><li><p><strong>Separate data handling from User Interface</strong></p></li><li><p><strong>Write small and focused components</strong></p></li><li><p><strong>Prefer composing a set of smaller components</strong></p></li><li><p><strong>Organize your components in terms of layers</strong></p></li></ul><p>That's all for today. I hope this was helpful. ‚úåÔ∏è</p><div><h2>How I can help you further?</h2><p><em><strong>Become the Senior React Engineer at your company! üöÄ</strong></em></p></div><p>I share daily practical tips to level up your skills and become a better engineer.</p><p><em>Thank you for being a great supporter, reader, and for your help in growing to 18.3K+ subscribers this week üôè</em></p><p><em>You can also hit the like ‚ù§Ô∏è button at the bottom to help support me or share this with a friend. It helps me a lot! üôè</em></p>","contentLength":1318,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ilj86o/single_responsibility_principle_srp_in_react/"},{"title":"From Engineer to Principal Solutions Architect at AWS with Prasad Rao","url":"https://newsletter.eng-leadership.com/p/from-engineer-to-principal-solutions","date":1739118558,"author":"/u/gregorojstersek","guid":442,"unread":true,"content":"<p>Finding skilled developers is hard ‚Üí even for seasoned engineering leaders. Traditional hiring cycles can take months while critical features sit in the backlog.</p><p>Need to scale your team quickly or find specialized talent that's hard to source locally? They match you with developers from Europe and Latin America who integrate seamlessly into your workflow ‚Üí without the long hiring cycles or commitment of long-term contracts.</p><p>They don't just check r√©sum√©s, but put developers through a rigorous multi-step vetting process that assesses technical skills, problem-solving abilities, and communication.</p><p>Let‚Äôs get back to this week‚Äôs thought!</p><p>When we talk about career paths, all of our journeys are unique. There is no one single best path that works for all of us. It‚Äôs important that you find out what path you wish to pursue and work towards it.</p><p><a href=\"https://www.linkedin.com/in/kprasadrao/\" rel=\"\">Prasad Rao</a></p><p>Prasad has chosen the Architecture path and I can see why very clearly. He grew as an engineer early on but later moved to the role of a Pre-sales Engineer, which helped him with speaking in both business and technical terms, creating presentations, understanding clients and managing multiple stakeholders.</p><p>That particular set of skills is often hard to get from engineering roles alone, but it plays a crucial part in an Architect positions.</p><p>Now, let‚Äôs get into his journey, Prasad, over to you!</p><p>When engineers think about career growth, they often focus on two traditional paths: either advancing as an Individual Contributor (climbing from Senior to Staff Engineer and beyond) or transitioning into Engineering Management. </p><p>However, there are other powerful career paths that are sometimes overlooked.</p><p>In this article, I am sharing my journey of transitioning from an engineer to a Solutions Architect at AWS, offering insights into this alternative career trajectory.</p><p>My career began as a .NET Developer, where I gradually progressed to become a Senior Developer and then a Tech Lead. The year I graduated, I interviewed for a couple of Big Tech companies but never got beyond the initial coding rounds. I thought I wasn't made for Big Tech and made peace with it. </p><p>After a few initial job switches, I settled into a consulting company and started climbing the ladder. Unlike many others who choose the management track, I wanted to grow as an Individual Contributor (IC). However, many companies do not have a clearly defined IC growth path. The natural progression is to become a manager. I was looking for alternative opportunities.</p><p>Even though I was working for a consulting company, I was in a unique position as I was working on building a product for a financial services company. When the product was ready, they needed someone in the field to demo it to potential clients. I took the role, and that opened a whole new world of possibilities for me.</p><p>That's when I was first introduced to pre-sales activities. Instead of being an engineer on the product team, I would be part of the field team as a pre-sales engineer.</p><blockquote><p>Pro Tip: Don‚Äôt shy away from exploring lateral roles when an opportunity arises. Career growth is never linear.</p></blockquote><p>Frankly, before I started, I didn't know if such a role existed. As with any new role, there were pros and cons of being a pre-sales engineer. The pros were that I would be working more closely with customers onsite and traveling the world. The cons were that I would work on activities sometimes frowned upon by engineers - stakeholder management, customer interactions, gathering requirements, creating sales presentations, etc.</p><p>Frankly, it was stepping out of my comfort zone, but it helped me develop skills that I never knew would be so important in my career growth. </p><p>After a couple of years in this role working with multiple customers, I understood the importance of understanding customers' requirements and working backward to achieve them.</p><p>Being an engineer, I had mostly focused on completing the tasks assigned to me. I never focused on understanding the real business reasons behind the tasks. Other skills I learned in this role:</p><ul><li><p>Speaking both business and technical languages</p></li><li><p>Creating stellar technical presentations and product demonstrations</p></li><li><p>Understanding prospective clients' business needs and designing customized solutions</p></li><li><p>Collaborating with multiple stakeholders like sales representatives, client executives, business analysts, and product teams</p></li></ul><blockquote><p>Pro Tip: Spend time with your business stakeholders to understand the WHY behind the tasks you do on a daily basis.</p></blockquote><p>After a few years in the role of Pre-sales engineer, I got an opportunity to consult as a Senior Engineer/Tech Lead for a financial services customer on a digital transformation project. With improved business acumen and communication skills, I quickly became the go-to person for the customer. It was a development project, but my focus shifted to understanding the bigger picture.</p><p>As developers, we design and architect components, so we're already doing architecture work without realizing it. A key to transitioning to an architect role is viewing these individual components and systems through a wider lens.</p><p>To grow as an architect, you need to learn system design, distributed systems, and integration patterns. You also need to develop the mindset of considering scalability, performance, security, cost, and other factors. But those are technical skills that are relatively easy to pick up. The important thing to develop as an architect is perspective - while developers often focus deeply on specific components, architects maintain a holistic view of the entire system. For that, understanding the business requirements is essential.</p><p><a href=\"https://www.youtube.com/watch?v=yflW4BG7Ves\" rel=\"\">Thinking Like an Architect</a></p><p>In architecture, there is nothing defined as right or wrong - it's always a trade-off. There is a reason architects start their answers with \"It depends.\" It depends on the requirements. It depends on what you would like to achieve. It depends on what constraints you're working with. </p><p>Every architectural decision involves balancing multiple factors: scalability versus simplicity, performance versus maintainability, time-to-market versus perfect technical design, or cost versus capability.</p><p>Lastly, to grow as an architect, it is also important to develop a broad understanding of multiple technologies. This enables you to make informed decisions about choosing the right tools for specific problems.</p><blockquote><p>Pro Tip: Shift your focus to look at the big picture and have a holistic view. Architects learn to navigate the ambiguity in requirements and constraints.</p></blockquote><p>With 10+ years in the industry, I had gained enough experience in different roles - developer, tech lead, pre-sales engineer, and architect. I was looking for a new job when one of my seniors suggested I try for AWS.</p><p>I was reluctant, thinking that I would have to go through coding exercises. I was pretty hands-on, but solving LeetCode was not my cup of tea. To my surprise, I learned that coding rounds happen only for SDE roles. So if you are a naive person like me thinking that jobs at Big Tech are out of reach because of coding rounds, then please explore other roles.</p><p>I browsed through multiple roles to find one that matched my profile - 'Solutions Architect, Microsoft Developer Tools on AWS'. The job role mentioned experience required with .NET and Microsoft workload stack. In the role, I had to help customers migrate and modernize their Microsoft workloads on AWS.</p><p>My decade-long career was all in Microsoft technologies, but I had zero experience with AWS. I was pretty candid about that in my call with the recruiter, and still my profile got shortlisted. The entire interview process (8 rounds) was completely based on my experience and my learning ability with new technologies. No coding round whatsoever. </p><p>I'm not saying the interviews were easy or that I did not have to prepare. It took a lot of hard work to prepare for the interviews, but the diverse experience I had gained helped me position myself as a good fit for a Solutions Architect role, which requires both technical and consulting skills.</p><blockquote><p>Pro Tip: Don't let coding interviews discourage you from applying at MAANG+ companies. Explore jobs other than SDE roles and you'll be surprised at how different the interview processes are.</p></blockquote><p>Having spent 5 years in the Solutions Architect (SA) role at AWS and being promoted to Principal SA has given me enough insights into what is required to become a successful SA. Ask any experienced SA about what their day-to-day role looks like, and they would answer, \"Every day is different.\" And that's true.</p><p>Let me give you a glimpse of the different hats an SA wears in their role. It will not only help you understand what a typical day of an SA looks like but also the skills you should be developing if you aspire to become an SA.</p><ul><li><p><strong>cross-functional collaborators</strong></p></li></ul><p>So, one day I might spend a full day in whiteboarding sessions with customers, understanding their requirements and coming up with solutions using different AWS services. </p><p>Another day might find me glued to my computer, creating a proof of concept to showcase the capabilities of AWS services. Then there might be days when I speak at conferences, evangelizing AWS services. Or I might spend a full day conducting workshops and training sessions to upskill customers on AWS.</p><blockquote><p>Pro Tip: As every customer is different and every customer problem is unique, so is each day of a Solutions Architect. And that's what I like about the SA role.</p></blockquote><p><a href=\"https://www.youtube.com/@be-sa\" rel=\"\"> BeSA (Become a Solutions Architect)</a><a href=\"https://www.youtube.com/@be-sa\" rel=\"\"> BeSA YouTube channel</a></p><ul><li><p>Technical Track: AWS GenAI immersive hands-on workshops</p></li><li><p>Behavioural Track: Cracking the Solutions Architect Interview at AWS</p></li></ul><p><a href=\"https://www.linkedin.com/in/kprasadrao/\" rel=\"\">LinkedIn</a></p><p>We are not over yet! 2 more things.</p><a href=\"https://www.writeedge.ai/\" rel=\"\">WriteEdge</a><p><a href=\"https://x.com/mahdi\" rel=\"\">Mahdi</a></p><p>If you are someone looking to have discussions with like-minded people ‚Üí More than 468 people are already there!</p><p>Liked this article? Make sure to üíô click the like button.</p><p>Feedback or addition? Make sure to üí¨ comment.</p><p>Know someone that would find this helpful? Make sure to üîÅ share this post.</p><ul><li><p><a href=\"https://maven.com/gregor-ojstersek/senior-engineer-to-lead?promoCode=ENGLEADERSHIP\" rel=\"\">here</a></p></li><li><p><a href=\"https://calico-cabinet-fbf.notion.site/Sponsor-Engineering-Leadership-fa0579535d6f4422a6da350580a54546\" rel=\"\">here</a></p></li><li><p><a href=\"https://store.eng-leadership.com/\" rel=\"\">here</a></p></li><li><p><a href=\"https://calico-cabinet-fbf.notion.site/Work-with-Gregor-Ojstersek-1147b66fdc24809b86b1fb0467b60318\" rel=\"\">here</a></p></li></ul><p>If you wish to make a request on particular topic you would like to read, you can send me an email to info@gregorojstersek.com.</p><p>This newsletter is funded by paid subscriptions from readers like yourself.</p><p>If you aren‚Äôt already, consider becoming a paid subscriber to receive the full experience!</p><p>You are more than welcome to find whatever interests you here and try it out in your particular case. Let me know how it went! Topics are normally about all things engineering related, leadership, management, developing scalable products, building teams etc.</p>","contentLength":10518,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ilik3a/from_engineer_to_principal_solutions_architect_at/"},{"title":"Brainfly: A high-performance Brainf**k JIT and AOT compiler built on top of C# type system","url":"https://github.com/hez2010/Brainfly/blob/main/Intro.md","date":1739108814,"author":"/u/hez2010","guid":445,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ilf1hy/brainfly_a_highperformance_brainfk_jit_and_aot/"},{"title":"AI Code Generators Are Creating a Generation of ‚ÄúCopy-Paste Coders‚Äù ‚Äî Here‚Äôs How We Fix It","url":"https://medium.com/mr-plan-publication/ai-code-generators-are-creating-a-generation-of-copy-paste-coders-heres-how-we-fix-it-d49a3aef8dc2?sk=4f546231cd24ca0e23389a337724d45c","date":1739104183,"author":"/u/TerryC_IndieGameDev","guid":447,"unread":true,"content":"<p>You‚Äôre mentoring a junior developer. They‚Äôre breezing through tasks, their screen a blur of AI-generated code snippets. They meet every deadline, their GitHub commits glowing green. But then you ask them to explain  their code works. Silence. They fumble through jargon, their confidence crumbling like a house of cards.</p><p>This isn‚Äôt a hypothetical scenario. It‚Äôs happening in startups, corporate IT departments, and bootcamps worldwide. AI-powered tools like GitHub Copilot are reshaping coding ‚Äî but beneath the hype lies a crisis we‚Äôre too afraid to name: <strong>We‚Äôre raising a generation of developers who can‚Äôt think for themselves.</strong></p><p>Let‚Äôs be clear: AI code completion isn‚Äôt evil. For seasoned developers, it‚Äôs like having a tireless intern handle boilerplate code. But for juniors? It‚Äôs become the programming equivalent of GPS addiction.</p><p>I recently reviewed code from a junior who‚Äôd ‚Äúsolved‚Äù a complex sorting problem using Copilot. When I‚Ä¶</p>","contentLength":967,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ildoun/ai_code_generators_are_creating_a_generation_of/"},{"title":"Carbon is not a programming language (sort of)","url":"https://herecomesthemoon.net/2025/02/carbon-is-not-a-language/","date":1739050237,"author":"/u/SophisticatedAdults","guid":446,"unread":true,"content":"<p>\n              In case you‚Äôve not heard of it,  is Google‚Äôs experimental\n              <a href=\"https://github.com/carbon-language/carbon-lang\" target=\"_blank\">open-source</a> ‚ÄúC++-successor\n              language‚Äù. As a very rough first approximation, think Objective-C/Swift, Java/Kotlin, C/C++, C++/Carbon.\n              It is also frequently mentioned in the same breath as Herb Sutter‚Äôs Cppfront and Sean Baxter‚Äôs Circle (and\n              Rust, surprise surprise).\n            </p><p>\n              Like with any ‚Äòsuccessor language‚Äô, the overall goal includes (at the bare minimum) near-seamless\n              interoperability, as well as  improvements over the original language.\n              (Otherwise it can hardly be called a successor, duh.)\n            </p><p>\n              If you‚Äôve clicked on the article, you‚Äôre probably waiting for me to admit that I‚Äôm lying, and to tell you\n              that (in fact) Carbon  a programming language.\n            </p><p>\n              And yes, it‚Äôs true! Carbon is a programming language. (Or rather, it‚Äôs  to be a\n              programming language. Carbon is an experimental project and hasn‚Äôt hit its 0.1 release milestone yet. The\n              Carbon developers are very transparent about this.)\n            </p><p>\n              But in my humble opinion, thinking of Carbon as a ‚Äòprogramming language‚Äô is kind of missing the point. Let\n              me tell you how I think about Carbon, and why I think that it‚Äôs more interesting than most people give it\n              credit for:\n            </p><blockquote><p>\n                Carbon is a concentrated experimental effort to develop tooling that will facilitate automated\n                large-scale long-term migrations of existing C++ code to a modern, well-annotated programming language\n                with a modern, transparent process of evolution and governance model.\n              </p></blockquote><p>\n              The entirety of Carbon (the language, as well as the project) is built around making this goal possible.\n              (Disclaimer, I don‚Äôt speak for Carbon, take my words with a grain of salt.)\n            </p><p>In this post, I want to convince you of the following points:</p><ol><li>\n                Carbon is a project to investigate the possibility of a large-scale reduction of C++ technical debt via\n                automated code migration.</li><li>\n                Many so-called ‚Äòsuccessor languages‚Äô are . They don‚Äôt make\n                 an explicit goal, and generally build a layer of abstraction on top of\n                or rely on their host language.\n              </li><li>\n                All of this is downstream of Google‚Äôs disagreements with the C++ Standard Committee. In fact, while all\n                of this is about reducing technical debt, it‚Äôs also about reducing the organizational costs involved in\n                having to coordinate migrations and language evolution with the committee.\n              </li><li>Developing a new programming language is probably necessary to achieve the goals of the project.</li></ol><p>\n              I‚Äôd like to bring special attention to the point about governance: This isn‚Äôt just a technical issue. It‚Äôs\n              a governance issue. It‚Äôs a ‚ÄúWe just straight-up disagree on the future direction of the C++ programming\n              language.‚Äù sort of issue. I already went over these cultural disagreements in\n              <a href=\"https://herecomesthemoon.net/2024/11/two-factions-of-cpp/\" target=\"_blank\">a previous post</a>.\n            </p><p>\n              (The astute reader will note that you can evolve and govern your own programming language however you\n              want, without needing to deal with WG21 (aka the C++ Standard Committee, aka the authority that decides\n              what C++ .))\n            </p><p>\n              At this point I‚Äôd  to reach for the Herb Sutter ‚ÄúWe must minimize the need to change existing\n              code.‚Äù quote again,\n              but I‚Äôll instead just state the obvious:\n            </p><p>\n              A large-scale migration to a different programming language is  paradigm. As far as\n              changes to existing code go, it‚Äôs uncompromising. It‚Äôs an approach that‚Äôs only going to work for a subset\n              of people, and in fact,\n              <a href=\"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#legacy-compiled-libraries-without-source-code-or-ability-to-rebuild\" target=\"_blank\">Carbon‚Äôs goal document</a>\n              lists ‚ÄúWe consider it a non-goal to support legacy code for which the source code is no longer available‚Äù.\n            </p><p>\n              In other words, the language is not for everyone. That‚Äôs fine! I am still very interested in it. I care\n              about Carbon since I believe that it‚Äôs trying to solve the hardest problem C++ is currently facing.\n            </p><p>\n              This isn‚Äôt any  technical issue (there are many, many of those), no, and it‚Äôs not even a\n              broad concern such as memory safety.\n            </p><p>\n              It‚Äôs the problem of C++ slowly calcifying and struggling to modernize. It‚Äôs about ABI, about dozens of\n              tools but no agreed upon standards, and it‚Äôs about backwards compatibility. It‚Äôs about allowing existing\n              C++ code to , modernize and change, in spite of decades of technical debt, multiple\n              implementations, and many different users with different expectations and requirements.\n            </p><p>This is, in other words, an , and a .</p><p>\n              If you believe that certain multi-million line C++ codebases are still going to exist in twenty years,\n              <em>then you should understand the business case for Carbon</em>.\n            </p><h3>A short lesson in history</h3><p>\n              Let‚Äôs briefly summarize the backstory for those who haven‚Äôt kept track. You could (very roughly) say that\n              Google is developing Carbon due to conflicts with WG21, and disagreements about the future of the C++\n              language.\n            </p><p>\n              What matters is that Google contributed to WG21 for many years, and that it has a vested interest in the\n              future of the language, due to owning many,  million lines of C++ code. It‚Äôs hard to\n              overstate how critical C++ is for Google‚Äôs infrastructure, and for modern technology in general.\n            </p><p>\n              The short summary is that Google‚Äôs developers (not just Google‚Äôs, mind you) disagreed with other parts of\n              the committee about the\n              <a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2137r0.html\" target=\"_blank\">future direction of the C++ language</a>. There are a lot of reasons for this, and\n              <a href=\"https://cor3ntin.github.io/posts/abi/\" target=\"_blank\">a lot of ink</a> has been spilled on the\n              topic. Eventually, after trying to work with WG21 for many years, Google basically threw in the towel.\n              (You cannot blame them. They tried hard, and the WG21 process is notoriously slow and frustrating.)\n            </p><p>\n              At this point, a lot of people might think that the core disagreement between Google and WG21 was about\n              ‚Äòmemory safety‚Äô, or something like that.\n            </p><p>\n              The current memory safety hype is a pretty big deal for C++, but the ball was already rolling several\n              years ago. All of this started with concerns about C++‚Äôs complexity\n              and .\n              It turns out that fixing certain issues would require backwards incompatible changes (bad!). Coordinating\n              this across the entire C++ ecosystem would be more or less impossible.\n            </p><p>\n              I‚Äôll not get into the details and instead point at Chandler Carruth‚Äôs\n              <a href=\"https://youtu.be/rHIkrotSwcc?t=1599\" target=\"_blank\">‚ÄòThere are no zero-cost abstractions‚Äô</a>\n              for an example: It pins down how first of all,  has a runtime overhead, and\n              second of all, how fixing this would require an ABI-break and a language change.\n            </p><p>\n              (That doesn‚Äôt mean Google doesn‚Äôt care about memory safety, of course. They do. But memory safety isn‚Äôt\n              what started the whole conflict, even though it‚Äôs currently carrying the torch. That‚Äôs why memory safety\n              is still relevant to all of this, especially since making C++ memory safe without compromising the vision\n              of the standard committee looks more or less impossible.)\n            </p><h2>Migration &amp; Language Evolution</h2><p>\n              First of all, that Carbon has  as one of its goals should be clear. The\n              Carbon people are\n              <a href=\"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/goals.md#interoperability-with-and-migration-from-existing-c-code\" target=\"_blank\">very explicit about this</a>. It‚Äôs also a common theme in\n              <a href=\"https://youtu.be/omrY53kbVoA?t=634\" target=\"_blank\">their talks</a>.\n            </p><p>\n              This is, first and foremost, about moving  from the ‚ÄúWe mustn‚Äôt break existing code, so we\n              had to squeeze in this new feature/syntax in some awkward way .‚Äù approach to language\n              evolution. ( and the (proposed) reflection operator () are sending\n              their regards.)\n            </p><p>\n              This approach to language evolution kind of sucks. It‚Äôs not like the committee doesn‚Äôt\n               the problem, or doesn‚Äôt  to evolve the language. The committee is not\n              evil, and it‚Äôs not your enemy. C++ is just incredibly hard to evolve for all sorts of reasons, which would\n              honestly justify an article on their own (ABI, multiple implementations and the committee process, no\n              unified ecosystem, no editions or epochs system, no unified migration tooling, widespread dynamic linking,\n              etc.)\n            </p><p>Carbon‚Äôs goal is to move away from that.</p><p>\n              How? Via automated tooling, a well-defined process of language evolution with clear guarantees, etc.\n              Carbon is still highly experimental, so the details are still WIP. If I had to guess, I‚Äôd say they‚Äôre\n              planning to follow in the footsteps of other modern languages. As an example, consider how Rust manages:\n            </p><ul><li>\n                Have a new ‚Äôedition‚Äô every three years or so. Each edition is allowed to make certain breaking changes,\n                but modules from separate editions can be compiled and linked together.\n              </li><li>\n                Ship automated migration tooling with the language, which allows an automatic migration of code to the\n                new edition whenever possible.\n              </li><li>\n                If you want to eg. introduce a new keyword, you  it one edition ahead of time.\n                <a href=\"https://doc.rust-lang.org/book/appendix-01-keywords.html#raw-identifiers\" target=\"_blank\">Raw Identifier syntax</a>\n                allows migration and use of old code that still uses this keyword as an identifier.\n              </li></ul><p>In contrast to this, I don‚Äôt think there‚Äôs any feasible roadmap to get C++ to this state.</p><p>It‚Äôs only possible with an ecosystem split, and that‚Äôs exactly the point.</p><p>\n              Let me reiterate this. If there‚Äôs one thing you take from this article, it‚Äôs this here: The\n               is to make it possible to take existing C++ code and to put it onto a path\n              towards a modern, well-defined process for future evolution and changes.\n            </p><p>\n              This is the point. If you want to be cynical, it‚Äôs about cutting the dependency on the standard committee,\n              and it‚Äôs about allowing any forwards-looking, backwards-incompatible changes , without\n              having to worry about someone else‚Äôs ancient binaries from the 80s.\n            </p><p>\n              I just want to make clear that I believe that Carbon is radically different from\n              <a href=\"https://hsutter.github.io/cppfront/\" target=\"_blank\">Cpp2</a> (ie. Herb Sutter‚Äôs experimental\n              project to evolve C++).\n            </p><p>\n              The major difference is that Cpp2 tries to leverage the existing C++ language to its full extent, while\n              Carbon tries to minimize its dependency on C++ wherever possible.\n            </p><p>\n              Cpp2 takes the same approach C++ originally did: It transpiles its own code to the host language, and is\n              thus deeply and intrinsically linked to it. It reuses the C++ standard library with all of its problems,\n              it aims to maintain the C++ ecosystem instead of splitting it.\n            </p><p>\n              Perhaps most importantly, Cpp2 also cannot go  than C++: It cannot directly interface with\n              the compiler, since it‚Äôs written to be used by ‚Äúany standard-compliant C++20 compiler‚Äù.\n            </p><p>\n              It should be obvious that it‚Äôs basically impossible for Cpp2 to make meaningful reductions to C++‚Äôs\n              technical debt. Yes, it can be ‚ÄúC++, except with better defaults and syntax.‚Äù, but that‚Äôs all it can\n              feasibly be as long as full backwards compatibility is an explicit goal. Reducing C++‚Äôs technical debt on\n              a deeper level is  for Cpp2.\n            </p><p>\n              It  reduce the number of ways there are to initialize objects by simplifying syntax. It\n               make any changes that would require an ABI-break, it cannot add null-safety to the\n              language (eg.  can still be null,  can still be valueless), and\n              it can‚Äôt prevent your code from blowing up in exciting ways due to lifetime issues.\n              Carbon has the advantage that it  make these changes. (eg. Carbon is planning to move away\n              from exceptions, in favor of treating errors as values.)\n            </p><p>\n              Just to be clear, this is fine! I am not saying Cpp2 is bad, and I‚Äôm curious to see how the project\n              develops. I am just highlighting that Carbon and Cpp2 are <em>completely different projects</em> with\n              completely different scopes and goals.\n            </p><p>\n              It is written by Herb Sutter, someone who very clearly  C++ as it is, and who wants to make\n              it easier to use. It‚Äôs about having a new syntax, and making it  to apply best practices\n              to your C++ code.\n            </p><p>\n              This is a great idea, and a much less invasive proposal than Carbon. Carbon isn‚Äôt that. Carbon is about\n              <em>reworking the language from the ground up</em>. It‚Äôs about building a  language that can\n              support almost all of the same semantics, but is still critically different. It‚Äôs about reworking the\n              fundamentals, and building stronger abstractions.\n            </p><p>\n              So in short, Cpp2 works  C++, and Carbon is trying to  a better C++ from\n              scratch, while cutting its dependency on C++ almost completely.\n            </p><p>\n              Is Carbon feasible? I‚Äôll be honest, I have no clue. C++ code is  and this project is\n              (more or less) unprecedented. (Which is, again, why I am interested in it.)\n            </p><p>The reasons why I believe it  be technically feasible at all are simple:</p><ol><li>\n                Carbon doesn‚Äôt attempt to do the impossible: The goal is a tool-assisted migration of idiomatic code,\n                not a fully automated migration of  code. (What does ‚Äòidiomatic‚Äô mean? Who knows. Probably\n                something like ‚Äòwell-annotated and easy to handle for static analyzers‚Äô. Figuring out how to draw the\n                boundary of which code can be migrated is part of the project.)\n              </li><li>\n                Carbon is capable of leveraging its underlying tooling to do a  of the hard work. For\n                example, resolving C++ templates and function calls is handled by Clang and LLVM. This should not be\n                much of a surprise. Clang can be used as a library, and this is exactly what you‚Äôd expect it to excel\n                at. (Swift is\n                <a href=\"https://www.swift.org/documentation/cxx-interop/status/\" target=\"_blank\">already doing this for its C++ interop</a>.)\n              </li><li>\n                Carbon already demonstrated that its chosen abstractions are capable of supporting some pretty ‚Äúfun‚Äù C++\n                features.\n              </li></ol><p>Let me quickly substantiate some of that.</p><p>\n              So, here‚Äôs the thing. Carbon can\n              <em>convert your C++ to Carbon and then run it against the old test suite</em>. (Or that‚Äôs the plan, at\n              least.)\n            </p><p>(You do have a test suite, right?)</p><p>\n              If the code compiles and all tests pass, this should give you confidence in the resulting code\n              proportional to your confidence in your own test suite. (This is especially helpful for changes\n               the initial automated migration, even if it‚Äôs just clean-up work.)\n            </p><p>This approach is  for all sorts of reasons.</p><p>\n              First of all, it means that Carbon can leverage\n              <em>existing C++ test suites to test its own migration and interop capabilities</em>. This is great.\n            </p><p>\n              Second of all, it puts  burden on the user and sets a minimal bar for what Carbon means with\n              ‚Äòmigration of idiomatic C++‚Äô: You should  have some tests in your code. If you critically\n              depend on something, then you should have a test for it.\n            </p><h3>Generalization and unification of C++ features</h3><div><pre tabindex=\"0\"><code data-lang=\"cpp\"></code></pre></div><p>\n              If you have no idea what you‚Äôre looking at: This is legal C++. Calling  a ‚Äòpointer‚Äô is a\n              stretch, in practice it is just an  relative to the location of an object of this class in\n              memory.\n            </p><p>\n              Two funfacts: First, this can also be used to refer to methods. Second, this value can be null, and it‚Äôs\n              null-value is , since  would point to an actual field.\n            </p><p>\n              When I see a feature like this, my first question would be whether Carbon is even capable of\n               this specific type of behavior, and it turns out that, yes, they have thought about\n              this.\n            </p><p>\n              Carbon is building  on top of  (which can broadly be\n              understood as C++0x Concepts or Rust traits).\n            </p><p>\n              There‚Äôs a simple reason for that: Carbon wants to support  checked generics\n              (roughly, you‚Äôll know that a generic function can be instantiated without having to look into the body of\n              the function. This is not the case for templates.) As a consequence,  which\n              you can ‚Äúdo‚Äù with a value needs to be implemented as an interface, so that you can specify that an\n              incoming value fulfills this constraint.\n            </p><p>\n              Consequently,  are implemented via a so-called\n               interface, which (as far as I can tell) generalizes expressions of the form\n              , whether  is a field, a static member function, a method, a member access\n              pointer, or who knows what else. Any  which implements  (where\n               is the class of ) can be used as .\n            </p><p>\n              The pattern of unifying abstractions as interfaces gets used a lot: It turns out that deep within Carbon,\n              function calls are implemented as a synthesized type which implements some  interface.\n              This is used to unify functions, methods, lambdas, etc. Every single thing in Carbon which you can ‚Äúcall‚Äù\n              is just some value implementing the  interface.\n            </p><p>\n              Sorry, I‚Äôm basically just rehashing parts of Chandler Carruth‚Äôs (highly technical) talk here. For the full\n              picture, please just go and watch it. He‚Äôs a great speaker, and I don‚Äôt trust myself to get every\n              technical detail right.\n            </p><p>\n              The point is, if you‚Äôre wondering what the Carbon people are working on, then it‚Äôs this kind of stuff.\n              They‚Äôre building  which are general enough to to make all sorts of gnarly C++\n              semantics (eg. member access pointers) work, but have a  simpler underlying model. (eg. it\n              unifies everything that can be called,  gives you the ‚Äòconcept‚Äô/interface for free).\n            </p><p>\n              Is this going to work for the rest of the language? Who knows! C++ is complicated, probably too\n              complicated to manage. That‚Äôs the whole reason why Carbon even exists.\n            </p><h3>Digression: Why not Rust‚Ñ¢? Why not C++?</h3><p>\n              Rust is really just too different for an automated conversion of C++ code to Rust code to be feasible,\n              it‚Äôs as simple as that. I even\n              <a href=\"https://herecomesthemoon.net/2025/01/type-inference-in-rust-and-cpp/\" target=\"_blank\">wrote an article</a>\n              getting into the differences in type inference alone.\n            </p><p>\n              You have no class inheritance, no templates, no specialization, no ad-hoc function overloads, no implicit\n              conversions, and there‚Äôs still the whole deal with the borrow checker. Any conversion of modern\n              general-purpose C++ code to Rust basically amounts to a rewrite, which is just not something you can do\n              with classic automation tooling.\n            </p><p>\n              Carbon has the luxury of being able to support both templates  checked generics (ie. something\n              like Rust traits or C++0x concepts), and a way to migrate between them.\n            </p><p>\n              As for a C++-to-more-modern-C++-migration, it just doesn‚Äôt solve the question of language evolution.\n              You‚Äôre still heavily limited by what you can do, unless you also commit to a proper fork of C++ and\n              possibly Clang.\n            </p><p>\n              Which‚Ä¶might be viable, but makes it much harder to implement clean abstractions from the get-go. It also\n              doesn‚Äôt help that a fork runs a pretty severe risk of being ‚Äòusable‚Äô right from the get-go (meaning that\n              people will want to use it, and the boundary between C++ and Carbon will be muddier).\n            </p><p>\n              As I said, Carbon is a moonshot project to allow modern C++ codebases to evolve. (They might stop being\n              called ‚ÄúC++‚Äù in the process, but that‚Äôs probably fine. The only constant in life is change, or something\n              like that.)\n            </p><p>\n              The north star goal is, of course, that of a gradual but mostly automated migration of existing C++ code\n              to Carbon code, followed by  migrations to fix and improve this code using Carbon‚Äôs\n              modern, more powerful semantics (eg. null safety).\n            </p><p>\n              From this angle, and with the historical background in mind, let‚Äôs address the elephant in the room\n              and take a stab at describing how some people feel about Carbon, by rephrasing my interpretation of its\n              goals in the most cynical way possible. I‚Äôm deeply sorry to anyone who‚Äôs working on Carbon, since this is\n              going to feel like I‚Äôm twisting a proverbial knife:\n            </p><blockquote><p>\n                Carbon‚Äôs primary goal is a large-scale migration of Google‚Äôs enormous pile of (highly specific,\n                exception-less, Abseil and Protobuf-using, Clang-based, Bazel-built) C++ technical debt into a modern\n                language capable of supporting Google‚Äôs needs, and\n                <em>over whose governance Google is capable of exerting a significant amount of control.</em></p></blockquote><p>\n              There we go. Do\n              you see the elephant yet?\n            </p><p>\n              It‚Äôs pretty hard to miss since I highlighted it. (Sorry, I know that it‚Äôs the second time I made that\n              joke.)\n            </p><p>\n              This is about the least charitable way to phrase it, of course. I‚Äôm bringing this up for the obvious\n              reasons: Carbon is spearheaded by a big tech company, and people have various concerns.\n            </p><p>\n              These include the concern that Google trying to ‚Äôtake control‚Äô of C++ via a divide-and-conquer approach,\n              that Carbon will favor Google‚Äôs style of C++ at the expense of others, and the classic sentiment that\n              Carbon will eventually be abandoned and dropped (potentially hanging early adopters out in the dry).\n            </p><p>\n              As I already gestured at before, all of this is about , and by extension about governance.\n            </p><p>\n              As long as we‚Äôre willing to say that Carbon is about reducing the reliance on the C++ Standard Committee,\n              it‚Äôs pretty clear that that governance-shaped hole has to be filled , and that someone (or\n              some group of people) has to decide the future direction of the language.\n            </p><p>\n              I‚Äôll be honest, I can make no guarantees here. I am not working on Carbon, and the dynamics here are far beyond my scope.\n            </p><p>\n              I can point out that Carbon is an Apache-licensed open source project,\n              <a href=\"https://github.com/carbon-language/carbon-lang/blob/trunk/CONTRIBUTING.md\" target=\"_blank\">open for contributors right now</a>, and that it has an explicit ‚ÄúThe intent is that [‚Ä¶] Carbon remains a community-driven project, avoiding\n              situations where any single organization controls Carbon‚Äôs direction.‚Äù\n              <a href=\"https://github.com/carbon-language/carbon-lang/blob/trunk/docs/project/faq.md#how-does-carbon-make-decisions\" target=\"_blank\">disclaimer</a>\n              in its FAQ, but that‚Äôs not going to convince you if you‚Äôre worried about bad intentions.\n            </p><p>\n              So. What I  tell you is that I believe that putting governance of the language into the hands\n              of the open-source community is critical for Carbon‚Äôs long-term success, and that Carbon‚Äôs developers\n              understand this.\n            </p><p>\n              Whether Carbon will find widespread adoption depends on whether  trust\n              Carbon‚Äôs stewards to handle the language with enough responsibility that migrating their own C++ code to\n              Carbon seems like a safe offer.\n            </p><p>\n              This sort of trust is hard to establish as long as there‚Äôs a single owner,  if that\n              owner is Google.\n            </p><p>\n              Second: That Carbon finds any public adoption at all is also pretty important  the primary\n              goal was just to use it purely within Google. This might come as a surprise, but it‚Äôs pretty simple:\n              People who‚Äôre expected to use Carbon first need to learn Carbon. This is  easier\n              when Google can rely on a broad ecosystem of tutorials, libraries and discussion boards outside of its\n              intranet.\n            </p><p>\n              So in other words, for Carbon to become successful, it‚Äôs critical that there‚Äôs a public community, and\n              that enterprise users of C++  Carbon.\n            </p><p>These are huge incentives to push the language towards independent community ownership.</p><p>\n              Both of these points (trust by enterprise users and need for a public community) were\n               for <a href=\"https://go.dev/\" target=\"_blank\">Go</a> (which was also\n              spearheaded by Google), primarily due to Go‚Äôs simplicity, the fact that there was far less competition in\n              the programming language space when Go released, and the fact that it was a language for greenfield\n              projects. (That is, it didn‚Äôt require convincing ancient C++ coders to perform a massive migration and\n              rework their tool chain.)\n            </p><p>\n              My understanding is that\n              <a href=\"https://news.ycombinator.com/item?id=32153320\" target=\"_blank\">Carbon‚Äôs leads understand all of this</a>, and want the project to be community driven. For now, that‚Äôs more than good enough for me. For a\n              project this early in its life-cycle, it‚Äôs nice to see that they‚Äôre thinking about this at all, and have\n              made an explicit commitment to community ownership.\n            </p><h2>Conclusion: There is no free lunch.</h2><p>\n              The prospect of building a  to C++‚Äîarguably single most important programming language\n              currently in existence‚Äîsounds like it should be doomed to fail.\n            </p><p>\n              I‚Äôll repeat what I said before, and what should be common knowledge: C++ is an incredibly complex\n              programming language. It‚Äôs under-annotated, has multiple implementations (governed by a 2000+ page ISO\n              Standard document), carries four decades of technical baggage, is full of undefined behavior, and has a\n              frequently abused Turing-complete quasi-code-generation meta-programming language built into it.\n            </p><p>\n              All of that should make it near impossible to succeed C++. Complexity is in fact a form of job security.\n              So why am I still relatively confident in Carbon‚Äôs potential?\n            </p><p>Simple, it‚Äôs mainly since the priorities look correct to me. Carbon understands that</p><ol><li>\n                C++‚Äôs inability to evolve, modernize, deprecate, migrate and standardize is  critical issue\n                which the language is facing today.</li><li>\n                You cannot improve on this without making concessions. This goes both ways: There is old C++ code which\n                you will not be able to support. At the same time, there are C++ features which you  to\n                support, whether you want to or not.\n              </li><li>\n                This is a herculean task that requires a massive initial investment (a whole new programming language),\n                and a complete rethinking of tooling, communication, software engineering and language development\n                practices.\n              </li></ol><p>\n              The inability to evolve is an issue for people who‚Äôre just starting to learn C++, and who stumble into\n              every single footgun that hasn‚Äôt been taken care of over the past thirty years.\n            </p><p>\n              It‚Äôs an issue for people who care for high-quality code, readability or memory safety, and see no viable\n              path towards getting their C++ codebase into that state.\n            </p><p>\n              It‚Äôs an issue for <em>committee and compiler contributors</em>, who need to carefully consider how a new\n              feature will interact with <em>literally everything else</em> the language already supports.\n            </p><p>\n              You might disagree with that assessment. It might not be an issue . That‚Äôs\n              fine. C++ (for a given version, anyway) will stay exactly as it is. It‚Äôs not going to go away anytime\n              soon, and that‚Äôs a good thing. People depend on that. Critical infrastructure depends on that.\n            </p><p>\n              As for myself, I am incredibly glad to see that  is trying to take this bull by the horns,\n              and willing to face this charging billion lines-of-code mountain of complexity and technical debt head-on.\n            </p><p>\n              At last but not at least just since it would be  if we (humanity, as a whole)\n              could actually pull it off, and don‚Äôt need to pass tales warning people about the dangers of using\n               across the generations.\n            </p><p>\n              It might take a while, but that‚Äôs fine. This is a long-term project. It  to be a long-term\n              project to make this work. Once you start thinking about it from that perspective, everything makes a lot\n              more sense.\n            </p><p>\n              Remember, those millions of lines of C++ code are not going to go away anytime soon. They‚Äôll still be\n              there in a few decades. It‚Äôs either a large-scale migration (in some form or another), or nothing.\n            </p><p>\n              In the meantime, if you‚Äôre remotely interested, I‚Äôll reiterate that I highly recommend Carbon‚Äôs talks, eg.\n              <a href=\"https://youtu.be/bBvLmDJrzvI\" target=\"_blank\">this one</a>.\n            </p><p>\n              Writing this took significantly longer than expected. The total number of footnotes written and deleted is\n              about forty.\n            </p><p>Let me know if you got something out of it‚ÄîIt means a lot to me.</p><p>\n              Questions, suggestions, comments, writing advice, reading recommendations, music suggestions, pictures of\n              pets and basically anything else you can think of are all welcome via my contact e-mail at the bottom of\n              the page.\n            </p>","contentLength":31331,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1iky82v/carbon_is_not_a_programming_language_sort_of/"},{"title":"Mastering cross-database operations with PostgreSQL FDW","url":"https://packagemain.tech/p/mastering-cross-database-operations-with-postgres-fdw","date":1739035067,"author":"/u/der_gopher","guid":444,"unread":true,"content":"<p><a href=\"https://wiki.postgresql.org/wiki/Foreign_data_wrappers\" rel=\"\">PostgreSQL‚Äôs </a></p><p>In this post we will talk about:</p><ul><li><p>Setting up FDW to connect to external databases (ex: another PostgreSQL instance).</p></li><li><p>Importing foreign schemas.</p></li><li><p>Creating archival policies with stored procedures</p></li><li><p>Automating archival tasks with pg_cron</p></li></ul><blockquote><p><a href=\"https://dub.sh/focU0Kg\" rel=\"\">Multiplayer</a></p></blockquote><p>FDW is an extension that implements the SQL/MED standard, allowing PostgreSQL to interact with external data sources.</p><ul></ul><p>There is a lot of different FDW extensions that will let you connect to a variety of databases (relational, no-sql, files etc..)</p><ul><li><ul><li><p>Connects to other PostgreSQL databases (local or remote)</p></li><li><p>Supports read/write operations</p></li></ul></li><li><ul><li><p>Reads data from flat files (CSV, TSV, etc..)</p></li></ul></li><li><ul><li><p>Connects to MySQL/MariaDB databases</p></li><li><p>Supports basic queries and joins</p></li></ul></li></ul><p><a href=\"https://wiki.postgresql.org/wiki/Foreign_data_wrappers\" rel=\"\">here</a></p><p>As you can imagine, there are many use cases possible. </p><p>From reading files from your database, to getting cache keys from Redis and augment them from content stored in your PostgreSQL.</p><p><strong>The use case we will focus on, is an automatic archival from PostgreSQL to PostgreSQL.</strong></p><pre><code>-- Enable FDW   \nCREATE EXTENSION IF NOT EXISTS postgres_fdw;</code></pre><pre><code>-- Create a foreign server\nCREATE SERVER postgres_server FOREIGN DATA WRAPPER postgres_fdw\n   OPTIONS (host '{FOREIGN_HOST}', dbname '{FOREIGN_DB_NAME}');\n\n-- Map local PostgreSQL user to foreign server credentials\nCREATE USER MAPPING FOR postgres SERVER postgres_server\n   OPTIONS (user '{FOREIGN_USERNAME}', password '{FOREIGN_PASSWORD}');</code></pre><p>You might be tempted to import foreign schema from the other postgres into the ‚Äúpublic‚Äù schema of your current instance, however you can‚Äôt have 2 tables with the same name. </p><p>That‚Äôs why, I would suggest you create a separate schema, you can call it foreign_schema or whatever you wish:</p><pre><code>-- Create a new schema to import the tables into\nCREATE SCHEMA foreign_schema;\n\n-- Import all tables from the foreign postgreSQL database\nIMPORT FOREIGN SCHEMA public FROM SERVER postgres_server INTO foreign_scehma;\n\n-- You can also import only specific tables\nIMPORT FOREIGN SCHEMA public LIMIT TO ({TABLE1}, {TABLE2}) FROM SERVER postgres_server INTO foreign_schema;</code></pre><p>Now you can query your foreign database:</p><pre><code>SELECT * FROM foreign_schema.{TABLE1};</code></pre><p>The distant server is used as archive and the current db (the one you are connected to) is your live DB. </p><pre><code>CREATE TABLE IF NOT EXISTS transactions (\n    id uuid DEFAULT uuid_generate_v4(),\n    amount INT DEFAULT 0,\n    created_at   TIMESTAMPTZ DEFAULT NOW(),\n\n    PRIMARY KEY (id)\n); </code></pre><pre><code>CREATE OR REPLACE PROCEDURE archive_old_transactions()  \nLANGUAGE plpgsql  \nAS $$  \nBEGIN  \n  -- Move data older than 1 year to archive  \n  INSERT INTO foreign_schema.transactions  \n  SELECT * FROM public.transactions  \n  WHERE created_at &lt; NOW() - INTERVAL '1 year';  \n\n  -- Delete archived data from main table  \n  DELETE FROM public.transactions  \n  WHERE created_at &lt; NOW() - INTERVAL '1 year';  \nEND;  \n$$\n;  </code></pre><pre><code>-- Enable pg cron   \nCREATE EXTENSION IF NOT EXISTS pg_cron;</code></pre><pre><code>-- Run at 2 AM daily\nSELECT cron.schedule(\n  'archive_transactions',\n  '0 2 * * *',\n  'CALL archive_old_transactions()'\n); </code></pre><pre><code>CREATE VIEW combined_transactions AS (\n    WITH remote_data AS (\n      SELECT * FROM foreign_schema.transactions\n    ),\n    local_data AS (\n      SELECT * FROM public.transactions\n    )\n    SELECT * FROM remote_data\n    UNION ALL\n    SELECT * FROM local_data\n);</code></pre><p>You will notice that I didn‚Äôt simply do a UNION of two tables, I used CTE (Common Table Expressions) because it is crucial for optimizing queries with foreign tables. </p><p>Essentially, it containerizes the FDW query, because the query planner will have to ask the foreign database to execute its part, and the clearer this query is, the faster it will be.</p><ul><li><p>Containerize the FDW query to reduce data transfer</p></li><li><p>Filter data at the source </p></li><li><p>Minimize the returned row count </p></li></ul><p>Nothing forces you to have the exact same copy of foreign and local table, neither you have to force foreign keys or equivalent indexes. </p><p>It is probably recommended to create specific indexes in your foreign table that will match the query patterns they will be submitted to. Because you don‚Äôt query archive data the same way you might query live data. </p><p>The concept of archival is often to reclaim space, but if you were to need faster access to data from both the archive and the live DB then you could use Materialized views to ensure fast queries. </p><p>So if you query transactions from 2 years ago from now, until now. You necessarily have to query both tables.</p><pre><code>SELECT * FROM combined_transactions WHERE created_at BETWEEN(NOW() - INTERVAL '2 year', NOW()); </code></pre><ol></ol><p>PostgreSQL FDW transforms your database into a unified gateway for cross-database operations. By combining it with pg_cron and stored procedures, you can automate complex workflows like archival, reporting, and data synchronization without external tools. </p><blockquote><p><a href=\"https://dub.sh/focU0Kg\" rel=\"\">Multiplayer</a></p></blockquote>","contentLength":4730,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1iksa6k/mastering_crossdatabase_operations_with/"}],"tags":["dev","reddit"]}