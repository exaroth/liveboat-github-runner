{"id":"EfcLDDAkyqguXw9Vbtcae7fRhxCsY1chPUNLpwbK9oHS42b4dGEMeGvA2hWHB2j3LFSAo7qhibLNgPBcA5djbGp95Jk5T","title":"top scoring links : programming","displayTitle":"Reddit - Programming","url":"https://www.reddit.com/r/programming/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/programming/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Hard Rust requirements from May onward for all Debian ports","url":"https://lists.debian.org/debian-devel/2025/10/msg00285.html","date":1762000364,"author":"/u/pyeri","guid":600,"unread":true,"content":"<pre>Hi all,\n\nI plan to introduce hard Rust dependencies and Rust code into\nAPT, no earlier than May 2026. This extends at first to the\nRust compiler and standard library, and the Sequoia ecosystem.\n\nIn particular, our code to parse .deb, .ar, .tar, and the\nHTTP signature verification code would strongly benefit\nfrom memory safe languages and a stronger approach to\nunit testing.\n\nIf you maintain a port without a working Rust toolchain,\nplease ensure it has one within the next 6 months, or\nsunset the port.\n\nIt's important for the project as whole to be able to\nmove forward and rely on modern tools and technologies\nand not be held back by trying to shoehorn modern software\non retro computing devices.\n\nThank you for your understanding.\n-- \ndebian developer - deb.li/jak | jak-linux.org - free software dev\nubuntu core developer                              i speak de, en\n</pre>","contentLength":874,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olmnhx/hard_rust_requirements_from_may_onward_for_all/"},{"title":"Not So Fast: Analyzing the Performance of WebAssembly vs. Native Code (WASM 45% slower)","url":"https://ar5iv.labs.arxiv.org/html/1901.09056","date":1761989253,"author":"/u/Zomgnerfenigma","guid":599,"unread":true,"content":"<h5>The Challenge of Benchmarking WebAssembly</h5><div><p>The aforementioned suite of 24 benchmarks is the PolybenchC benchmark\nsuite&nbsp;, which is designed to measure the effect of\npolyhedral loop optimizations in compilers. All the benchmarks in the\nsuite are small scientific computing kernels rather than full\napplications (e.g., matrix multiplication and LU Decomposition); each is\nroughly 100 LOC. While WebAssembly is designed to accelerate scientific\nkernels on the Web, it is also explicitly designed for a much richer set\nof full applications.</p></div><div><p>The WebAssembly documentation highlights several intended use\ncases&nbsp;, including scientific kernels, image editing,\nvideo editing, image recognition, scientific visualization, simulations,\nprogramming language interpreters, virtual machines, and POSIX applications.\nTherefore, WebAssembly‚Äôs strong performance on the scientific kernels in PolybenchC\ndo not imply that it will perform well given a different kind of application.</p></div><div><p>We argue that a more comprehensive evaluation of WebAssembly should rely on an\nestablished benchmark suite of large programs, such as the SPEC CPU benchmark\nsuites. In fact, the SPEC CPU 2006 and 2017 suite of\nbenchmarks include several applications that fall under the intended use cases of\nWebAssembly: eight benchmarks are scientific applications (e.g., ,\n, , , and\n), two benchmarks involve image and video processing\n( and ), and all of the benchmarks are POSIX\napplications.</p></div><div><p>Unfortunately, it is not possible to simply compile a sophisticated\nnative program to WebAssembly. Native programs, including the programs in\nthe SPEC CPU suites, require operating system services, such as a\nfilesystem, synchronous I/O, and processes, which WebAssembly and the\nbrowser do not provide. The SPEC benchmarking harness itself requires\na file system, a shell, the ability to spawn processes, and other Unix\nfacilities. To overcome these limitations when porting native\napplications to the web, many programmers painstakingly modify their\nprograms to avoid or mimic missing operating system\nservices. Modifying well-known benchmarks, such as SPEC CPU, would not\nonly be time consuming but would also pose a serious threat to\nvalidity.</p></div><div><p>The standard approach to running these applications today is to use\nEmscripten, a toolchain for compiling C and C++ to\nWebAssembly&nbsp;. Unfortunately, Emscripten only supports\nthe most trivial system calls and does not scale up to large-scale\napplications. For example, to enable applications to use synchronous\nI/O, the default Emscripten  filesystem loads the entire\nfilesystem image into memory before the program begins executing. For\nSPEC, these files are too large to fit into memory.</p></div><div><p>A promising alternative is to use , a framework that enables\nrunning unmodified, full-featured Unix applications in the\nbrowser&nbsp;.  implements\na Unix-compatible kernel in JavaScript, with full support for\nprocesses, files, pipes, blocking I/O, and other Unix features.\nMoreover, it includes a C/C++ compiler (based on Emscripten)\nthat allows programs to run in the browser\nunmodified. The  case studies include complex applications,\nsuch as , which runs entirely in the browser without any\nsource code modifications.</p></div><div><p>Unfortunately,  is a JavaScript-only solution, since it was\nbuilt before the release of\nWebAssembly. Moreover,  suffers from high performance overhead,\nwhich would be a significant confounder while benchmarking. Using ,\nit would be difficult to tease apart the poorly performing benchmarks\nfrom performance degradation introduced by .</p></div>","contentLength":3526,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1oljj3v/not_so_fast_analyzing_the_performance_of/"},{"title":"Programming Language Agnostic Naming Conventions","url":"https://codedrivendevelopment.com/posts/programmatic-naming-conventions-guide","date":1761982250,"author":"/u/Distinct-Panic-246","guid":598,"unread":true,"content":"<p>There is a famous quote when it comes to naming things in programming, which is attributed to Phil Karlton</p><blockquote><p>\"There are only two hard things in Computer Science: cache invalidation and naming things\"</p></blockquote><p>(Or the slight variation of <em>\"There are only two hard things in Computer Science: cache invalidation, naming things, and off by one errors\"</em>)</p><p>But over the last few decades there are definitely a few common conventions. Using standard names for things frees up time to work on tougher problems than naming, and means future readers of your code can probably understand the concept better.</p><h2>Why we spend time naming things correctly</h2><p>If you see a variable called , you can probably assume it is a boolean.  or  are not clear.</p><h3>Avoid Negative variable names:</h3><p>Negative names can lead to double negatives, which are confusing.</p><ul></ul><p>Abbreviations can be ambiguous - not everyone will interpret it as the same meaning. Just use the full word, it is clearer.</p><p>(Although  is probably an exception where it should always be used over ).</p><ul></ul><h3>Pick a language and always use that</h3><p>If you work in a modern company then it is likely you work with people originally from various countries around the world. It can be easy to end up with a codebase with a mix of words like  and .</p><p>I'd recommend just picking US spelling in your code (even if the app is localised only for a UK or AU audiece)</p><ul></ul><h3>Make booleans obvious by using is/has prefix</h3><p>If you name something , it is quite obvious that it is a boolean. Try to always do this, as something like  could read as if it wasn't a boolean</p><ul></ul><p>Words like , ,  are too generic. Try to avoid these terms</p><p>Pick a convention for naming things, and use those everywhere.calculateAmount</p><ul><li>Bad üëé:  and </li><li>Good üëç:  and </li></ul><p>Also pick a style for casing, and be sure you're consistent with it. Here are some examples (there might be other typical conventions for your library/language of choice)</p><ul><li> for class names</li><li> for most other variables</li><li> for static constants</li></ul><h2>Common names for specific things</h2><p>If you're taking some data and  it to a different shape or different values then  is a common and accurate name.</p><pre><div><div><div><code></code></div></div></div></pre><p>If you need to check if data is valid/correct, then its almost always called a validator.</p><pre><div><div><div><code></code></div></div></div></pre><p>Used when describing the shape of some data structure. Often used with database designs.</p><pre><div><div><div><code></code></div></div></div></pre><p>When you need to take some data (e.g. some string) and understand its own data structure. They are quite different things, parsers and transformers can  be very related</p><pre><div><div><div><code></code></div></div></div></pre><p>For code that runs 'between' different parts of your application. A typical use for middleware is in HTTP servers the incoming HTTP request can go through multiple middlewares to either transform the incoming data (before passing to next one or final endpoint handler function) or to do something with that data</p><pre><div><div><div><code></code></div></div></div></pre><p>When you have some functionality with a specific interface, and you need to convert it to another interface/shape.</p><p>It is also known as a 'wrapper' (or a bridge, although that is technically a slightly different thing)</p><p>When you need to make data uniform in scale, format, or structure</p><pre><div><div><div><code></code></div></div></div></pre>","contentLength":3010,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olht95/programming_language_agnostic_naming_conventions/"},{"title":"IRS open-sourced the fact graph it uses for tax law","url":"https://github.com/IRS-Public/fact-graph","date":1761958132,"author":"/u/R2_SWE2","guid":602,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1olb241/irs_opensourced_the_fact_graph_it_uses_for_tax_law/"},{"title":"John Carmack on mutable variables","url":"https://twitter.com/id_aa_carmack/status/1983593511703474196","date":1761938789,"author":"/u/iamkeyur","guid":601,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1ol3unj/john_carmack_on_mutable_variables/"},{"title":"C3 0.7.7 Vector ABI changes, RISC-V improvements and more","url":"https://c3-lang.org/blog/c3-language-at-0-7-7-vector-abi,-riscv-improvements-and-more/","date":1761928654,"author":"/u/Nuoji","guid":597,"unread":true,"content":"<p>0.7.7 is a major advance in C3 usability with vector ABI changes. It also contains several small quality-of-life additions, such as the ability to splat structs into an initializer, and implicit subscript dereferencing. Fairly few bugs were discovered during this development cycle, which is why the fixed bugs are unusually low.</p><p>Let‚Äôs look at what 0.7.7 brings in more detail:</p><p>The most significant change in this release is the ABI change for vectors, which now store and pass vectors as arrays in function calls and structs. While vectors still use SIMD, their equality to arrays on the ABI level means that C graphical libraries will directly match vector types.</p><p>Where before you needed to work with C structs defining vectors and then converting them to SIMD vectors for actual computation, it now works out of the box. Another problem with vectors prior to 0.7.7 was their space and alignment requirements over structs. From 0.7.7 alignment matches that of structs and arrays, making them extremely convenient to work with.</p><p>For cases where SIMD vectors are actually expected, it‚Äôs possible to create distinct types using  with a new  attribute to exactly match standard C SIMD vectors, e.g. <code dir=\"auto\">typedef V4si = int[&lt;4&gt;] @simd;</code>. This then exactly matches the corresponding C SIMD type.</p><p>This makes it easier than ever to use SIMD with C3.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><h2>Struct initializer splats</h2><p>This feature enables using the splat operator  to give a designated initializer default values that are overridden by the following arguments.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>When passing arrays or lists by reference, the  operator tend to behave in an undesirable way, dereferencing the pointer instead of the underlying array/list:</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>Subscript deref addresses this. Using  will dereference :</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>This is helpful when writing macros and such that will want to accept both elements by reference and by value:</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>A new feature for  is to allow creating a type with a specific alignment without wrapping it in a struct. We may, for example, create an integer that is 16 bit aligned using <code dir=\"auto\">typedef Int2 = int @align(2);</code>. This is an alternative way to safely work with references to under-aligned members in packed structs.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><p>, ,  and  macros are added to modify strings at compile time efficiently for certain macro manipulation at compile time.</p><div><figure><pre data-language=\"c3\"><code></code></pre></figure></div><h2>Small but important changes</h2><p>Aliases that refer to  variables must themselves have local visibility.  is renamed  as it was frequently misunderstood. Generic inference now works better in initializers. For slices with the  syntax, it‚Äôs now possible to have the end index be one less than the starting index, so that zero size slices can be expressed with the  syntax as well.</p><p>This release significantly strengthens C3C‚Äôs cross-platform capabilities, particularly for RISC-V architecture support. It‚Äôs now possible to set individual CPU features using , e.g. . For RISC-V,  has been added, as well as renaming the RISC-V abi flag to the more correct .</p><p>The sorting macros accidentally only took non-slices by value, which would work in some cases but not in others. This has been fixed, but might mean that some code needs to update as well. TcpSocketPair was added to the tcp module to create a bidirectional local socket pair, and using sockets on Windows should now implicitly initialize the underlying socket subsystem.</p><p>0.7.7 has only about 11 fixes, which reflects the relatively few bugs encountered in the 0.7.7 cycle. There are outstanding bugs on the inline asm, which has a significant update planned. The most important fix is patching a regression for MacOS which prevented backtrace printing.</p><p>With the updated Vector ABI and the change from  to  there are a lot of vendor libraries that will need a refresh. There is also a new matrix library in development that hopefully might get included in the next release. There is more functionality to add for fine-tuning processor capabilities for both RISC-V, but also AArch64. There have also been requests for 32-bit Arm support, but the lack of CI tests for different Arm processors is blocking it at the moment.</p><p>This release wouldn‚Äôt have been possible without the C3 community. I‚Äôd like to extend a deep thank you to all who have contributed, both through filed issues, PRs and just plain discussions.</p><p>Have questions? Come and chat with us on <a href=\"https://discord.gg/qN76R87\">Discord</a>.</p><p>Discuss this article on <a href=\"https://www.reddit.com/r/programming/comments/1okzgsu/c3_077_vector_abi_changes_riscv_improvements_and/?utm_source=share&amp;utm_medium=web3x&amp;utm_name=web3xcss&amp;utm_term=1&amp;utm_content=share_button\">Reddit</a>.</p>","contentLength":4297,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/programming/comments/1okzgsu/c3_077_vector_abi_changes_riscv_improvements_and/"}],"tags":["dev","reddit"]}