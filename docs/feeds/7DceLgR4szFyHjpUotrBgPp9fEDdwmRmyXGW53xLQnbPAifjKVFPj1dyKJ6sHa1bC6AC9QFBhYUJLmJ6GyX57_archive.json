{"id":"7DceLgR4szFyHjpUotrBgPp9fEDdwmRmyXGW53xLQnbPAifjKVFPj1dyKJ6sHa1bC6AC9QFBhYUJLmJ6GyX57","title":"top scoring links : linux","displayTitle":"Reddit - Linux","url":"https://www.reddit.com/r/linux/top/.rss?sort=top&t=day&limit=6","feedLink":"https://www.reddit.com/r/linux/top/?sort=top&t=day&limit=6","isQuery":false,"isEmpty":false,"isHidden":false,"itemCount":6,"items":[{"title":"Video: LibreOffice 25.8 – Some of the new features","url":"https://www.youtube.com/watch?v=6dIRR37PF7M","date":1755938047,"author":"/u/themikeosguy","guid":576,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1mxw2e2/video_libreoffice_258_some_of_the_new_features/"},{"title":"What on Earth Does Pointer Provenance Have to do With RCU?","url":"https://people.kernel.org/paulmck/what-on-earth-does-lifetime-end-pointer-zap-have-to-do-with-rcu","date":1755923066,"author":"/u/unixbhaskar","guid":573,"unread":true,"content":"<p>TL;DR: Unless you are doing very strange things with RCU, not much!!!</p><p>So why has the guy most responsible for Linux-kernel spent so much time over the past five years working on the provenance-related lifetime-end pointer zap within the C++ Standards Committee?</p><h2>What is Pointer Provenance?</h2><p>Back in the old days, provenance was for objets d'art and the like, and we did not need them for our pointers, no sirree!!!  Pointers had bits, those bits formed memory addresses, and as often as not we didn't even need to worry about these addresses being translated.  But life is more complicated now.  On the other hand, computing life is also much bigger, faster, more reliable, and (usually) more productive, so be extremely careful what you wish for from back in the Good Old Days!</p><p>These days, pointers have provenance as well as addresses, and this has consequences.  The C++ Standard  (<a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/n5008.pdf\" rel=\"nofollow\">recent draft</a>) states that when an object's storage duration ends, any pointers to that object become invalid.  For its part, the C Standard states that when an object's storage duration ends, any pointers to that object become indeterminate.  In both standards, the wording is more precise, but this will serve for our purposes.</p><p>For the remainder of this document, we will follow C++ and say “invalid”, which is shorter than “indeterminate”.  We will balance this out by using C-language example code.  Those preferring C++ will be happy to hear that this is the language that I use in my <a href=\"https://cppcon2025.sched.com/event/27bR6/interesting-upcoming-low-latency-concurrency-and-parallelism-features-from-wroclaw-2024-hagenberg-2025-and-sofia-2025\" rel=\"nofollow\">upcoming CPPCON presentation</a>.</p><p>Neither standard places any constraints on what a compiler can do with an invalid pointer value, even if all you are doing is loading or storing that value.</p><p>Those of us who cut our teeth on assembly language might quite reasonably ask why anyone would even think to make pointers so invalid that you cannot even load or store them.  Let's start by looking at pointer comparisons using this code fragment:</p><pre><code>p = kmalloc(...);\nmight_kfree(p);         // Pointer might become invalid (AKA \"zapped\")\nq = kmalloc(...);       // Assume that the addresses of p and q are equal.\nif (p == q)             // Compiler can optimize as \"if (false)\"!!!\n    do_something();\n</code></pre><p>Both  and  contain addresses, but the compiler also keeps track of the fact that their values were obtained from different invocations of .  This information forms part of each pointer's provenance.  This means that  and  have different provenance, which in turn means that the compiler does not need to generate any code for the  comparison.  The two pointers' provenance differs, so the result cannot be anything other than .</p><p>And this is one motivation for pointer provenance and invalidity:  The results of operations on invalid pointers are not guaranteed, which provides additional opportunities for optimization.  This example perhaps seems a bit silly, but modern compilers can use pointer provenance and invalidity to carry out serious points-to and aliasing analysis.</p><p>Yes, you can have hardware provenance.  Examples include ARM MTE, the CHERI research prototype (which last I checked had issues with C++'s requirement that pointers are trivially copiable), and the venerable IBM System i.  Conventional systems provide pointer provenance of a sort via their page tables, which is used by a variety of memory-allocation-use debuggers, for but one example, the efence library.  The pointer-provenance features of ARM MTE and IBM System i are not problematic, but last I checked, the jury was still out on CHERI.</p><p>Of course, using invalid (AKA “dangling”) pointers is known to be a bad idea.  So why are we even talking about it???</p><h2>Why Would Anyone Use Invalid/Dangling Pointers?</h2><p>Please allow me to introduce you to the famous and frequently re-invented LIFO Push algorithm.  You can find this in many places, but let's focus on the Linux kernel's  and  functions.  The former atomically pushes a list of elements on a linked-list stack, and the latter just as atomically removes the entire contents of the stack:</p><pre><code>static inline bool llist_add_batch(struct llist_node *new_first,\n                                   struct llist_node *new_last,\n                                   struct llist_head *head)\n{\n    struct llist_node *first = READ_ONCE(head-&gt;first);\n\n    do {\n        new_last-&gt;next = first;\n    } while (!try_cmpxchg(&amp;head-&gt;first, &amp;first, new_first));\n\n    return !first;\n}\n\nstatic inline struct llist_node *llist_del_all(struct llist_head *head)\n{\n    return xchg(&amp;head-&gt;first, NULL);\n}\n</code></pre><p>As lockless concurrent algorithms go, this one is pretty straightforward.  The  function reads the list header, fills in the  pointer, then does a compare-and-exchange operation to point the list header at the new first element.  The  function is even simpler, doing a single atomic exchange operation to  out the list header and returning the elements that were previously on the list.  This algorithm also has excellent forward-progress properties: the  function is lock-free and the  function is wait-free.</p><p>In assembly language, or with a simple compiler, not much.  But to see the pointer-provenance issue with more heavily optimized languages, consider the following sequence of events:</p><ol><li>CPU 0 allocates an  B and passes it via both the  and  parameters of .</li><li>CPU 0 picks up the  pointer and places it in the  local variable, then assigns it to .  This  pointer now references  A.</li><li>CPU 1 invokes , which returns a list containing  A.  The caller of  processes A and passes it to .</li><li>CPU 0's  pointer is now invalid due to  A having been freed.  But CPU 0 does not know this.</li><li>CPU 1 allocates an  C that happens to have the same address as the old  A.  It passes C  via both the  and  parameters of , which runs to completion.  The  pointer now points to  C, which happens to have the same address as the now storage-duration-ended  A.</li><li>CPU 0 finally gets around to executing its , which given typical C compilers will succeed.  The  now contains an  B that contains an invalid pointer to dead  A, but whose pointer address happens to reference the shiny new  C.  (We term this invalid pointer a “zombie pointer” because it has in some assembly-language sense come back from the dead.)</li><li>Some CPU invokes  and gets back an  containing an invalid pointer.</li></ol><p>One could argue that the Linux-kernel implementation of LIFO Push is simply buggy and should be fixed.  Except that there is no reasonable way to fix it.  Which of course raises the question...</p><h2>What Are Unreasonable Fixes?</h2><p>We can protect pointers from invalidity by storing them as integers, but:</p><ol><li>Suppose someone has an element that they are passing to a library function.  They should not be required to convert all their  pointers to integer just because the library's developers decide to switch to the LIFO Push algorithm for some obscure internal operation.</li><li>In addition, switching to integer defeats type-checking, because integers are integers no matter what type of pointer they came from.</li><li>We could restore some type-checking capability by wrapping the integer into a differently named struct for each pointer type.  Except that this requires a struct with some particular name to be treated as compatible with pointers of some type corresponding to that name, a notion that current do not support.</li><li>In C++, we could use template metaprogramming to wrap an integer into a class that converts automatically to and from compatibly typed pointers.  But there would then be windows of time in which there was a real pointer, and at that time there would still be the possibility of pointer invalidity.</li><li>All of the above hack-arounds put additional obstacles in the way of developers of concurrent software.</li><li>In environments such as the Linux kernel that provides their own memory allocators, we can hide them from the compiler.  But this is not free, in fact, the patch that exposed the Linux-kernel's memory allocators to the compiler resulted in a small but significant improvement.</li></ol><p>However, it is fair to ask...</p><h2>Why Do We Care About Strange New Algorithms???</h2><p>Let's take a look at the history, courtesy of Maged Michael's diligent software archaeology.</p><p>In 1986, R. K. Treiber presented an assembly language implementation of the LIFO Push algorithm in technical report RJ 5118 entitled “Systems Programming: Coping with Parallelism” while at the IBM Almaden Research Center.</p><p><a href=\"https://patents.google.com/patent/US3886525\" rel=\"nofollow\">US Patent 3,886,525</a> was filed in June 1973, just a few months before I wrote my first line of code, and contains a prior-art reference to the LIFO Push algorithm (again with pop() instead of popall()) as follows: “Conditional swapping of a single address is sufficient to program a last-in, first-out single-user-at-a-time sequencing mechanism.”  (If you were to ask a patent attorney, you would likely be told that this 50-year-old patent has long since expired.  Which should be no surprise, given that it is even older than Dennis Ritchie's setuid <a href=\"https://patents.google.com/patent/US4135240A/en\" rel=\"nofollow\">Patent 4,135,240</a>.)</p><p>All three of these references describe LIFO push as if it was straightforward and well known.</p><p>So we don’t know who first invented LIFO Push or when they invented it, but it was well known in 1973.  Which is well over a decade before C was first standardized, more than two decades before C++ was first standardized, and even longer before work was started on Rust.</p><p>And its combination of (relative) simplicity and excellent forward-progress properties just might be why this algorithm was anonymously invented so long ago and why it is so persistently and repeatedly reinvented.  This frequent reinvention puts paid to any notion that LIFO Push is strange.</p><p>So sorry, but LIFO Push is neither new nor strange.</p><p>The lifetime-end pointer-zap story is not yet over, but we are currently pushing for the changes in four working papers.</p><h3>Nondeterministic Pointer Provenance</h3><p><a href=\"https://isocpp.org/files/papers/P2434R4.html\" rel=\"nofollow\">P2434R4 (“Nondeterministic pointer provenance”)</a> is the basis for the other three papers.  It asks that when converting a pointer to an integer and back, the implementation must choose a qualifying pointed-to object (if there is one) whose storage duration began before or concurrently with the conversion back to a pointer.  In particular, the implementation is free to ignore a qualifying pointed-to object when the conversion to pointer happens before the beginning of that object’s storage duration.</p><p>The “qualifying” qualifier includes compatible type, as well as sufficiently early and long storage duration.</p><p>But why restrict the qualifying pointed-to object's storage duration to begin before or concurrently with the conversion back to a pointer?</p><p>An instructive example by Hans Boehm may be found in P2434R4, which shows that reasonable (and more important, very heavily used) optimizations would be invalidated by this approach.  Several examples that manage to be even more sobering may be found in David Goldblatt's <a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3292r0.html\" rel=\"nofollow\">P3292R0 (“Provenance and Concurrency”)</a>.</p><h3>Pointer Lifetime-End Zap Proposed Solutions: Atomics and Volatile</h3><p><a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2414r9.pdf\" rel=\"nofollow\">P2414R10 (“Pointer lifetime-end zap proposed solutions: Atomics and volatile”)</a> is motivated by the observation that atomic pointers are subject to update at any time by any thread, which means that the compiler cannot reasonably do much in the way of optimization.  This paper therefore asks (1) that atomic operations be redefined to yield and to store prospective pointers values and (2) that operations on volatile pointers be defined to yield and to store prospective pointer values.  The effect is as if atomic pointers were stored internally as integers. This includes the “old” pointer passed by reference to compare_exchange().</p><p>This helps, but is not a full solution because atomic pointers are converted to non-atomic pointers prior to use, at which point they are subject to lifetime-end pointer zap.  And the standard does not even guarantee that a zapped pointer can even be loaded, stored, passed to a function, or returned from a function.  Which brings us to the next paper.</p><h3>Pointer Lifetime-End Zap Proposed Solutions: Tighten IDB for Invalid Pointers</h3><p><a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3347r3.pdf\" rel=\"nofollow\">P3347R3 (“Pointer lifetime-end zap proposed solutions: Tighten IDB for invalid pointers”)</a> therefore asks that all non-comparison non-arithmetic non-dereference computations involving pointers, specifically including normal loads and stores, are fully defined even if the pointers are invalid.  This permits invalid pointers to be loaded, stored, passed as arguments, and returned.  Fully defining comparisons would rule out optimizations, and fully defining arithmetic would be complex and thus far unneeded.</p><p>If these first three papers are accepted into the standard, the C++ implementation of LIFO Push show above becomes valid code.  This is important because this algorithm has been re-invented many times over the past half century, and is often open coded.  This makes it very hard to construct tools that find LIFO Push implementations in existing code.</p><h3>P3790R1: Pointer Lifetime-End Zap Proposed Solutions: Bag-of-Bits Pointer Class</h3><p><a href=\"https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3790r0.pdf\" rel=\"nofollow\">P3790R1 (“Pointer lifetime-end zap proposed solutions: Bag-of-bits pointer class”)</a> asks that (1) the addition to the C++ standard library of the function <code>launder_bag_of_bits_ptr()</code> that takes a pointer argument and returns a prospective pointer value corresponding to its argument; and (2) the addition to the C++ standard library of the class template  that is a pointer-like type that is still usable after the pointed-to object’s lifetime has ended.  Of course, such a pointer still cannot be dereferenced unless there is a live object at that pointer's address.  Furthermore, some systems, such as ARMv9 with memory tagging extensions (MTE) enabled have provenance as well as address bits in the pointer, and on such systems dereferencing will fail unless the pointer's provenance bits happen to match those of the pointed-to object.</p><p>This function and template class is nevertheless quite useful for maintaining hash maps keyed by pointers after the pointed-to object's lifetime has ended.</p><p>Unlike LIFO Push, source-code changes are required for these use cases.  This is unfortunate, but we have thus far been unable to come up with a same-source-code approach.</p><p>Those who have participated in standards work (or even open-source work) will understand that the names <code>launder_bag_of_bits_ptr()</code> and  are still subject to bikeshedding.</p><h2>A Happen Lifetime-End Pointer Zap Ending?</h2><p>It is still too early to say for certain, but thus far these proposals are making much better progress than did their predecessors.  So who knows?  Perhaps C++29 will address lifetime-end pointer zap.</p>","contentLength":14444,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1mxrwl4/what_on_earth_does_pointer_provenance_have_to_do/"},{"title":"This month in Servo: new image formats, canvas backends, automation, and more!","url":"https://servo.org/blog/2025/08/22/this-month-in-servo/","date":1755914332,"author":"/u/KlasySkvirel","guid":574,"unread":true,"content":"<p>Servo has smashed its record again in July, with  landing in our nightly builds!\nThis includes several new web platform features:</p><p>Notable changes for Servo library consumers:</p><p>Like many browsers, Servo has two kinds of zoom:  affects the size of the viewport, while  does not (<a href=\"https://github.com/shubhamg13\">@shubhamg13</a>, <a href=\"https://github.com/servo/servo/pull/38194\">#38194</a>).\n now correctly triggers reflow (<a href=\"https://github.com/mrobinson\">@mrobinson</a>, <a href=\"https://github.com/servo/servo/pull/38166\">#38166</a>), and  is now reset to the viewport meta config when navigating (<a href=\"https://github.com/shubhamg13\">@shubhamg13</a>, <a href=\"https://github.com/servo/servo/pull/37315\">#37315</a>).</p><p> is now isolated between webviews, and copied to new webviews with the same  (<a href=\"https://github.com/janvarga\">@janvarga</a>, <a href=\"https://github.com/servo/servo/pull/37803\">#37803</a>).</p><p> now has a  and , so you can now  on Linux (<a href=\"https://github.com/MichaelMcDonnell\">@MichaelMcDonnell</a>, <a href=\"https://github.com/servo/servo/pull/38038\">#38038</a>).\nWe’ve made it more ergonomic too, fixing both the sluggish  and <strong>pixel-perfect trackpad scrolling</strong> and the too fast  (<a href=\"https://github.com/yezhizhen\">@yezhizhen</a>, <a href=\"https://github.com/servo/servo/pull/37982\">#37982</a>).</p><p> is key to programmable graphics on the web, with Servo supporting WebGPU, WebGL, and 2D canvas contexts.\nBut the <strong>general-purpose 2D graphics</strong> routines that power Servo’s 2D canvases are potentially useful for a lot more than &lt;canvas&gt;:  is bread and butter for Servo, but  is only minimally supported right now, and  is not yet implemented at all.</p><p>Those features have one thing in common: they require things that WebRender can’t yet do.\n does one thing and does it well: rasterise the layouts of the web, really fast, by <a href=\"https://hacks.mozilla.org/2017/10/the-whole-web-at-maximum-fps-how-webrender-gets-rid-of-jank/\">using the GPU as much as possible</a>.\nFont rendering and SVG rendering both involve rasterising arbitrary paths, which currently has to be done outside WebRender, and PDF output is out of scope entirely.</p><p>The more code we can share between these tasks, the better we can make that code, and the smaller we can make Servo’s binary sizes (<a href=\"https://github.com/servo/servo/issues/38022\">#38022</a>).\nWe’ve started by moving 2D-&lt;canvas&gt;-specific state out of the  crate (<a href=\"https://github.com/sagudev\">@sagudev</a>, <a href=\"https://github.com/servo/servo/pull/38098\">#38098</a>, <a href=\"https://github.com/servo/servo/pull/38114\">#38114</a>, <a href=\"https://github.com/servo/servo/pull/38164\">#38164</a>, <a href=\"https://github.com/servo/servo/pull/38214\">#38214</a>), which has in turn allowed us to modernise it with <strong>new backends based on <a href=\"https://github.com/linebender/vello\">Vello</a></strong> (<a href=\"https://github.com/EnnuiL\">@EnnuiL</a>, <a href=\"https://github.com/sagudev\">@sagudev</a>, <a href=\"https://github.com/servo/servo/issues/30636\">#30636</a>, <a href=\"https://github.com/servo/servo/issues/38345\">#38345</a>):</p><ul><li><p>a Vello GPU-based backend (<a href=\"https://github.com/sagudev\">@sagudev</a>, <a href=\"https://github.com/servo/servo/pull/36821\">#36821</a>), currently slower than the default backend; to use it, build Servo with  and enable it with <code>--pref dom_canvas_vello_enabled</code></p></li><li><p>a Vello CPU-based backend (<a href=\"https://github.com/sagudev\">@sagudev</a>, <a href=\"https://github.com/servo/servo/pull/38282\">#38282</a>), <strong>already faster than the default backend</strong>; to use it, build Servo with  and enable it with <code>--pref dom_canvas_vello_cpu_enabled</code></p></li></ul><p>Many recent Servo bugs have been related to our handling of , , and  (<a href=\"https://github.com/servo/servo/issues/36817\">#36817</a>, <a href=\"https://github.com/servo/servo/issues/37804\">#37804</a>, <a href=\"https://github.com/servo/servo/issues/37824\">#37824</a>, <a href=\"https://github.com/servo/servo/issues/37878\">#37878</a>, <a href=\"https://github.com/servo/servo/issues/37978\">#37978</a>, <a href=\"https://github.com/servo/servo/issues/38089\">#38089</a>, <a href=\"https://github.com/servo/servo/issues/38090\">#38090</a>, <a href=\"https://github.com/servo/servo/issues/38093\">#38093</a>, <a href=\"https://github.com/servo/servo/issues/38255\">#38255</a>).\nSymptoms of these bugs include  (e.g. links that can’t be clicked),  to the end of the page, or  like disappearing browser UI or black bars.</p><p>Windows rarely take up the whole screen, viewports rarely take up the whole window due to window decorations, and when different units come into play, like CSS  vs device pixels, a more systematic approach is needed.\nWe built <a href=\"https://docs.rs/euclid/0.22.11/euclid/\"></a> to solve these problems in a strongly typed way within Servo, but beyond the viewport, we need to convert between euclid types and the geometry types provided by the embedder, the toolkit, the platform, or WebDriver, which creates opportunities for errors.</p><p>Servo is also on <a href=\"https://thanks.dev\">thanks.dev</a>, and already  (−3 from June) that depend on Servo are sponsoring us there.\nIf you use Servo libraries like <a href=\"https://crates.io/crates/url/reverse_dependencies\">url</a>, <a href=\"https://crates.io/crates/html5ever/reverse_dependencies\">html5ever</a>, <a href=\"https://crates.io/crates/selectors/reverse_dependencies\">selectors</a>, or <a href=\"https://crates.io/crates/cssparser/reverse_dependencies\">cssparser</a>, signing up for <a href=\"https://thanks.dev\">thanks.dev</a> could be a good way for you (or your employer) to give back to the community.</p><p>As always, use of these funds will be decided transparently in the Technical Steering Committee.\nFor more details, head to our <a href=\"https://servo.org/sponsorship/\">Sponsorship page</a>.</p>","contentLength":3367,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1mxp3nt/this_month_in_servo_new_image_formats_canvas/"},{"title":"I'm making a freeware Linux Learning Game and could use some QA, Criticism, and feedback.","url":"https://www.reddit.com/r/linux/comments/1mxgm8l/im_making_a_freeware_linux_learning_game_and/","date":1755892448,"author":"/u/nconsola","guid":577,"unread":true,"content":"<p>I hope I can post here, I read the rules and I’m not trying to self-promoter, as I’m going to release this Linux learning game for free and make it open source when complete.</p><p>I am making a simple text-based game that is 100% focused on learning Linux command line, this game is not focused on specific distros of Linux like Ubuntu or Debian, it is Basic Standard Linux. If people like the game I will make others that are continuations off of this, that are specific to distros but for now its base Linux.</p><p>Quick background, I DO NOT KNOW LINUX, but we use it at work (Debian) and I need to learn it. This is why I made this game, every time I try to learn the commands ill forget them or say screw it, I will use the GUI. So, I thought if I had a game that focused on teaching me Linux, I could do it.... yeah, I know probably not going to happen, but still I set off to make it, and with the help of Google Gemini I have a solid Beta of the game, maybe Alpha/Beta, maybe Alpha. There is a lot I want to add after the instruction part of the game which is all I have now, so it is not complete just the 3 chapters that are below.</p><p>Through QA'ing the game myself I have learned a ton about command line. But as anyone who has QA a game before, you eventually know what to put in to get to the next part, and this doesn’t give a good representation of whether or not the game is teaching well for people who just pick it up. So, I’m looking for any testers who know Linux, and anyone who doesn’t.</p><p>I want people who know Linux, this way I can make sure all the commands work as they should, basically \"look\" the way they should in the simulated terminal, and to make sure I have all the commands that are available for basic Linux, and provide feedback where needed.</p><p>I want people who don’t know Linux, this way I can get feedback on the way the game progresses, does it make sense, do you actually feel like you’re learning Linux while playing, is it confusing, what do you not like, etc.</p><p>A little bit on what I have implemented so far,</p><p>some simple non game elements are,</p><ol><li><p>Terminal themes, so I have Default theme (supposed to simulate the terminal from the movie Alien, its close but not 100%), Commodore 64, Dos, Linux, and Apple II+ (which was my first computer)</p></li><li><p>A voice over on/off switch for the simulated AI, Aurora, it’s not a real AI or even a LLM it’s just simulated, all the commands and responses I have put in, and it is basic right now. But as the user you are being helped by a ship AI which is basically teaching you the Linux commands. And yeah, it was the closest voice I could get to simulate Mother in the movie Alien, and it sounds nothing like Mother.</p></li></ol><p>There is a beginner, intermediate, and advanced sections of the game, that teach you the following commands. Someone who knows Linux really good please let me know if you think anything is missing, but remember this is basic Linux so there is no apt-get etc. like in Debian, at least as far as I know.</p><p>* `help` - Shows available commands.</p><p>* `pwd` - Prints the current working directory.</p><p>* `ls` - Lists files and directories.</p><p>* `~` - A shortcut for the user's home directory.</p><p>* `clear` - Clears the terminal screen.</p><p>* `cat` - Displays the contents of a file.</p><p>* `hint` - Provides a hint for the current objective.</p><p>* `man` - Shows the manual page for a command.</p><p>* `cd` - Changes the current directory.</p><p>* `uptime` - Shows how long the system has been running.</p><p>* `echo` - Displays text or writes it to a file.</p><p>* `mkdir` - Creates a new directory.</p><p>* `touch` - Creates a new, empty file.</p><p>* `&gt;` - A redirection operator to write output to a file.</p><p>* `rm` - Removes (deletes) files.</p><p>* `rmdir` - Removes (deletes) empty directories.</p><p>* `mv` - Moves or renames files and directories.</p><p>* `less` - Views the content of a file page by page.</p><p>* `grep` - Searches for patterns within files.</p><p>* `find` - Searches for files and directories.</p><p>* `head` - Displays the beginning of a file.</p><p>* `tail` - Displays the end of a file.</p><p>* `wc` - Counts lines, words, and characters in a file.</p><p>* `sort` - Sorts the lines of a file.</p><p>* `|` - The \"pipe\" operator, used to send the output of one command to another.</p><p>* `uniq` - Removes duplicate adjacent lines from a file.</p><p>* `diff` - Compares two files and shows their differences.</p><p>* `ln` - Creates links between files.</p><p>* `uname` - Shows system information.</p><p>* `whoami` - Shows the current user's username.</p><p>* `groups` - Shows the groups a user belongs to.</p><p>* `dmesg` - Shows kernel and driver messages.</p><p>* `free` - Displays memory usage.</p><p>* `df` - Displays disk space usage.</p><p>* `du` - Shows the disk usage of files and directories.</p><p>* `tree` - Displays a directory's contents in a tree-like format.</p><p>* `file` - Determines a file's type.</p><p>* `cmp` - Compares two files byte by byte.</p><p>* `cut` - Extracts sections from lines of a file.</p><p>* `tr` - Translates or deletes characters.</p><p>* `&lt;` - A redirection operator to use a file's content as input.</p><p>* `tee` - Reads from standard input and writes to both standard output and files.</p><p>* `locate` - Finds files by name quickly.</p><p>* `chmod` - Changes the permissions of a file or directory.</p><p>* `sudo` - Executes a command as the superuser (root).</p><p>* `chown` - Changes the owner of a file or directory.</p><p>* `umask` - Sets the default permissions for new files.</p><p>* `split` - Splits a file into smaller pieces.</p><p>* `paste` - Merges the lines of files.</p><p>* `join` - Joins the lines of two files on a common field.</p><p>* `tar` - Creates and extracts archive files.</p><p>* `gzip` - Compresses or decompresses files.</p><p>* `gunzip` - Decompresses `.gz` files.</p><p>* `zip` - Creates a `.zip` archive.</p><p>* `unzip` - Extracts files from a `.zip` archive.</p><p>* `sed` - A stream editor for filtering and transforming text.</p><p>* `awk` - A powerful pattern scanning and processing language.</p><p>* `ping` - Tests network connectivity to a host.</p><p>* `traceroute` - Traces the network path to a host.</p><p>* `curl` - Transfers data from or to a server.</p><p>* `ps` - Shows currently running processes.</p><p>* `top` - Displays a dynamic, real-time view of processes.</p><p>* `htop` - An interactive process viewer.</p><p>* `netstat` - Shows network connections and statistics.</p><p>* `kill` - Sends a signal to a process (e.g., to terminate it) by its ID.</p><p>* `pkill` - Sends a signal to a process by its name.</p><p>* `iostat` - Reports CPU and I/O statistics.</p><p>* `vmstat` - Reports virtual memory statistics.</p><p>* `sar` - Collects and reports system activity information.</p><p>* `passwd` - Changes a user's password.</p><p>* `groupadd` - Creates a new user group.</p><p>* `useradd` - Creates a new user account.</p><p>* `usermod` - Modifies an existing user account.</p><p>* `userdel` - Deletes a user account.</p><p>* `groupdel` - Deletes a user group.</p><p>* `systemctl` - Manages system services.</p><p>* `bg` - Sends a job to the background.</p><p>* `fg` - Brings a job to the foreground.</p><p>* `jobs` - Lists active jobs.</p><p>* `mount` - Mounts a filesystem.</p><p>* `umount` - Unmounts a filesystem.</p><p>* `rsync` - Synchronizes files and directories between locations.</p><p>* `dd` - Copies and converts files at a low level.</p><p>* `lsof` - Lists open files.</p><p>* `crontab` - Manages scheduled tasks (cron jobs).</p><p>I’ve been working on the game for almost 4 months, and rewritten this game from scratch 3 times now, which sucks, but when I seem to make major changes I break things, and as I’m not a good programmer, I rely on AI (Google Gemini), and as anyone who has used any AI programmer you know sometimes it decides to just DESTROY EVERYTHING YOU HAVE CREATED BEYOND REPAIR! So, when you go through the Beginner section you will notice that all the commands you need to run are explained by the ship AI and it is 99% complete as far as I can tell. The intermediate and advanced sections so far have everything working, as in the commands to move on to the next section, but you need to talk to the ship AI for every new command you need to enter to complete the task. So, it works functionally as far as I last tested, but you need to ask Aurora what to do next all the time, which is a pain in the ass. But That will be fixed as soon as I know everything else in the Beginner section is working, as I don’t want to update everything to just have to redo it if I messed something up in the beginner part.</p><p>Once the 3 parts are complete, I can then work on the, story part, which as of my planning will have 3 endings depending on how the player uses the Linux commands, and what they do in the game. The story part will be used as repetition on the commands from the previous 3 parts, this way it will hopefully burn the Linux commands into our heads, and we become Linux gods.</p><p>So, what’s the premise of the game. You are a sole caretaker (except for the ship AI, Aurora) of a spaceship on a deep space mission. Something happened on the ship and the AI sent you to the Engineering Bay and converted all life support to that area before shutting down to conserver power as the power is draining as well. The ship is run on a Linux system, and you need to get it back up and running before the Life support and Power go to 0% and you die. But you don’t know Linux, so the localized version of the ship AI, Aurora, is there to talk you through how to fix the ship and bring the systems back up using just Linux commands from the one terminal that is working. once you get everything back up and running stably, then you need to go through and see what happened. From this point on is the story part of the game and will involve going into the ships servers to find out what happened and what else needs to be fixed, etc.</p><p>The game is all web browser bases so far, when done I’ll be able to port it to windows, Linux, mobile, at least that is what Google Gemini told me. So, I can put all the files in a Zip, or upload to my google drive, or can I upload here? I don’t want to upload here yet unless I get permission, as I believe it was one of the rules, unless I read it wrong.</p>","contentLength":9738,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Anybody using multi-seat? This is my Ubuntu 24.04 multi-seat setup for my kids.","url":"https://www.reddit.com/r/linux/comments/1mxcodi/anybody_using_multiseat_this_is_my_ubuntu_2404/","date":1755883456,"author":"/u/Rob_Bob_you_choose","guid":578,"unread":true,"content":"","contentLength":0,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":null},{"title":"Quickly navigate in man pages, using emacs, neovim or w3m.","url":"https://codeberg.org/chimay/blog/src/commit/02bdd1d592f7130c2dd2cc13e35a63c551387e91/meta/man-pages.org","date":1755870977,"author":"/u/orduval","guid":575,"unread":true,"content":"<p>\nNeovim offers a nice man view with the  command.  It can handle\nreferences by using  over the word, which can easily be remapped to\nthe return key.</p><p>\nIt even has a table of content, but it's too cluttered for my taste, so I\ndecided to write my own version of it, displaying only the minimum I need.</p><p>\nFirst, let's write some functions in ~/.config/nvim/autoload/library.vim :</p><div><pre><code>## %\n\t# %\n\t##</code></pre></div><p>\nThen, go back to ~/.config/nvim/init.vim and let's map the \nwrapper to e.g.  :</p><div><pre><code>#</code></pre></div><p>\nFinally, use buffer local maps triggered when\nentering a man buffer :</p><div><pre><code>####</code></pre></div><p>\nDone! Now, try  and enter e.g.  to the prompt.  The key :</p><ul><li> opens the toc/link window</li><li> closes the toc/link window</li><li> deletes the man page buffer</li></ul><p>In the man buffer, you can press  (enter) over a reference\n(i.e. link) to follow it.</p>","contentLength":762,"flags":null,"enclosureUrl":"","enclosureMime":"","commentsUrl":"https://www.reddit.com/r/linux/comments/1mx77vh/quickly_navigate_in_man_pages_using_emacs_neovim/"}],"tags":["dev","reddit"]}